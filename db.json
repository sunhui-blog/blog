{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/basic.jpg","path":"img/basic.jpg","modified":0,"renderable":0},{"_id":"source/img/cactus.jpg","path":"img/cactus.jpg","modified":0,"renderable":0},{"_id":"source/img/deer.jpg","path":"img/deer.jpg","modified":0,"renderable":0},{"_id":"source/img/desert.jpg","path":"img/desert.jpg","modified":0,"renderable":0},{"_id":"source/img/execute.png","path":"img/execute.png","modified":0,"renderable":0},{"_id":"source/img/flower.jpg","path":"img/flower.jpg","modified":0,"renderable":0},{"_id":"source/img/pen.jpg","path":"img/pen.jpg","modified":0,"renderable":0},{"_id":"source/img/plant.jpg","path":"img/plant.jpg","modified":0,"renderable":0},{"_id":"source/img/shell.jpg","path":"img/shell.jpg","modified":0,"renderable":0},{"_id":"source/img/shadow.jpeg","path":"img/shadow.jpeg","modified":0,"renderable":0},{"_id":"source/img/eventloop.jpg","path":"img/eventloop.jpg","modified":0,"renderable":0},{"_id":"source/img/vuerouter/matched.png","path":"img/vuerouter/matched.png","modified":0,"renderable":0},{"_id":"source/img/performance.jpg","path":"img/performance.jpg","modified":0,"renderable":0},{"_id":"source/img/tree.jpeg","path":"img/tree.jpeg","modified":0,"renderable":0},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/clipboard.js","path":"js/clipboard.js","modified":0,"renderable":1},{"_id":"source/img/chrome/eventmodel.jpg","path":"img/chrome/eventmodel.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/eventflow.jpg","path":"img/chrome/eventflow.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/procedure.jpg","path":"img/chrome/procedure.jpg","modified":0,"renderable":0},{"_id":"source/img/network/tcp.png","path":"img/network/tcp.png","modified":0,"renderable":0},{"_id":"source/img/koa/enter.png","path":"img/koa/enter.png","modified":0,"renderable":0},{"_id":"source/img/paradigm/aop.jpg","path":"img/paradigm/aop.jpg","modified":0,"renderable":0},{"_id":"source/img/vuerouter/error.png","path":"img/vuerouter/error.png","modified":0,"renderable":0},{"_id":"source/img/chrome/addEventListener.jpg","path":"img/chrome/addEventListener.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/observer.jpg","path":"img/chrome/observer.jpg","modified":0,"renderable":0},{"_id":"source/img/vuerouter/samerouter.png","path":"img/vuerouter/samerouter.png","modified":0,"renderable":0},{"_id":"source/img/chrome/soucecode.jpg","path":"img/chrome/soucecode.jpg","modified":0,"renderable":0},{"_id":"source/img/knowledge.png","path":"img/knowledge.png","modified":0,"renderable":0},{"_id":"source/img/HomeBrew/1.png","path":"img/HomeBrew/1.png","modified":0,"renderable":0},{"_id":"source/img/network/osi.png","path":"img/network/osi.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"8e83b85a1b24fbfc4142fb77e5ac12b4011e49d7","modified":1560073232000},{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1549071164000},{"_id":"themes/icarus/_config.yml","hash":"de052892be6d9ae8cc2c236ea24988f214660c5d","modified":1610366084584},{"_id":"themes/icarus/.DS_Store","hash":"ff6a009391fa48ef38559616dc5134d9e9aa9484","modified":1549959122000},{"_id":"themes/icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1549071164000},{"_id":"themes/icarus/README.md","hash":"4409383fbd7422800049d6597e9b26aa8db66b66","modified":1549071164000},{"_id":"themes/icarus/package.json","hash":"4167e65682af257bdf8531a05730e6c42339996d","modified":1549071164000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1560072188000},{"_id":"source/img/basic.jpg","hash":"5d7b639f775afa4daf75a312bba03e6746574e42","modified":1563709812000},{"_id":"source/img/cactus.jpg","hash":"5162330a4466000f75ef352f8fc60d8c4400aedd","modified":1570759443000},{"_id":"source/img/deer.jpg","hash":"aeeb445722949281bda6df0b622dfd433e0ec41d","modified":1558888562000},{"_id":"source/img/desert.jpg","hash":"f2cfe1cd15e66db283a72600643df284a41216a2","modified":1558888796000},{"_id":"source/img/execute.png","hash":"f3e9ff6d95473eaa6c1600fa7c29e4298389ae0f","modified":1610741417699},{"_id":"source/img/flower.jpg","hash":"692f8f93097723856d46f1c403664059e68614ca","modified":1558889354000},{"_id":"source/img/pen.jpg","hash":"7f3782cc4f2de0bd5fd3dba65dd0f00a9d8f6dfb","modified":1580137595000},{"_id":"source/img/plant.jpg","hash":"a1d8e7cb1b4f38feea0cd3bdba4b50194472af1c","modified":1558889193000},{"_id":"source/img/shell.jpg","hash":"83257359649e0926b8fdaa6cb3c03752fe72abb0","modified":1560073698000},{"_id":"source/img/shadow.jpeg","hash":"b58c631c608d006693d8ed94c2a01673cef70ee6","modified":1558889572000},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"6b17b84116938367757928087a09dcb8489d06f6","modified":1549071164000},{"_id":"themes/icarus/languages/es.yml","hash":"8827823e5b2ce967566854c9bfebc7c69098b4ac","modified":1549071164000},{"_id":"themes/icarus/languages/en.yml","hash":"159f5ff384156c8deb6e275ea79400e3739480ee","modified":1551890465000},{"_id":"themes/icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1549071164000},{"_id":"themes/icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1549071164000},{"_id":"themes/icarus/languages/ko.yml","hash":"06d2bb8b66f68f780218e0ba7edffe1e57fac268","modified":1549071164000},{"_id":"themes/icarus/languages/id.yml","hash":"ca7d51748e6031b8a36c20183c8114a956b80010","modified":1551936879000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1549071164000},{"_id":"themes/icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1549071164000},{"_id":"themes/icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1549071164000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1549071164000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"79fab0bff625634fb6bb6cadf9c547bd36226dcf","modified":1549071164000},{"_id":"themes/icarus/layout/category.ejs","hash":"bda344da0e6c03899f53abc20ae2a2efab5ab243","modified":1549071164000},{"_id":"themes/icarus/layout/archive.ejs","hash":"64a81f4c6ca9517169413408d076371e8e09c63a","modified":1549071164000},{"_id":"themes/icarus/layout/index.ejs","hash":"71120f41d019bf2866a5556747e5e671c8147f85","modified":1549071164000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1549071164000},{"_id":"themes/icarus/layout/layout.ejs","hash":"da63c914247eba116ea5263bfc27a69e96f859b6","modified":1549071164000},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1549071164000},{"_id":"themes/icarus/layout/categories.ejs","hash":"14ae8e638a21fcc776c27f21f58660d5684104a9","modified":1609485546018},{"_id":"themes/icarus/layout/tag.ejs","hash":"1feac7aa842882757a479b8ad427f6a72fce70c4","modified":1549071164000},{"_id":"themes/icarus/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1549071164000},{"_id":"themes/icarus/scripts/index.js","hash":"9203e2ba1f821d945edf20fc277f3c58d22bfd00","modified":1549071164000},{"_id":"source/img/eventloop.jpg","hash":"69c5ed189b28661487d075642545544e530dd9e0","modified":1610988750408},{"_id":"source/img/vuerouter/matched.png","hash":"92194e9f38f781c2dde37ab265bcc46d7854b754","modified":1610075787124},{"_id":"source/img/performance.jpg","hash":"8f6509096ab903644a03b135654386c953ae701d","modified":1610898359217},{"_id":"source/_posts/FQA/存疑问题整理.md","hash":"6e2bb54fd1aa075aee7fa39bfd6304bbcc2fdc78","modified":1608973302763},{"_id":"source/_posts/JavaScript/JavaScript严格模式.md","hash":"04362de10d753f7e4027ee7fa3ee369af1861644","modified":1609479200929},{"_id":"source/_posts/JavaScript/JavaScript判断对象是否一致.md","hash":"5b3718a6feeec3790ab3c4f716fd9d19683a63a2","modified":1609479191597},{"_id":"source/_posts/JavaScript/JavaScript基础巩固篇.md","hash":"701e4b8ca6e6df520e2b90d92e7e89495aee82e5","modified":1610503623482},{"_id":"source/_posts/JavaScript/JavaScript原型.md","hash":"c20f49bde2e742c8bcb1565e55c370206f2be681","modified":1609479204654},{"_id":"source/_posts/JavaScript/Javascript内存管理.md","hash":"c5255cd1b16d2c23bc8f67e87cb4472da970d210","modified":1609479186764},{"_id":"source/_posts/JavaScript/JavaScript的set和get.md","hash":"4df47990ca760fc8273d1c49b74f358a197eb0cb","modified":1610340974659},{"_id":"source/_posts/JavaScript/this机制.md","hash":"44f20c458dbc9ac3d03cec450aae33b35ad31c0e","modified":1609479208269},{"_id":"source/_posts/JavaScript/JavaScript实现继承的几种方式.md","hash":"2c47d232f5083c911309c9a61fe86fd47f864547","modified":1609479196954},{"_id":"source/_posts/JavaScript/实现一个简单的模板引擎.md","hash":"c92fb29e0320849d85dc381d74310f4f7032a479","modified":1612014042401},{"_id":"source/_posts/JavaScript/如何手动实现form表单提交的url.md","hash":"436946a24ace97bd73abc425b4644bf726c2108c","modified":1609479174528},{"_id":"source/_posts/JavaScript/宏任务和微任务.md","hash":"8d91524236679c1bd3f6bd0f0e6eb2f9ba640daf","modified":1611033848457},{"_id":"source/_posts/JavaScript/手写一个compose.md","hash":"560456ee5bc49d1fd2b9f1e12ad12513997efadc","modified":1611554904768},{"_id":"source/_posts/JavaScript/手写一个reduce.md","hash":"12eaea900b01a93d7c0f44ab59f733328cb70a08","modified":1611554929116},{"_id":"source/_posts/JavaScript/请求后台数据的几种方式.md","hash":"fc50a9c631a4a7b55bb0828c0c23064c8f2b4069","modified":1609479169585},{"_id":"source/_posts/JavaScript/深拷贝&浅拷贝.md","hash":"dc1484601d9b9d8338d2d1ce769b616f1c40375e","modified":1609479178185},{"_id":"source/_posts/JavaScript/防抖和节流.md","hash":"7e3f77fc782158e811af39aa2d3e312ee2b9e83c","modified":1610420972004},{"_id":"source/_posts/JavaScript/手写一个简易版promise.md","hash":"73d2568a98c4508a2690c745cda504e02aaf9bd5","modified":1611413046246},{"_id":"source/_posts/css/IE及移动端兼容性问题&其他汇总.md","hash":"3a767bf303b51d2303286363fc47c7b4bf7819bf","modified":1610548198645},{"_id":"source/_posts/书虫/巨人的陨落.md","hash":"67696a11c8c410e456288d5cfa14e7c9c41bc7aa","modified":1610959828411},{"_id":"source/_posts/兼容性问题处理/多端适配.md","hash":"c81c12e8fc6fd6d9248ddf5407846e42d13d4b5f","modified":1610745795129},{"_id":"source/_posts/书虫/偷影子的人.md","hash":"5c803c12c0637a5affeabb4e774b6be0995ffd77","modified":1610959825051},{"_id":"source/_posts/书虫/巨人的陨落－观感2.md","hash":"629d3d939cff8eaa97de9dd78733c05700380822","modified":1610959830635},{"_id":"source/_posts/工具/VSCode常用快捷键.md","hash":"d5d3faa4257ce7afc8b08a37674df9486e10157e","modified":1609500461400},{"_id":"source/_posts/工具/Mac安装和卸载HomeBrew.md","hash":"326531ae942a07e7987a4335017ec9e4fe51d255","modified":1608555883534},{"_id":"source/_posts/工具/Git使用过程中遇到的问题.md","hash":"622f5562deab2bbfedbd65d7ed2409ca80917542","modified":1611042898456},{"_id":"source/_posts/工具/babel编译过程.md","hash":"dc7f52bbdc4e760541abdf923e1c1da9276c4791","modified":1611043001011},{"_id":"source/_posts/工具/手动实现一个koa-logger中间件.md","hash":"7c0ed26de32ee597eb2e045d0fca81b10247854c","modified":1611069758048},{"_id":"source/_posts/工具/webpack编译过程.md","hash":"1850e84e02487c6c2d6700491e03432e76109ce7","modified":1611042962096},{"_id":"source/_posts/工具/unit-tests.md","hash":"f61ce96a6eb2d4a9774230edcaec0f1a1fed1435","modified":1608557065289},{"_id":"source/_posts/工具/使用Mocha进行自动化测试.md","hash":"459cf614955c60f49498bca70419ec668db23d4e","modified":1612014312059},{"_id":"source/_posts/工具/编写自己的webpack-loader.md","hash":"773d9898094a0b053ecf4443776f545be195e20f","modified":1611075389674},{"_id":"source/img/tree.jpeg","hash":"f1dd6384d72e2d516ac88295b452a2d2459aa64e","modified":1560071997000},{"_id":"source/_posts/工程化/工程化概述.md","hash":"3c5ec3f0496bd11315eb7e98b378afc715ccdb77","modified":1609479061934},{"_id":"source/_posts/异常&性能/前端异常处理.md","hash":"677485a2077787a0e8a9d79d5777f1ffbef06a1d","modified":1611302025027},{"_id":"source/_posts/异常&性能/Performance-Monitor性能指标.md","hash":"37b5ac4efe9be8414582753689158c166f998aa4","modified":1610905907912},{"_id":"source/_posts/工具/编写自己的webpack-plugins.md","hash":"4250cfaa8aa22807001384f4f735b537480054c7","modified":1611075387507},{"_id":"source/_posts/数据结构&算法/常见缓存算法和缓存策略.md","hash":"c0358df36327540ed04e66a8956dc049f726a54a","modified":1611084874935},{"_id":"source/_posts/总结/SEO原理.md","hash":"b5b07622c8f30ddd4d83e748290c79af8d2bf87b","modified":1611568227089},{"_id":"source/_posts/数据结构&算法/Javascript数组去重和排序.md","hash":"46359559e21844c27f425a16377757565da6147c","modified":1611083491546},{"_id":"source/_posts/异常&性能/前端性能优化.md","hash":"7a8b27c0afd0efc77726a696780fd8b36fcf1ae8","modified":1610592407768},{"_id":"source/_posts/总结/使用Hexo-Github搭建属于自己的blog.md","hash":"abfc70e4e2e05aa2fbc712f71ab906b2aa9ee506","modified":1608557025147},{"_id":"source/_posts/架构/UNIX编程艺术.md","hash":"762094861215a732f8b5a036f7bc930ee059375b","modified":1610202521679},{"_id":"source/_posts/总结/前端跨域解决方案.md","hash":"8e8ea18d8d07970c2234178111320d1ec5daf489","modified":1611075310674},{"_id":"source/_posts/架构/Chrome架构.md","hash":"4f9e459f2dd3e18d7ae05ef4145b531b63f1eafb","modified":1609479091493},{"_id":"source/_posts/架构/无服务器架构.md","hash":"6dc42f7e3b18648b08020a862a66f1e82a13d819","modified":1610745909115},{"_id":"source/_posts/架构/编程范式.md","hash":"80511bdc28bd6150680bc8b52121bb7d05a4375d","modified":1610908295909},{"_id":"source/_posts/框架/从零搭建vue-react项目.md","hash":"5aaf954a7a58c6c50b9cfce772a4feba5043e4bb","modified":1611495557306},{"_id":"source/_posts/框架/Vue问题总结.md","hash":"1cd196dcb2cdf06b744b3a4171c6f02be2d530cb","modified":1610741666308},{"_id":"source/_posts/框架/骨架屏.md","hash":"606185bbb8e0625ddc6f07e8d1da7779e43f323d","modified":1609479100897},{"_id":"source/_posts/框架/菜单路由连续点击无响应.md","hash":"642784a1b0d2eb00faacdf8ff7ec9cce0472d797","modified":1610747809797},{"_id":"source/_posts/浏览器/浏览器中的EventLoop.md","hash":"182cf960e448d78ef75a093aa4817c6086ff0ade","modified":1609479126003},{"_id":"source/_posts/程序设计/UML类图与交互图.md","hash":"e678b0da195e0393f75a84ff041b33650d1a0080","modified":1609500314878},{"_id":"source/_posts/浏览器/浏览器事件机制.md","hash":"f3b4263f36389adcba672fce20f582a0046f1653","modified":1610898261059},{"_id":"source/_posts/浏览器/浏览器缓存机制.md","hash":"7ef96dc06a8bbb09412d1264356a2c85c40fae30","modified":1609479117190},{"_id":"source/_posts/网络安全/web安全.md","hash":"932629337685b514adc01c0ebcbe29ca9fce0997","modified":1609479148754},{"_id":"source/_posts/计算机基础/进程与线程.md","hash":"98bdd1c15d4d2f6bce8261c726d32b5d3846bac0","modified":1609479075164},{"_id":"source/_posts/脚手架/前端脚手架.md","hash":"9e044d12e949c91dbb61f3c251dfb3dc50458ffa","modified":1610745902745},{"_id":"source/_posts/计算机网络/网络传输模型.md","hash":"b46a59ba5bdf46b6fb2f728ec1d885fe7aaadfc9","modified":1609479083309},{"_id":"source/_posts/计算机网络/计算机网络.md","hash":"445357a850bdc5f5bb394024b40176159acaed96","modified":1610745990492},{"_id":"source/_posts/设计模式/JavaScript设计模式-观察者模式.md","hash":"272c796423f5c70e7baa5f6aede441312b25044c","modified":1609479137898},{"_id":"source/_posts/编译原理/JavaScript柯里化.md","hash":"18f1375b03ef4021902151d0972a0fd8983a420a","modified":1610745623404},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1549071164000},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"cd3cd12bc042b401825fd7bfd9a6434c8b14e092","modified":1549071164000},{"_id":"themes/icarus/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1549071164000},{"_id":"themes/icarus/includes/filters/highlight.js","hash":"19a4dcd2dee7388544b57e473cfb0fc9eea9623e","modified":1549071164000},{"_id":"themes/icarus/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1549071164000},{"_id":"themes/icarus/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1549071164000},{"_id":"themes/icarus/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1549071164000},{"_id":"themes/icarus/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"aa8582a2b470d9efc17c75d90e5fe7b4fe49fc82","modified":1608548989888},{"_id":"source/_posts/设计模式/设计模式概览.md","hash":"f19f8367ec205bf38f35d49b2096c0ee28591b30","modified":1609479133166},{"_id":"themes/icarus/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/page.js","hash":"25aeed6449ca381661cec528fe96bbb993026ca9","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/site.js","hash":"f154ddb0dac79fd28ced2b518f8052b42555d0c9","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/override.js","hash":"726cf99612fd060753d9da08db2776aec1802e20","modified":1549071164000},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"a805c1a6f03ccb07d73512aef40d38541ddbb0eb","modified":1549071164000},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"02af67eb87482028b223299b20a129756b1c122b","modified":1549071164000},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1549071164000},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"a9db61ab22a005e74c9615e8838a3c3a148058bd","modified":1551077415000},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"49fabe9c03f3124f0253fa1ee3e69328373ad117","modified":1549071164000},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1549071164000},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"8a7f8d0e72ebf04e69fdbc0fe2800b39c2e919fe","modified":1550484720000},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"67ebd05fb378439a094a7906f4ea04fbedd8c1b5","modified":1549071164000},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"3db2046311dd0392aed0ba2d81b51a081131f1de","modified":1610980647086},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"e29473155a35f391fbc53349bdc256cb7600855e","modified":1549071164000},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"d981ad203a2002c35d710d33e304f9e99f31cab0","modified":1549071164000},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"6c04cccec13a656189ab2d917d69d059027d0343","modified":1549071164000},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"bd500be763486918894e731ce14bc9c4047fb76d","modified":1549071164000},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"cc56bcd2d8d4c6ce3f15d97555e67e90539dfea9","modified":1610292798047},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1549071164000},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"cfc357f27116d1b9285a3b0bec35c3e89ae73711","modified":1549071164000},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1549071164000},{"_id":"source/_posts/计算机网络/HTTP响应代码.md","hash":"2df00bbf92fc70ec28d258c59402c63609fcfa3a","modified":1610745039131},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"b38ea86a1cae48f671501af74d7f109f63fb3d72","modified":1549071164000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"b5fff46e453d58baa20028a47fd85923494bb85c","modified":1549071164000},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"9ccc7ec354b968e60bdcfcd1dba451d38de61f12","modified":1549071164000},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"ef01396e64ab4f6e62155f0b357bcd903138d611","modified":1549071164000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1549071164000},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"033fb890dc1de71f7d3b97061d0d75f4564bd09a","modified":1549071164000},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1549071164000},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"9ed89b4b40bdf4ae2212e3d197cd7834b59e2eff","modified":1549071164000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"93fb89212c271f6ea796a7d5045dad021d36c2e8","modified":1556280542000},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"8def4c56fa935c5368d151aa32e8be0e9b4ff3ba","modified":1611917200074},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"fb7bf815a6fb3b57c68656728509d6461689b595","modified":1550485014000},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1549071164000},{"_id":"themes/icarus/layout/common/head.ejs","hash":"bd72ffd5942bb2fd18319d551bbaa59647e33f3c","modified":1549071164000},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"5414d6bfbf88efa7e72ccf7e44a79d0378ddeb77","modified":1549071164000},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"5417af9f208d2fb5aaeb96031caa261e9683557c","modified":1550494059000},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1549071164000},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"8e52a9c28ffaf4b0b786a20977b848c5f60f2274","modified":1549071164000},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1549071164000},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"3975dee39f9378975b9c10f37d118ad7cb6f5bf6","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"198062ef863c96aa4d6a8225d575afcb60dfb1d1","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"79d1118a3d3ebc521ffce452b986b504f0e7d6b7","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"eb66e313ad43ec4424b2d75bae94e5c8a7568428","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/clipboard.ejs","hash":"8662ed9c211f3993b93eedcf5e41c2a1ddbede57","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"ad68fafd923747d6b7c1b5873d00989d1639678c","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"282cecb28ac458b71b56cf429c72ffac0f820199","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"2b97737d802984750a7b4461fcf68818a57a2439","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"667aabb6b9cb4d707b37975af794d4a3c66b5264","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"fe051093893c64c8575bcc67dc1c146d409e8e80","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"e594ed6705bccbef27f49d84b6153f6443efbecd","modified":1549071164000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1549071164000},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1549071164000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"46ffb57104aa5fdb7b4d22aa35832c7886541946","modified":1610980656241},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1549071164000},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1549071164000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"04cb247d8c83ca7c5b52f3b11bb3ac155b1bc3ab","modified":1549071164000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1549071164000},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1549071164000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1549071164000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"c2a9f2211a21a168c54b0563cdfd58bd25fa39fe","modified":1549071164000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"2b707fd65c94b00d8b4c6755fbc6c19709f3d49a","modified":1549071164000},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"d8f86f0db04f8293cf0ec683bf94434af6c24bb7","modified":1550484159000},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"8c5b8020ca776cc3ebbc7b723915f3173efc28d4","modified":1549071164000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"d32e7c56e8e2074da16d9141f9a597841d28d07d","modified":1549071164000},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"bdc6f22602cdabe7c740f1818e0681ff8508fb64","modified":1549071164000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2166f3190e47bf4746775b5d16654564a88c2041","modified":1609486309943},{"_id":"themes/icarus/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1549071164000},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1549071164000},{"_id":"themes/icarus/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1549071164000},{"_id":"themes/icarus/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1549071164000},{"_id":"themes/icarus/source/css/style.styl","hash":"b8d1bd4405c23849b674e916118a4a006c2eb324","modified":1558880995000},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1549071164000},{"_id":"themes/icarus/source/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1549071164000},{"_id":"themes/icarus/source/images/avatar.jpeg","hash":"95260542d17426da2558fc1fc7c05886927ccb88","modified":1550484528000},{"_id":"themes/icarus/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1549071164000},{"_id":"themes/icarus/source/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1549071164000},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1549071164000},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1549071164000},{"_id":"themes/icarus/source/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1549071164000},{"_id":"themes/icarus/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1549071164000},{"_id":"themes/icarus/source/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1549071164000},{"_id":"themes/icarus/source/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1549071164000},{"_id":"source/img/chrome/eventmodel.jpg","hash":"c1bd6edbb32c525465fe95cce74e63a391ee57c3","modified":1610749105811},{"_id":"source/img/chrome/eventflow.jpg","hash":"952842244a3c54d2c3f2e4dc40902d01d5f19ff0","modified":1610749751779},{"_id":"source/img/chrome/procedure.jpg","hash":"beb30506cc956c1e155ec67c130149639257e895","modified":1610749564587},{"_id":"source/img/network/tcp.png","hash":"628d89ced3afdbf5a35be6d16e0f167882390830","modified":1608570073131},{"_id":"source/img/koa/enter.png","hash":"6ec54d9d3cc9fd7158beeacc078d8f514f4f5021","modified":1610188725246},{"_id":"source/img/paradigm/aop.jpg","hash":"df79cb33d98627495faddddb14ed34c74ee76c5b","modified":1610905434024},{"_id":"source/img/vuerouter/error.png","hash":"d90c7a7cc560bbc41b16d6907274888df985b0d8","modified":1610076943891},{"_id":"source/img/chrome/addEventListener.jpg","hash":"6c284ed679416d83411f46c6def93e4fe45c60f6","modified":1610750144769},{"_id":"source/img/chrome/observer.jpg","hash":"21b048e2f1db8dd814e4ffd01821fb4a223eb7ac","modified":1610750502582},{"_id":"source/img/vuerouter/samerouter.png","hash":"59830b4e5bcd9b68c7b0b79143a4fb3045dc8b21","modified":1610075797545},{"_id":"source/img/chrome/soucecode.jpg","hash":"0375fecc50b1ea8cb28056bff484b156fa16dc21","modified":1610749260682},{"_id":"source/img/knowledge.png","hash":"cf79f1e832023e920cc1a3c35a6cfde309d7c351","modified":1610891673821},{"_id":"source/img/HomeBrew/1.png","hash":"4bfc88cedf80d4186f53db3d150c06babc005823","modified":1563706354000},{"_id":"source/img/network/osi.png","hash":"25c798d682aee839c70da9bcebdd2ad4a5f3cd99","modified":1608568808584},{"_id":"public/content.json","hash":"a3d915f1365dbcdd82d5aacf09fe2f85c39f18bd","modified":1614879991324},{"_id":"public/2021/01/19/工具/手动实现一个koa-logger中间件/index.html","hash":"86607fcc5a0250c5fceea17556852e4ff5e63aae","modified":1614879997298},{"_id":"public/2021/01/16/框架/从零搭建vue-react项目/index.html","hash":"8ae494ba68f47d3be8e60ecbb81b371c70bdefb4","modified":1614879997299},{"_id":"public/2021/01/15/框架/菜单路由连续点击无响应/index.html","hash":"40793bf32b72865d070b07f684f055b4e11e1390","modified":1614879997302},{"_id":"public/2021/01/15/浏览器/浏览器事件机制/index.html","hash":"5a46bb52d5617f4e8c991594e3db6276d9cb5941","modified":1614879997303},{"_id":"public/2021/01/14/架构/编程范式/index.html","hash":"ab679fe990f82f1baba9092e762166e1c39141cd","modified":1614879997303},{"_id":"public/2021/01/13/JavaScript/手写一个compose/index.html","hash":"a67950f0268fa770500a8a2dbf9e5e8e04f5efad","modified":1614879997303},{"_id":"public/2021/01/13/JavaScript/手写一个简易版promise/index.html","hash":"d3e9d6c3c4d0f92663fbb5af7ac490fed22370b0","modified":1614879997303},{"_id":"public/2021/01/13/JavaScript/手写一个reduce/index.html","hash":"6caf2f2ba2f6e236c4e903a7872467b5e4c22bc2","modified":1614879997303},{"_id":"public/2021/01/12/编译原理/JavaScript柯里化/index.html","hash":"b7c016b8523e10527138814792f64f0e16d1c094","modified":1614879997303},{"_id":"public/2021/01/11/JavaScript/防抖和节流/index.html","hash":"09788b815817bcc07e269ac9f56ec386ccc7a7fc","modified":1614879997303},{"_id":"public/2021/01/10/异常&性能/前端异常处理/index.html","hash":"01047f384fc9db2e7309b88dcab4c1f7cee3789e","modified":1614879997303},{"_id":"public/2021/01/09/计算机网络/HTTP响应代码/index.html","hash":"d12ddb83f79474ef41acb0c6d27cb1ef002182e4","modified":1614879997303},{"_id":"public/2021/01/11/JavaScript/JavaScript的set和get/index.html","hash":"43aaf7d92ab7cfa03a0651b9108f7a2933ec7110","modified":1614879997303},{"_id":"public/2021/01/10/异常&性能/Performance-Monitor性能指标/index.html","hash":"8713dcfa379dcb5c837fc18a266b73d6bb10d98a","modified":1614879997303},{"_id":"public/2021/01/07/兼容性问题处理/多端适配/index.html","hash":"3b36b73409b321f184f0ee4ee181df9ebf1f7cf8","modified":1614879997303},{"_id":"public/2021/01/07/JavaScript/宏任务和微任务/index.html","hash":"75d487300df546b4d29bcb5599106f47960444d9","modified":1614879997304},{"_id":"public/2021/01/06/架构/UNIX编程艺术/index.html","hash":"6ddc10973902024d597af96c31c75de80bcd3cea","modified":1614879997304},{"_id":"public/2021/01/01/工具/编写自己的webpack-loader/index.html","hash":"a6ab57b1b73bdccdddfa33fa367ec6df6f031e0c","modified":1614879997304},{"_id":"public/2021/01/01/总结/SEO原理/index.html","hash":"6e9f601b696cecf5c93822b79f8341fc3d9cfbd2","modified":1614879997304},{"_id":"public/2021/01/01/工具/编写自己的webpack-plugins/index.html","hash":"3f684246b5b78f4d83bf98d4d2f27cd16ccc0755","modified":1614879997304},{"_id":"public/2021/01/01/脚手架/前端脚手架/index.html","hash":"045b773d300be7cd5ffca1d55ebd9b04834dcd15","modified":1614879997304},{"_id":"public/2021/01/01/总结/前端跨域解决方案/index.html","hash":"46510b1f797ef7d9e457bd471d19c491abd070af","modified":1614879997304},{"_id":"public/2020/12/22/计算机网络/网络传输模型/index.html","hash":"388f491afd3675fb097dbb13eccfc05c47ca51de","modified":1614879997304},{"_id":"public/2020/12/21/JavaScript/深拷贝&浅拷贝/index.html","hash":"8c56f4d94ad5ed8f309676bdf145ec24f3631839","modified":1614879997304},{"_id":"public/2020/12/21/工程化/工程化概述/index.html","hash":"d09e4d1bd5803446d2bb769f202694fbdfc74058","modified":1614879997304},{"_id":"public/2020/12/13/数据结构&算法/常见缓存算法和缓存策略/index.html","hash":"c1335853f3edbac89a9872653484cfed642634c7","modified":1614879997304},{"_id":"public/2020/12/13/数据结构&算法/Javascript数组去重和排序/index.html","hash":"aad48f93531b7acf826adede3a69830c80bb9b02","modified":1614879997305},{"_id":"public/2020/09/02/JavaScript/this机制/index.html","hash":"40df91912f737a40b23c95397c694f2c510f618b","modified":1614879997305},{"_id":"public/2020/04/02/架构/Chrome架构/index.html","hash":"8d48cb3c73ca3e9e85c45697fa7aaa465730f455","modified":1614879997305},{"_id":"public/2020/03/21/计算机基础/进程与线程/index.html","hash":"1dbb745722b1f2c8940166b5c6335ab5c6709738","modified":1614879997305},{"_id":"public/2020/02/18/架构/无服务器架构/index.html","hash":"f0cb6a6ada9c768e01d67b429b133f7c05a46aa7","modified":1614879997305},{"_id":"public/2020/01/27/书虫/巨人的陨落－观感2/index.html","hash":"754035093bb215e386e3d1bba1f4d1882358d951","modified":1614879997305},{"_id":"public/2020/01/13/计算机网络/计算机网络/index.html","hash":"1763e2ce2e0f101057bc9569dc509f327ff5f8af","modified":1614879997305},{"_id":"public/2020/01/03/JavaScript/JavaScript严格模式/index.html","hash":"08cfb3d278baffa3979162d59ce4fa46aea96a7b","modified":1614879997305},{"_id":"public/2019/10/28/框架/Vue问题总结/index.html","hash":"ce264ba86b522ea58158cc4c1f08a5e0b598c68a","modified":1614879997305},{"_id":"public/2019/10/28/JavaScript/JavaScript原型/index.html","hash":"9f81613b5dd60f4a9827ff7fd9db5710547a6a8b","modified":1614879997305},{"_id":"public/2019/10/27/工具/unit-tests/index.html","hash":"4e2c547cb1734c160fbc91f417a46687256218d5","modified":1614879997305},{"_id":"public/2019/10/17/工具/VSCode常用快捷键/index.html","hash":"b74e3cde3efb61778f57e4cfd16e4cf44956abc8","modified":1614879997305},{"_id":"public/2019/10/17/工具/babel编译过程/index.html","hash":"76b73ae2f13062e644047659c0f3e0892fde22a2","modified":1614879997306},{"_id":"public/2019/10/17/工具/webpack编译过程/index.html","hash":"0276199bc55521475feb5461fbd995f36faa4fa1","modified":1614879997306},{"_id":"public/2019/10/10/书虫/巨人的陨落/index.html","hash":"02ce0f0e7cfa5a09848d9e1c64a2898e1d534e5b","modified":1614879997306},{"_id":"public/2019/10/10/网络安全/web安全/index.html","hash":"e91eea6779eb5f6ed917a26a6f32db59c942f9aa","modified":1614879997306},{"_id":"public/2019/09/30/浏览器/浏览器缓存机制/index.html","hash":"061342a160b546c2e7e1b9228d69e1c47fd8833d","modified":1614879997306},{"_id":"public/2019/09/30/浏览器/浏览器中的EventLoop/index.html","hash":"0bef96a7bd898248008466621c4cd8fa85a61d3e","modified":1614879997306},{"_id":"public/2019/09/04/JavaScript/JavaScript判断对象是否一致/index.html","hash":"0f20be6ede85e987c62fa8da9ac65d358427be97","modified":1614879997306},{"_id":"public/2019/09/04/JavaScript/如何手动实现form表单提交的url/index.html","hash":"07eb63ebd12a05ef364b39758770dfb8e5e854e8","modified":1614879997306},{"_id":"public/2019/09/04/工具/Git使用过程中遇到的问题/index.html","hash":"0e7d2fc7d134d4f5233597e9048c2b45ccd045b5","modified":1614879997306},{"_id":"public/2019/08/29/JavaScript/Javascript内存管理/index.html","hash":"c375758e10e22e719de5ac70706c7aceb7443b84","modified":1614879997307},{"_id":"public/2019/08/09/程序设计/UML类图与交互图/index.html","hash":"557ca94824b35eacc4bc25ff2fd69b6d19896af9","modified":1614879997307},{"_id":"public/2019/07/29/设计模式/设计模式概览/index.html","hash":"5594c17597783bcb7eb5e3fdfe96b63f8fa2d068","modified":1614879997307},{"_id":"public/2019/07/21/工具/Mac安装和卸载HomeBrew/index.html","hash":"c798e81e36a42aec4ba4042be804cb0b91fd1ec3","modified":1614879997307},{"_id":"public/2019/07/03/JavaScript/请求后台数据的几种方式/index.html","hash":"47576e8fee7e82364bf6af570b441c8f8998312f","modified":1614879997307},{"_id":"public/2019/06/25/JavaScript/JavaScript基础巩固篇/index.html","hash":"170bb4d731543370b96061e2e56ab0f25e9d19e6","modified":1614879997307},{"_id":"public/2019/06/09/JavaScript/JavaScript实现继承的几种方式/index.html","hash":"fb898e2e2d8b415aa4ae86a27878140f0cf931b8","modified":1614879997307},{"_id":"public/2019/05/24/设计模式/JavaScript设计模式-观察者模式/index.html","hash":"f83d24a961d5ed4fd5ebc5c006676b2fcb308538","modified":1614879997307},{"_id":"public/2019/05/11/书虫/偷影子的人/index.html","hash":"e4c158e851ee9331fde396cc2d153b59246481e8","modified":1614879997307},{"_id":"public/2019/05/10/异常&性能/前端性能优化/index.html","hash":"b435c6fb93e99de02620a7bcaa9dd0e9991964d1","modified":1614879997307},{"_id":"public/2019/04/26/框架/骨架屏/index.html","hash":"c83d42fb88232c9ab083cef0bfd68c11f4df6239","modified":1614879997307},{"_id":"public/2019/04/23/FQA/存疑问题整理/index.html","hash":"79ab37aafb989d537c77bfc9030755d0266f93e3","modified":1614879997307},{"_id":"public/2019/03/06/css/IE及移动端兼容性问题&其他汇总/index.html","hash":"4f650549bcff0ab115574e2e2fc65f47a908f9dd","modified":1614879997308},{"_id":"public/2019/02/18/总结/使用Hexo-Github搭建属于自己的blog/index.html","hash":"c270179c08cd41933915bba4e40ccb390c3f7067","modified":1614879997308},{"_id":"public/categories/FQA/index.html","hash":"97c622560ab7a10a989f637bedb80498defccc41","modified":1614879997310},{"_id":"public/categories/JavaScript/index.html","hash":"019976fad07fe865bf828ef7d4d7385604b01430","modified":1614879997310},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"67f8aace650b625e2e7b301a56f11d6ddae103f3","modified":1614879997311},{"_id":"public/categories/css/index.html","hash":"650af273e215b6eca5f2d1ea8c127205169bc4a0","modified":1614879997311},{"_id":"public/categories/书虫/index.html","hash":"6bd767399bde832570c14e79822d5de47c8cc58b","modified":1614879997311},{"_id":"public/categories/架构/index.html","hash":"df6bbfcfa47071de630c777651cb742c1f0983b1","modified":1614879997312},{"_id":"public/categories/工具/index.html","hash":"0f676ddce6acabd9e20258b15dba825e544aed7d","modified":1614879997312},{"_id":"public/categories/工程化/index.html","hash":"40f0323993a2476ddf341abfca98ca287cfab841","modified":1614879997312},{"_id":"public/categories/异常-性能/index.html","hash":"fcc3a20765b9c551eafebf75ef2aa02e3fa610f7","modified":1614879997312},{"_id":"public/categories/数据结构-算法/index.html","hash":"e15aa33b35edf1a5a7973456e2ee9db84ba77611","modified":1614879997312},{"_id":"public/categories/总结/index.html","hash":"d27225e52978564a04015b29014b137cf5db0b6f","modified":1614879997312},{"_id":"public/categories/框架/index.html","hash":"2843916d42540b3c176ecdcba4d5c0bab1fb76da","modified":1614879997312},{"_id":"public/categories/浏览器/index.html","hash":"9286f57d1eff8ed11aa23a6e0e0ffa5ed2bead63","modified":1614879997312},{"_id":"public/categories/程序设计/index.html","hash":"5b496a23b9fe3d04fd7012a5b8bb3949bbef9d9f","modified":1614879997313},{"_id":"public/categories/网络安全/index.html","hash":"301e0f37078ac868f6ecdf0e79ff443ae37dd7a0","modified":1614879997313},{"_id":"public/categories/计算机基础/index.html","hash":"c80591c281df4838ca084c9213bd5b4edbd1c7b6","modified":1614879997313},{"_id":"public/categories/脚手架/index.html","hash":"431492d898c19a4d77ff0085e18cc665679142cd","modified":1614879997313},{"_id":"public/categories/计算机网络/index.html","hash":"1649c2fcf534ce4445fe1124e5b5a751de95a698","modified":1614879997313},{"_id":"public/categories/设计模式/index.html","hash":"c0a2bba309356e1a62e5001e2cacafdb5384cb21","modified":1614879997313},{"_id":"public/categories/编译原理/index.html","hash":"6e81157b3f284bd94c7ce80d44e5f537e4a7e9f8","modified":1614879997313},{"_id":"public/archives/index.html","hash":"61b485a6485300a5ec3f15626f4281806a3eb2ce","modified":1614879997308},{"_id":"public/archives/page/2/index.html","hash":"ce3ddf88b25c1b8ca74c0b7ad4de30070f868a35","modified":1614879997308},{"_id":"public/archives/page/3/index.html","hash":"4b0a32191815df08e140e3421490a512ccb8b6ad","modified":1614879997308},{"_id":"public/archives/page/4/index.html","hash":"9847a05591bd3d5e5602b587aa190e1e008f869b","modified":1614879997308},{"_id":"public/archives/page/5/index.html","hash":"bc3f313544374ae0be2b219af22d4cfa676abaa8","modified":1614879997308},{"_id":"public/archives/page/6/index.html","hash":"4a375d7466b9c4125e3c44af4431386f0a5a648f","modified":1614879997308},{"_id":"public/archives/page/7/index.html","hash":"57044e21357a7322cccfe3e589ed533a8b31e802","modified":1614879997308},{"_id":"public/archives/2019/index.html","hash":"4d19ff027d3bfe83ad97f8ff0239a2f0cd6cccb1","modified":1614879997308},{"_id":"public/archives/2019/page/2/index.html","hash":"4cf871d3e5e5df16f2adad64159d08fb99cf6ce8","modified":1614879997308},{"_id":"public/archives/2019/page/3/index.html","hash":"ae7c8b41fb1d7dcec078e82bbb6b927a1f1f50de","modified":1614879997308},{"_id":"public/archives/2019/02/index.html","hash":"32124924ec266c0c05b71068562c25bed66d98b8","modified":1614879997308},{"_id":"public/archives/2019/03/index.html","hash":"52a1c7c790b9070e322bb3c12baf88070eaba074","modified":1614879997308},{"_id":"public/archives/2019/04/index.html","hash":"a1692c43a591da305c3461a1398e88f321f45d98","modified":1614879997308},{"_id":"public/archives/2019/05/index.html","hash":"f7abf63c6d8762bfa45a3809ec6505c88993d1af","modified":1614879997308},{"_id":"public/archives/2019/06/index.html","hash":"1e0c8ca26b9d41a35a696ca34633f0f895e48187","modified":1614879997308},{"_id":"public/archives/2019/07/index.html","hash":"196751e2b1305d126baa3486dd9e3700eaaedef3","modified":1614879997309},{"_id":"public/archives/2019/08/index.html","hash":"b2a42e2d5f2ea3682e60a13e1ed5cca0e16d56ca","modified":1614879997309},{"_id":"public/archives/2019/09/index.html","hash":"8061aef9aff120f983879ac8c28417fd651044ff","modified":1614879997309},{"_id":"public/archives/2019/10/index.html","hash":"d7a155c8c484582060913e13b3c676580fd1bd86","modified":1614879997309},{"_id":"public/archives/2020/index.html","hash":"03e40be69816c9a9a05a5d30311a74eb95199994","modified":1614879997309},{"_id":"public/archives/2020/page/2/index.html","hash":"c4ac037632085ca088add8594855ce4053516efc","modified":1614879997309},{"_id":"public/archives/2020/01/index.html","hash":"77275ab9842dcdc32564e314696bbc2ce0292c8e","modified":1614879997309},{"_id":"public/archives/2020/02/index.html","hash":"aaa9c0eed37dc3433c87787d32563e49578be7de","modified":1614879997309},{"_id":"public/archives/2020/03/index.html","hash":"0d2a446fedba69d99678d77c86a5b8476a801516","modified":1614879997309},{"_id":"public/archives/2020/04/index.html","hash":"109f2c054655db95431ec550f8162767339b1f08","modified":1614879997309},{"_id":"public/archives/2020/09/index.html","hash":"74a3a66153e4c9514758020f81ab2e582b67efba","modified":1614879997310},{"_id":"public/archives/2020/12/index.html","hash":"fd28d51881b4da7425cb436a1a3ca78e4fff4884","modified":1614879997310},{"_id":"public/archives/2021/index.html","hash":"284692cb42df58b0bd6be0bfe255252e1db3b0b2","modified":1614879997310},{"_id":"public/archives/2021/page/2/index.html","hash":"fc2f28ac91820cd19deda9b493dc619c97c17414","modified":1614879997310},{"_id":"public/archives/2021/page/3/index.html","hash":"29cc1351ff24e3c2a4f947d944f3d66c333cf579","modified":1614879997310},{"_id":"public/archives/2021/01/index.html","hash":"a66311027cd983c71b39d85b10583e79d06e4fe4","modified":1614879997310},{"_id":"public/archives/2021/01/page/2/index.html","hash":"2bbe9fea55c2909932864361f7f7ba5da0ceefe5","modified":1614879997310},{"_id":"public/archives/2021/01/page/3/index.html","hash":"3322def50b08b019204b7beb91bc65661408b434","modified":1614879997310},{"_id":"public/index.html","hash":"5294b8592aaf4871d468b2811e2446786269388e","modified":1614879997314},{"_id":"public/page/2/index.html","hash":"b79205f2556cec680cb7d61b0a3e2cdd410fdfb5","modified":1614879997314},{"_id":"public/page/3/index.html","hash":"e65fff5a7e860fab104eedf9a8ee7a8fbf36091d","modified":1614879997314},{"_id":"public/page/4/index.html","hash":"d5f3bf1c2cb3af327eeadc653744b3ada6ed706b","modified":1614879997314},{"_id":"public/page/5/index.html","hash":"83463c07a1cf3daeacdf6ac47a1a264bddc1683a","modified":1614879997315},{"_id":"public/tags/编程语言/index.html","hash":"af104ff932d26e4dda64103376555d6fea2a5c2a","modified":1614879997313},{"_id":"public/tags/前后端分离/index.html","hash":"0d2edb28b5f40c12958dce4b5fbd16d561748e86","modified":1614879997313},{"_id":"public/tags/书籍/index.html","hash":"8f17209c894da51b0eb67108a695dd838146f076","modified":1614879997313},{"_id":"public/tags/架构/index.html","hash":"2044699442b618a611881b93f9dbdcc11a02ab8b","modified":1614879997313},{"_id":"public/tags/工具/index.html","hash":"7e1b8bbf19cc8a823d1de7fab46c973ce57d2e1e","modified":1614879997313},{"_id":"public/tags/异常-性能/index.html","hash":"c5388a977d7d56179016227efc53fe4a2113db44","modified":1614879997313},{"_id":"public/tags/算法/index.html","hash":"414ae2bbecbcbb30ed78064de455e65ac83f605c","modified":1614879997313},{"_id":"public/tags/框架/index.html","hash":"a8f94562421c775423e49656e645fe2b8270c1d3","modified":1614879997313},{"_id":"public/tags/浏览器/index.html","hash":"9c5ca15a795955a647dc11c88e6337334dfa9180","modified":1614879997314},{"_id":"public/tags/程序设计/index.html","hash":"6f7e06e79db3a3c7a71b2cbddc842959d3d683b0","modified":1614879997314},{"_id":"public/tags/脚手架/index.html","hash":"18f7ad446c31852347de2b8fc1a53ff9357a398c","modified":1614879997314},{"_id":"public/tags/网络知识/index.html","hash":"60e988ef5b76c5347f77c867937e3276f118c7f1","modified":1614879997314},{"_id":"public/tags/设计模式/index.html","hash":"860bbfcd7235d307b232ce42fc099e787ec142e6","modified":1614879997314},{"_id":"public/tags/编译原理/index.html","hash":"0593777abcc6c82f718daedd43a9d9d076326c90","modified":1614879997314},{"_id":"public/categories/index.html","hash":"bcdb925dfcb5715fae7db09ed58d331a80e46323","modified":1614879997315},{"_id":"public/tags/index.html","hash":"85f40f52979783ef3afb2727ab0443455a64c1e7","modified":1614879997315},{"_id":"public/2021/01/30/JavaScript/实现一个简单的模板引擎/index.html","hash":"d981c9179c35c5c99397130fffeba1e492d3d6f9","modified":1614879996905},{"_id":"public/2021/01/30/工具/使用Mocha进行自动化测试/index.html","hash":"ec301df2d282f07624f85fedbed5cd58f2b1ab72","modified":1614879996905},{"_id":"public/img/desert.jpg","hash":"f2cfe1cd15e66db283a72600643df284a41216a2","modified":1613895435794},{"_id":"public/img/deer.jpg","hash":"aeeb445722949281bda6df0b622dfd433e0ec41d","modified":1613895435794},{"_id":"public/img/pen.jpg","hash":"7f3782cc4f2de0bd5fd3dba65dd0f00a9d8f6dfb","modified":1613895435794},{"_id":"public/img/execute.png","hash":"f3e9ff6d95473eaa6c1600fa7c29e4298389ae0f","modified":1613895435794},{"_id":"public/img/flower.jpg","hash":"692f8f93097723856d46f1c403664059e68614ca","modified":1613895435794},{"_id":"public/img/plant.jpg","hash":"a1d8e7cb1b4f38feea0cd3bdba4b50194472af1c","modified":1613895435794},{"_id":"public/img/shell.jpg","hash":"83257359649e0926b8fdaa6cb3c03752fe72abb0","modified":1613895435794},{"_id":"public/img/vuerouter/matched.png","hash":"92194e9f38f781c2dde37ab265bcc46d7854b754","modified":1613895435795},{"_id":"public/img/shadow.jpeg","hash":"b58c631c608d006693d8ed94c2a01673cef70ee6","modified":1613895435795},{"_id":"public/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1613895435795},{"_id":"public/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1613895435795},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1613895435795},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1613895435795},{"_id":"public/images/avatar.jpeg","hash":"95260542d17426da2558fc1fc7c05886927ccb88","modified":1613895435795},{"_id":"public/img/network/tcp.png","hash":"628d89ced3afdbf5a35be6d16e0f167882390830","modified":1613895435795},{"_id":"public/img/koa/enter.png","hash":"6ec54d9d3cc9fd7158beeacc078d8f514f4f5021","modified":1613895435795},{"_id":"public/img/vuerouter/error.png","hash":"d90c7a7cc560bbc41b16d6907274888df985b0d8","modified":1613895435795},{"_id":"public/img/basic.jpg","hash":"5d7b639f775afa4daf75a312bba03e6746574e42","modified":1613895435955},{"_id":"public/img/cactus.jpg","hash":"5162330a4466000f75ef352f8fc60d8c4400aedd","modified":1613895435955},{"_id":"public/img/eventloop.jpg","hash":"69c5ed189b28661487d075642545544e530dd9e0","modified":1613895435955},{"_id":"public/img/chrome/eventmodel.jpg","hash":"c1bd6edbb32c525465fe95cce74e63a391ee57c3","modified":1613895435955},{"_id":"public/img/chrome/eventflow.jpg","hash":"952842244a3c54d2c3f2e4dc40902d01d5f19ff0","modified":1613895435956},{"_id":"public/img/paradigm/aop.jpg","hash":"df79cb33d98627495faddddb14ed34c74ee76c5b","modified":1613895435956},{"_id":"public/img/vuerouter/samerouter.png","hash":"59830b4e5bcd9b68c7b0b79143a4fb3045dc8b21","modified":1613895435956},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1613895435960},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1613895435961},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1613895435961},{"_id":"public/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1613895435961},{"_id":"public/css/style.css","hash":"621f9b669b7a98053ed614eb5151a3a3fa770ba4","modified":1613895435961},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1613895435961},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1613895435961},{"_id":"public/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1613895435961},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1613895435961},{"_id":"public/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1613895435961},{"_id":"public/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1613895435961},{"_id":"public/img/tree.jpeg","hash":"f1dd6384d72e2d516ac88295b452a2d2459aa64e","modified":1613895435961},{"_id":"public/img/chrome/procedure.jpg","hash":"beb30506cc956c1e155ec67c130149639257e895","modified":1613895435961},{"_id":"public/img/performance.jpg","hash":"8f6509096ab903644a03b135654386c953ae701d","modified":1613895435961},{"_id":"public/img/chrome/addEventListener.jpg","hash":"6c284ed679416d83411f46c6def93e4fe45c60f6","modified":1613895436007},{"_id":"public/img/chrome/soucecode.jpg","hash":"0375fecc50b1ea8cb28056bff484b156fa16dc21","modified":1613895436009},{"_id":"public/img/chrome/observer.jpg","hash":"21b048e2f1db8dd814e4ffd01821fb4a223eb7ac","modified":1613895436011},{"_id":"public/img/knowledge.png","hash":"cf79f1e832023e920cc1a3c35a6cfde309d7c351","modified":1613895436011},{"_id":"public/img/network/osi.png","hash":"25c798d682aee839c70da9bcebdd2ad4a5f3cd99","modified":1613895436015},{"_id":"public/img/HomeBrew/1.png","hash":"4bfc88cedf80d4186f53db3d150c06babc005823","modified":1613895436015},{"_id":"source/_posts/工具/Docker常用命令.md","hash":"64525db8f726e9d890a0187e7c34213fb3ccb6ac","modified":1614879846602},{"_id":"source/_posts/数据库/mysql.md","hash":"93e8341cb2944f353082cab3f04425f07ce1268a","modified":1614879903110},{"_id":"source/_posts/测试框架/Jest.md","hash":"8be987b9ec5ea98bff8e7fac78decdd5383a8d79","modified":1614879954055},{"_id":"public/2021/03/04/测试框架/Jest/index.html","hash":"6c477ed3dd1b2367cd4a160ba4e4affe58ca4a68","modified":1614879997318},{"_id":"public/2021/03/04/工具/Docker常用命令/index.html","hash":"4ab9838f9f32789ccd27cfb6ec608559c4b6db1c","modified":1614879997318},{"_id":"public/2021/03/04/数据库/mysql/index.html","hash":"c931bdb8a1caba22de969f6fc14016ecc39cd507","modified":1614879997319},{"_id":"public/archives/2021/03/index.html","hash":"4f69d1d938a37480d7c94da393a78cefe3ea0960","modified":1614879997319},{"_id":"public/categories/工具/page/2/index.html","hash":"dc373972b582513e5d17ce015d805f29bcb06358","modified":1614879997319},{"_id":"public/categories/数据库/index.html","hash":"667b745dba9e666562f207d8b709efd1f7dd9183","modified":1614879997319},{"_id":"public/categories/测试框架/index.html","hash":"c96b96e2116105a8914085f11991c95a46d5a27b","modified":1614879997319},{"_id":"public/tags/工具/page/2/index.html","hash":"1656f6539b77ddad40172c91da1367b1a25ed599","modified":1614879997319},{"_id":"public/tags/数据库/index.html","hash":"12b7abcf4c34debf6de134744141733282658b34","modified":1614879997319},{"_id":"public/tags/测试框架/index.html","hash":"2a85fe3ea11bb1284f95218b45dccde783bef362","modified":1614879997319}],"Category":[{"name":"FQA","_id":"cklevo3jg0002vbxx0xbkxq1c"},{"name":"JavaScript","_id":"cklevo3jj0006vbxx8v6o1j6v"},{"name":"css","_id":"cklevo3jy001fvbxx53t3yrwt"},{"name":"书虫","_id":"cklevo3k0001nvbxxd1uuqp58"},{"name":"架构","_id":"cklevo3k40021vbxxgso5lcpc"},{"name":"工具","_id":"cklevo3k6002avbxxy5tqkxsu"},{"name":"工程化","_id":"cklevo3ki003ivbxx5nysxjwd"},{"name":"异常&性能","_id":"cklevo3kk003rvbxxbibmh6dl"},{"name":"数据结构&算法","_id":"cklevo3ko0047vbxx72gayaji"},{"name":"总结","_id":"cklevo3kq004fvbxx21k36jo6"},{"name":"框架","_id":"cklevo3kz005bvbxxbe2shtgy"},{"name":"浏览器","_id":"cklevo3l4005vvbxxla3cv0db"},{"name":"程序设计","_id":"cklevo3l50062vbxxy7tl4oa2"},{"name":"网络安全","_id":"cklevo3l60066vbxxhd86g4tt"},{"name":"计算机基础","_id":"cklevo3l60069vbxx22qidbb1"},{"name":"脚手架","_id":"cklevo3l7006bvbxx3m4lcy9m"},{"name":"计算机网络","_id":"cklevo3l7006dvbxxm0tcnuzs"},{"name":"设计模式","_id":"cklevo3l7006gvbxxh23ommqf"},{"name":"编译原理","_id":"cklevo3l8006jvbxxkhgahnar"},{"name":"数据库","_id":"cklv5unm3000474xx1wgjfw3i"},{"name":"测试框架","_id":"cklv5unmb000774xxkyv1svt2"}],"Data":[],"Page":[],"Post":[{"title":"存疑问题整理","date":"2019-04-23T11:46:28.000Z","thumbnail":"img/deer.jpg","_content":"<p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<!-- more -->\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：https://www.jianshu.com/p/07f2e1364f35</p>\n    </li>\n    <li>WebGL\n        <p>参考：http://www.hewebgl.com/article/getarticle/26</p>\n    </li>\n    <li>Node\n        <p>http://nodejs.cn/latest-api/events.html</p>\n    </li>\n    <li>koa\n        <p>参考：https://koajs.com/</p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：https://www.cnblogs.com/fozero/p/9134543.html</p>\n    </li>\n    <li>Es5严格模式：\n        <p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</p>\n    </li>\n</ol>","source":"_posts/FQA/存疑问题整理.md","raw":"---\ntitle: 存疑问题整理\ndate: 2019-04-23 19:46:28\ncategories: FQA\ntags:\nthumbnail: img/deer.jpg\n---\n<p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<!-- more -->\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：https://www.jianshu.com/p/07f2e1364f35</p>\n    </li>\n    <li>WebGL\n        <p>参考：http://www.hewebgl.com/article/getarticle/26</p>\n    </li>\n    <li>Node\n        <p>http://nodejs.cn/latest-api/events.html</p>\n    </li>\n    <li>koa\n        <p>参考：https://koajs.com/</p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：https://www.cnblogs.com/fozero/p/9134543.html</p>\n    </li>\n    <li>Es5严格模式：\n        <p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</p>\n    </li>\n</ol>","slug":"FQA/存疑问题整理","published":1,"updated":"2020-12-26T09:01:42.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jc0000vbxxrzuswswh","content":"<p></p><p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<a id=\"more\"></a><p></p>\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：<a href=\"https://www.jianshu.com/p/07f2e1364f35\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/07f2e1364f35</a></p>\n    </li>\n    <li>WebGL\n        <p>参考：<a href=\"http://www.hewebgl.com/article/getarticle/26\" target=\"_blank\" rel=\"noopener\">http://www.hewebgl.com/article/getarticle/26</a></p>\n    </li>\n    <li>Node\n        <p><a href=\"http://nodejs.cn/latest-api/events.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/latest-api/events.html</a></p>\n    </li>\n    <li>koa\n        <p>参考：<a href=\"https://koajs.com/\" target=\"_blank\" rel=\"noopener\">https://koajs.com/</a></p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：<a href=\"https://www.cnblogs.com/fozero/p/9134543.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fozero/p/9134543.html</a></p>\n    </li>\n    <li>Es5严格模式：\n        <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>\n    </li>\n</ol>","site":{"data":{}},"excerpt":"<p></p><p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>","more":"<p></p>\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：<a href=\"https://www.jianshu.com/p/07f2e1364f35\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/07f2e1364f35</a></p>\n    </li>\n    <li>WebGL\n        <p>参考：<a href=\"http://www.hewebgl.com/article/getarticle/26\" target=\"_blank\" rel=\"noopener\">http://www.hewebgl.com/article/getarticle/26</a></p>\n    </li>\n    <li>Node\n        <p><a href=\"http://nodejs.cn/latest-api/events.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/latest-api/events.html</a></p>\n    </li>\n    <li>koa\n        <p>参考：<a href=\"https://koajs.com/\" target=\"_blank\" rel=\"noopener\">https://koajs.com/</a></p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：<a href=\"https://www.cnblogs.com/fozero/p/9134543.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fozero/p/9134543.html</a></p>\n    </li>\n    <li>Es5严格模式：\n        <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>\n    </li>\n</ol>"},{"title":"JavaScript严格模式","date":"2020-01-03T06:10:10.000Z","_content":"\n<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<!-- more -->\n\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  ```\n  // 非严格模式\n  eval(\"function sayHi () { alert('hi'); }\")\n  sayHi() // \"hi\"\n\n  eval(\"var msg= 'hello world'; \")\n  alert(msg) // \"hello world\"\n\n  // 严格模式\n  \"use strict\"\n  eval = 'hi' // 抛出error 创建变量和函数类似\n  ```\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  ```\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // 'Nicholas'\n  person.name = 'lilei'\n  console.log(person.name) // 'Nicholas'\n\n  \"use strict\"\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // Nicholas\n  person.name = 'lilei' // 抛出error\n  console.log(person.name)\n  ```\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n  \n  ```\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    get: function () {\n      return this._year\n    }\n  })\n\n  book.year = 2021 // 抛出错误\n\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    set: function (newValue) {\n      this._year = newValue\n      this.edition++\n    }\n  })\n\n  book.year // 非严格模式下 undefined\n  ```\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, ...)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  ```\n  \"use strict\"\n  window.color = \"red\"\n  let o = { color: \"blue\" }\n\n  function sayColor() {\n    console.log(this.color)\n  }\n  sayColor.call(null); // error 非严格：red\n  sayColor.call(undefined); // error 非严格：red\n  ```\n  </li>\n</ol>","source":"_posts/JavaScript/JavaScript严格模式.md","raw":"---\ntitle: JavaScript严格模式\ndate: 2020-01-03 14:10:10\ntags:\ncategories: JavaScript\n---\n\n<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<!-- more -->\n\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  ```\n  // 非严格模式\n  eval(\"function sayHi () { alert('hi'); }\")\n  sayHi() // \"hi\"\n\n  eval(\"var msg= 'hello world'; \")\n  alert(msg) // \"hello world\"\n\n  // 严格模式\n  \"use strict\"\n  eval = 'hi' // 抛出error 创建变量和函数类似\n  ```\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  ```\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // 'Nicholas'\n  person.name = 'lilei'\n  console.log(person.name) // 'Nicholas'\n\n  \"use strict\"\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // Nicholas\n  person.name = 'lilei' // 抛出error\n  console.log(person.name)\n  ```\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n  \n  ```\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    get: function () {\n      return this._year\n    }\n  })\n\n  book.year = 2021 // 抛出错误\n\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    set: function (newValue) {\n      this._year = newValue\n      this.edition++\n    }\n  })\n\n  book.year // 非严格模式下 undefined\n  ```\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, ...)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  ```\n  \"use strict\"\n  window.color = \"red\"\n  let o = { color: \"blue\" }\n\n  function sayColor() {\n    console.log(this.color)\n  }\n  sayColor.call(null); // error 非严格：red\n  sayColor.call(undefined); // error 非严格：red\n  ```\n  </li>\n</ol>","slug":"JavaScript/JavaScript严格模式","published":1,"updated":"2021-01-01T05:33:20.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3je0001vbxxfn2mz568","content":"<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 非严格模式</span><br><span class=\"line\">eval(&quot;function sayHi () &#123; alert(&apos;hi&apos;); &#125;&quot;)</span><br><span class=\"line\">sayHi() // &quot;hi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">eval(&quot;var msg= &apos;hello world&apos;; &quot;)</span><br><span class=\"line\">alert(msg) // &quot;hello world&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 严格模式</span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">eval = &apos;hi&apos; // 抛出error 创建变量和函数类似</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\">person.name = &apos;lilei&apos;</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // Nicholas</span><br><span class=\"line\">person.name = &apos;lilei&apos; // 抛出error</span><br><span class=\"line\">console.log(person.name)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = 2021 // 抛出错误</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year // 非严格模式下 undefined</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, …)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">window.color = &quot;red&quot;</span><br><span class=\"line\">let o = &#123; color: &quot;blue&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sayColor() &#123;</span><br><span class=\"line\">  console.log(this.color)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(null); // error 非严格：red</span><br><span class=\"line\">sayColor.call(undefined); // error 非严格：red</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>","site":{"data":{}},"excerpt":"<p>严格模式为了修复Javascript语法的不严谨性。</p>","more":"<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 非严格模式</span><br><span class=\"line\">eval(&quot;function sayHi () &#123; alert(&apos;hi&apos;); &#125;&quot;)</span><br><span class=\"line\">sayHi() // &quot;hi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">eval(&quot;var msg= &apos;hello world&apos;; &quot;)</span><br><span class=\"line\">alert(msg) // &quot;hello world&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 严格模式</span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">eval = &apos;hi&apos; // 抛出error 创建变量和函数类似</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\">person.name = &apos;lilei&apos;</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // Nicholas</span><br><span class=\"line\">person.name = &apos;lilei&apos; // 抛出error</span><br><span class=\"line\">console.log(person.name)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = 2021 // 抛出错误</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year // 非严格模式下 undefined</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, …)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">window.color = &quot;red&quot;</span><br><span class=\"line\">let o = &#123; color: &quot;blue&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sayColor() &#123;</span><br><span class=\"line\">  console.log(this.color)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(null); // error 非严格：red</span><br><span class=\"line\">sayColor.call(undefined); // error 非严格：red</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>"},{"title":"JavaScript原型","date":"2019-10-27T16:33:25.000Z","_content":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<!-- more -->\n\n以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。\n\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n```\nfunction A() {}\n\nconst a = new A(); // new 并没有直接关联，间接关联(意外的副作用)\n\nObject.getPrototypeOf(a) === A.prototype // true\n```\n\n<p class=\"l30\">Object.create(...): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n```\n// ES6之前需要抛弃默认的A.prototype\nA.prototype = Object.create(B.prototype)\n\n// ES6开始可以直接修改现有的B.prototype\nObject.setPrototypeOf(A.prototype, B.prototype)\n\n```\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作\"字典\"，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n#未完待续#\n","source":"_posts/JavaScript/JavaScript原型.md","raw":"---\ntitle: JavaScript原型\ndate: 2019-10-28 00:33:25\ntags:\ncategories: JavaScript\n---\n<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<!-- more -->\n\n以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。\n\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n```\nfunction A() {}\n\nconst a = new A(); // new 并没有直接关联，间接关联(意外的副作用)\n\nObject.getPrototypeOf(a) === A.prototype // true\n```\n\n<p class=\"l30\">Object.create(...): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n```\n// ES6之前需要抛弃默认的A.prototype\nA.prototype = Object.create(B.prototype)\n\n// ES6开始可以直接修改现有的B.prototype\nObject.setPrototypeOf(A.prototype, B.prototype)\n\n```\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作\"字典\"，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n#未完待续#\n","slug":"JavaScript/JavaScript原型","published":1,"updated":"2021-01-01T05:33:24.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jh0003vbxxzern2zz0","content":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<a id=\"more\"></a>\n<p>以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。</p>\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = new A(); // new 并没有直接关联，间接关联(意外的副作用)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getPrototypeOf(a) === A.prototype // true</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(…): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6之前需要抛弃默认的A.prototype</span><br><span class=\"line\">A.prototype = Object.create(B.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6开始可以直接修改现有的B.prototype</span><br><span class=\"line\">Object.setPrototypeOf(A.prototype, B.prototype)</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作”字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n<p>#未完待续#</p>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>","more":"<p>以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。</p>\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = new A(); // new 并没有直接关联，间接关联(意外的副作用)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getPrototypeOf(a) === A.prototype // true</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(…): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6之前需要抛弃默认的A.prototype</span><br><span class=\"line\">A.prototype = Object.create(B.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6开始可以直接修改现有的B.prototype</span><br><span class=\"line\">Object.setPrototypeOf(A.prototype, B.prototype)</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作”字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n<p>#未完待续#</p>"},{"title":"Javascript内存管理","date":"2019-08-28T16:00:05.000Z","_content":"<p>总结Javascript内存相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<h5>回顾基础知识:</h5>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<h5>重点:</h5>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<h5>优化内存:</h5>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  ```\n  let obj = new dialog()\n  obj = null\n  ```\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<h5>补充</h5>\n<h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<h5>思考&扩展</h5>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n#未完待续#","source":"_posts/JavaScript/Javascript内存管理.md","raw":"---\ntitle: Javascript内存管理\ndate: 2019-08-29 00:00:05\ntags: 编程语言\ncategories: JavaScript\n---\n<p>总结Javascript内存相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<h5>回顾基础知识:</h5>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<h5>重点:</h5>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<h5>优化内存:</h5>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  ```\n  let obj = new dialog()\n  obj = null\n  ```\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<h5>补充</h5>\n<h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<h5>思考&扩展</h5>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n#未完待续#","slug":"JavaScript/Javascript内存管理","published":1,"updated":"2021-01-01T05:33:06.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jh0004vbxxhd27z00l","content":"<p></p><p>总结Javascript内存相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p></p><h5>回顾基础知识:</h5><p></p>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<p></p><h5>重点:</h5><p></p>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<p></p><h5>优化内存:</h5><p></p>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = new dialog()</span><br><span class=\"line\">obj = null</span><br></pre></td></tr></table></figure>\n\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<p></p><h5>补充</h5><p></p>\n<p></p><h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5><p></p>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<p></p><h5>思考&amp;扩展</h5><p></p>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n<p>#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p></p><p>总结Javascript内存相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p></p><h5>回顾基础知识:</h5><p></p>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<p></p><h5>重点:</h5><p></p>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<p></p><h5>优化内存:</h5><p></p>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = new dialog()</span><br><span class=\"line\">obj = null</span><br></pre></td></tr></table></figure>\n\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<p></p><h5>补充</h5><p></p>\n<p></p><h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5><p></p>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<p></p><h5>思考&amp;扩展</h5><p></p>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n<p>#未完待续#</p>"},{"title":"JavaScript基础巩固篇","date":"2019-06-25T08:50:28.000Z","thumbnail":"img/basic.jpg","_content":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<!-- more -->\n\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            ```\n            Object.prototype.toString.call([])  // \"[object Array]\"\n            Object.prototype.toString.call({})  // \"[object Object]\"\n            ```\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            ```\n            Array.isArray([])  // true\n            Array.isArray({})  // false\n            ```\n            <p>通过instanceof运算符来识别</p>\n            ```\n            console.log({} instanceof Array) // false \n            console.log([] instanceof Array) // true\n            ```\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            ```\n            Array.prototype.isPrototypeOf({}) // false\n            Array.prototype.isPrototypeOf([]) // true\n            Object.prototype.isPrototypeOf({}) // true\n            Object.prototype.isPrototypeOf([]) // false\n            ```\n            <p>通过constructor属性来区别</p>\n            ```\n            [].constructor // ƒ Array() { [native code] }\n            ({}).constructor // ƒ Object() { [native code] }\n            ```\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          ```\n          const a = {}\n          Object.keys(a).length // 是否为0\n          ```\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：http://www.imooc.com/article/277859\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：https://www.cnblogs.com/wangdashi/p/9606182.html\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>'abcd'变为{d:{c:{b:\"a\"}}}</p>\n          ```\n          const str = 'abcd'\n          const newObj = str.split('').reduce(function(prev, next){\n              const obj = {}\n              obj[next]=prev\n              return obj\n          })\n          console.log(newObj) //{d:{c:{b:\"a\"}}}\n          ```\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        ```\n        ```\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        ```\n        var obj = {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n        var arr = []\n        for (let i in obj) {\n          let o = {};\n          o[i] = obj[i];\n          arr.push(o)\n        }\n        console.log(arr) // [{a: 1}, {b: 2}, {c: 3}]\n        ```\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        ```\n        // 1.Object.assign 2.扩展运算符（...）\n        const arr = [1, 2, 3]\n        Object.assign({},[1,2,3]) // {0: 1, 1: 2, 2: 3}\n        {...['a','b','c']} // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // forEach\n        let obj = {}\n        const arr = ['a','b','c']\n        arr.forEach((item,index)=>{obj[index] = item}) // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // for...in\n        let obj = {}\n        const arr = ['a','b','c']\n        for(var key in arr){\n          obj[key]=arr[key]\n        }\n        obj // {0: \"a\", 1: \"b\", 2: \"c\"}\n        ```\n        </div>\n    </li>\n    <li>\n        \n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","source":"_posts/JavaScript/JavaScript基础巩固篇.md","raw":"---\ntitle: JavaScript基础巩固篇\ndate: 2019-06-25 16:50:28\ntags: 编程语言\ncategories: JavaScript\nthumbnail: img/basic.jpg\n---\n<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<!-- more -->\n\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            ```\n            Object.prototype.toString.call([])  // \"[object Array]\"\n            Object.prototype.toString.call({})  // \"[object Object]\"\n            ```\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            ```\n            Array.isArray([])  // true\n            Array.isArray({})  // false\n            ```\n            <p>通过instanceof运算符来识别</p>\n            ```\n            console.log({} instanceof Array) // false \n            console.log([] instanceof Array) // true\n            ```\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            ```\n            Array.prototype.isPrototypeOf({}) // false\n            Array.prototype.isPrototypeOf([]) // true\n            Object.prototype.isPrototypeOf({}) // true\n            Object.prototype.isPrototypeOf([]) // false\n            ```\n            <p>通过constructor属性来区别</p>\n            ```\n            [].constructor // ƒ Array() { [native code] }\n            ({}).constructor // ƒ Object() { [native code] }\n            ```\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          ```\n          const a = {}\n          Object.keys(a).length // 是否为0\n          ```\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：http://www.imooc.com/article/277859\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：https://www.cnblogs.com/wangdashi/p/9606182.html\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>'abcd'变为{d:{c:{b:\"a\"}}}</p>\n          ```\n          const str = 'abcd'\n          const newObj = str.split('').reduce(function(prev, next){\n              const obj = {}\n              obj[next]=prev\n              return obj\n          })\n          console.log(newObj) //{d:{c:{b:\"a\"}}}\n          ```\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        ```\n        ```\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        ```\n        var obj = {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n        var arr = []\n        for (let i in obj) {\n          let o = {};\n          o[i] = obj[i];\n          arr.push(o)\n        }\n        console.log(arr) // [{a: 1}, {b: 2}, {c: 3}]\n        ```\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        ```\n        // 1.Object.assign 2.扩展运算符（...）\n        const arr = [1, 2, 3]\n        Object.assign({},[1,2,3]) // {0: 1, 1: 2, 2: 3}\n        {...['a','b','c']} // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // forEach\n        let obj = {}\n        const arr = ['a','b','c']\n        arr.forEach((item,index)=>{obj[index] = item}) // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // for...in\n        let obj = {}\n        const arr = ['a','b','c']\n        for(var key in arr){\n          obj[key]=arr[key]\n        }\n        obj // {0: \"a\", 1: \"b\", 2: \"c\"}\n        ```\n        </div>\n    </li>\n    <li>\n        \n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","slug":"JavaScript/JavaScript基础巩固篇","published":1,"updated":"2021-01-13T02:07:03.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ji0005vbxx96yv4m0a","content":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<a id=\"more\"></a>\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call([])  // &quot;[object Array]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(&#123;&#125;)  // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([])  // true</span><br><span class=\"line\">Array.isArray(&#123;&#125;)  // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过instanceof运算符来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#123;&#125; instanceof Array) // false </span><br><span class=\"line\">console.log([] instanceof Array) // true</span><br></pre></td></tr></table></figure>\n\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.isPrototypeOf(&#123;&#125;) // false</span><br><span class=\"line\">Array.prototype.isPrototypeOf([]) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf(&#123;&#125;) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf([]) // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过constructor属性来区别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor // ƒ Array() &#123; [native code] &#125;</span><br><span class=\"line\">(&#123;&#125;).constructor // ƒ Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;</span><br><span class=\"line\">Object.keys(a).length // 是否为0</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：<a href=\"http://www.imooc.com/article/277859\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/article/277859</a>\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：<a href=\"https://www.cnblogs.com/wangdashi/p/9606182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangdashi/p/9606182.html</a>\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>‘abcd’变为{d:{c:{b:”a”}}}</p>\n          <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;abcd&apos;</span><br><span class=\"line\">const newObj = str.split(&apos;&apos;).reduce(function(prev, next)&#123;</span><br><span class=\"line\">    const obj = &#123;&#125;</span><br><span class=\"line\">    obj[next]=prev</span><br><span class=\"line\">    return obj</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newObj) //&#123;d:&#123;c:&#123;b:&quot;a&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr = []</span><br><span class=\"line\">for (let i in obj) &#123;</span><br><span class=\"line\">  let o = &#123;&#125;;</span><br><span class=\"line\">  o[i] = obj[i];</span><br><span class=\"line\">  arr.push(o)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr) // [&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;]</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.Object.assign 2.扩展运算符（...）</span><br><span class=\"line\">const arr = [1, 2, 3]</span><br><span class=\"line\">Object.assign(&#123;&#125;,[1,2,3]) // &#123;0: 1, 1: 2, 2: 3&#125;</span><br><span class=\"line\">&#123;...[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&#125; // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// forEach</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">arr.forEach((item,index)=&gt;&#123;obj[index] = item&#125;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// for...in</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">for(var key in arr)&#123;</span><br><span class=\"line\">  obj[key]=arr[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>\n\n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>","more":"<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call([])  // &quot;[object Array]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(&#123;&#125;)  // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([])  // true</span><br><span class=\"line\">Array.isArray(&#123;&#125;)  // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过instanceof运算符来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#123;&#125; instanceof Array) // false </span><br><span class=\"line\">console.log([] instanceof Array) // true</span><br></pre></td></tr></table></figure>\n\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.isPrototypeOf(&#123;&#125;) // false</span><br><span class=\"line\">Array.prototype.isPrototypeOf([]) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf(&#123;&#125;) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf([]) // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过constructor属性来区别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor // ƒ Array() &#123; [native code] &#125;</span><br><span class=\"line\">(&#123;&#125;).constructor // ƒ Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;</span><br><span class=\"line\">Object.keys(a).length // 是否为0</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：<a href=\"http://www.imooc.com/article/277859\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/article/277859</a>\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：<a href=\"https://www.cnblogs.com/wangdashi/p/9606182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangdashi/p/9606182.html</a>\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>‘abcd’变为{d:{c:{b:”a”}}}</p>\n          <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;abcd&apos;</span><br><span class=\"line\">const newObj = str.split(&apos;&apos;).reduce(function(prev, next)&#123;</span><br><span class=\"line\">    const obj = &#123;&#125;</span><br><span class=\"line\">    obj[next]=prev</span><br><span class=\"line\">    return obj</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newObj) //&#123;d:&#123;c:&#123;b:&quot;a&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr = []</span><br><span class=\"line\">for (let i in obj) &#123;</span><br><span class=\"line\">  let o = &#123;&#125;;</span><br><span class=\"line\">  o[i] = obj[i];</span><br><span class=\"line\">  arr.push(o)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr) // [&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;]</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.Object.assign 2.扩展运算符（...）</span><br><span class=\"line\">const arr = [1, 2, 3]</span><br><span class=\"line\">Object.assign(&#123;&#125;,[1,2,3]) // &#123;0: 1, 1: 2, 2: 3&#125;</span><br><span class=\"line\">&#123;...[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&#125; // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// forEach</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">arr.forEach((item,index)=&gt;&#123;obj[index] = item&#125;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// for...in</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">for(var key in arr)&#123;</span><br><span class=\"line\">  obj[key]=arr[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>\n\n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"JavaScript的set和get","date":"2021-01-11T02:48:32.000Z","_content":"\n<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<!-- more -->\n\n<ol>\n  <li>ES6的set和get：\n    <div>\n      ```\n      class MyClass {\n        constructor () {\n          this.data = {}\n        }\n\n        set prop (value) {\n          this.data = value\n        }\n\n        get prop () {\n          return this.data\n        }\n      }\n\n      const test = new MyClass()\n      test.prop = 123\n      test.prop // output:'123'\n      ```\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    ```\n    let book = {\n      _year: 2020,\n      edition: 1\n    }\n    Object.defineProperty(book, 'year', {\n      get: function () {\n        return this._year\n      },\n      set: function (newValue) {\n        this._year = newValue\n        this.edition++\n      }\n    })\n    ```\n    </div>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","source":"_posts/JavaScript/JavaScript的set和get.md","raw":"---\ntitle: JavaScript的set和get\ndate: 2021-01-11 10:48:32\ntags: 编程语言\ncategories: JavaScript\n---\n\n<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<!-- more -->\n\n<ol>\n  <li>ES6的set和get：\n    <div>\n      ```\n      class MyClass {\n        constructor () {\n          this.data = {}\n        }\n\n        set prop (value) {\n          this.data = value\n        }\n\n        get prop () {\n          return this.data\n        }\n      }\n\n      const test = new MyClass()\n      test.prop = 123\n      test.prop // output:'123'\n      ```\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    ```\n    let book = {\n      _year: 2020,\n      edition: 1\n    }\n    Object.defineProperty(book, 'year', {\n      get: function () {\n        return this._year\n      },\n      set: function (newValue) {\n        this._year = newValue\n        this.edition++\n      }\n    })\n    ```\n    </div>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","slug":"JavaScript/JavaScript的set和get","published":1,"updated":"2021-01-11T04:56:14.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jj0008vbxx5cvfdzrd","content":"<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>ES6的set和get：\n    <div>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.data = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop (value) &#123;</span><br><span class=\"line\">    this.data = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop () &#123;</span><br><span class=\"line\">    return this.data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const test = new MyClass()</span><br><span class=\"line\">test.prop = 123</span><br><span class=\"line\">test.prop // output:&apos;123&apos;</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &apos;year&apos;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","site":{"data":{}},"excerpt":"<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>","more":"<ol>\n  <li>ES6的set和get：\n    <div>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.data = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop (value) &#123;</span><br><span class=\"line\">    this.data = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop () &#123;</span><br><span class=\"line\">    return this.data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const test = new MyClass()</span><br><span class=\"line\">test.prop = 123</span><br><span class=\"line\">test.prop // output:&apos;123&apos;</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &apos;year&apos;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>"},{"title":"JavaScript判断对象是否一致","date":"2019-09-03T20:33:31.000Z","_content":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为\"真\"，则返回真</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).some(key => { return objA[key] !== objB[key] })\n    }\n    isObjEqual(a, b) // true:不一致 false:一致 \n    ```\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为\"假\"，则返回假</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).every(key => { return objA[key] === objB[key] })\n    }\n    isObjEqual(a, b) // true:一致 false:不一致 \n    ```\n    </div>\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>此处也可用for...in来实现</li>\n  <li>循环中断参考：https://juejin.im/entry/5884717a1b69e6005919f0d3</li>\n</ol>","source":"_posts/JavaScript/JavaScript判断对象是否一致.md","raw":"---\ntitle: JavaScript判断对象是否一致\ndate: 2019-09-04 04:33:31\ntags:\ncategories: JavaScript\n---\n<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为\"真\"，则返回真</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).some(key => { return objA[key] !== objB[key] })\n    }\n    isObjEqual(a, b) // true:不一致 false:一致 \n    ```\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为\"假\"，则返回假</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).every(key => { return objA[key] === objB[key] })\n    }\n    isObjEqual(a, b) // true:一致 false:不一致 \n    ```\n    </div>\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>此处也可用for...in来实现</li>\n  <li>循环中断参考：https://juejin.im/entry/5884717a1b69e6005919f0d3</li>\n</ol>","slug":"JavaScript/JavaScript判断对象是否一致","published":1,"updated":"2021-01-01T05:33:11.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jk0009vbxxq0iu1wq7","content":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为”真”，则返回真</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).some(key =&gt; &#123; return objA[key] !== objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:不一致 false:一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为”假”，则返回假</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).every(key =&gt; &#123; return objA[key] === objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:一致 false:不一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>此处也可用for…in来实现</li>\n  <li>循环中断参考：<a href=\"https://juejin.im/entry/5884717a1b69e6005919f0d3\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5884717a1b69e6005919f0d3</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为”真”，则返回真</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).some(key =&gt; &#123; return objA[key] !== objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:不一致 false:一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为”假”，则返回假</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).every(key =&gt; &#123; return objA[key] === objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:一致 false:不一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>此处也可用for…in来实现</li>\n  <li>循环中断参考：<a href=\"https://juejin.im/entry/5884717a1b69e6005919f0d3\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5884717a1b69e6005919f0d3</a></li>\n</ol>"},{"title":"实现一个简单的模板引擎","date":"2021-01-30T13:39:08.000Z","_content":"\n编写add方法，让结果符合预期\nadd(2, 5); // 7\nadd(2)(5); // 7\n\n\n实现一个简单的模板引擎\n```\nlet template = '我是{{name}}，年龄{{age}}，性别{{sex}}';\n\nlet data = {\n\n  name: '姓名',\n\n  age: 18\n\n};\n\nrender(template, data); // 我是姓名，年龄18，性别undefined\n```","source":"_posts/JavaScript/实现一个简单的模板引擎.md","raw":"---\ntitle: 实现一个简单的模板引擎\ndate: 2021-01-30 21:39:08\ntags: 编程语言\ncategories: JavaScript\n---\n\n编写add方法，让结果符合预期\nadd(2, 5); // 7\nadd(2)(5); // 7\n\n\n实现一个简单的模板引擎\n```\nlet template = '我是{{name}}，年龄{{age}}，性别{{sex}}';\n\nlet data = {\n\n  name: '姓名',\n\n  age: 18\n\n};\n\nrender(template, data); // 我是姓名，年龄18，性别undefined\n```","slug":"JavaScript/实现一个简单的模板引擎","published":1,"updated":"2021-01-30T13:40:42.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jm000cvbxx0zs9fg9r","content":"<p>编写add方法，让结果符合预期\nadd(2, 5); // 7\nadd(2)(5); // 7</p>\n<p>实现一个简单的模板引擎\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let template = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  name: &apos;姓名&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  age: 18</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">render(template, data); // 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>编写add方法，让结果符合预期\nadd(2, 5); // 7\nadd(2)(5); // 7</p>\n<p>实现一个简单的模板引擎\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let template = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">let data = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  name: &apos;姓名&apos;,</span><br><span class=\"line\"></span><br><span class=\"line\">  age: 18</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">render(template, data); // 我是姓名，年龄18，性别undefined</span><br></pre></td></tr></table></figure></p>\n"},{"title":"this机制","date":"2020-09-02T03:52:38.000Z","toc":true,"_content":"\n<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<!-- more -->\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","source":"_posts/JavaScript/this机制.md","raw":"---\ntitle: this机制\ndate: 2020-09-02 11:52:38\ntoc: true\ncategories: JavaScript\n---\n\n<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<!-- more -->\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","slug":"JavaScript/this机制","published":1,"updated":"2021-01-01T05:33:28.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jo000fvbxx1965161h","content":"<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>","more":"<p style=\"text-indent:30px\">\n  提出问题：\n</p>"},{"title":"JavaScript实现继承的几种方式","date":"2019-06-09T05:39:07.000Z","toc":true,"_content":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<!-- more -->\n\n以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。\n\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n```\n    function Animal() {\n        this.home = \"earth\"\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(color) {\n        this.color = color\n    }\n\n    // 原型对象等于另一个类型的实例\n    Cat.prototype = new Animal()\n\n    // 添加新方法\n    Cat.prototype.eat = function () {\n        return \"fish\"\n    }\n\n    var whiteCat = new Cat()\n    \n    alert(whiteCat.home) // \"earth\"\n    alert(whiteCat.say()) // \"hello\"\n    alert(whiteCat.eat()) // \"fish\"\n```\n\n<注>\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n```\n    function Animal() {\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    function Cat() {\n        Animal.call(this)\n    }\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors = \"black\"\n\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // \"black\"\n```\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n```\n    function Animal(age) {\n        this.age = age\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(age) {\n        // 继承属性\n        Animal.call(this, age)\n    }\n\n    // 继承方法\n    Cat.prototype = new Animal();\n\n    Cat.prototype.constructor = Cat;\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors.push(\"black\")\n\n    calico.say() // \"hello\"\n    blackCat.say() // \"hello\"\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // [\"red\", \"blue\", \"yellow\", \"black\"]\n\n```\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<注>\n    <p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p>\n\n<h4>寄生组合式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n```\n    function inheritPrototype(subType, superType){\n        var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)\n        prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性\n        subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型\n    }\n    function Animal(name) {\n        this.name = name;\n    }\n    Animal.prototype.sayName = function () {\n        alert(this.name);\n    };\n    function Cat(name, age) {\n        Animal.call(this,name);  //继承SuperType\n        this.age = age;       //扩展出age属性\n    }\n    inheritPrototype(Cat, Animal);\n    Cat.prototype.sayAge = function () {\n        alert(this.age);\n    };//扩展出sayAge方法\n\n    var calico=new Cat(\"linda\",2);\n    calico.sayName();\n    calico.sayAge();\n```\n\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<h4 style=\"color:blue;\">ES6实现继承</h4>\n<p style=\"text-indent:30px\"></p>\n```\nclass Animal {\n    //构造函数\n    constructor(props) {\n      this.name = props.name || '未知';\n    }\n\n    eat() {\n      alert(this.name + \"在吃东西...\");\n    }\n  }\n\n  //class继承\n  class Bird extends Animal {\n    //构造函数\n    constructor(props) {\n      //调用实现父类的构造函数\n      super(props);\n      this.type = props.type || \"未知\";\n    }\n\n    fly() {\n      alert(this.name + \"在飞...\");\n    }\n  }\n  var myBird = new Bird({\n    name: '鹦鹉'\n  })\n  myBird.eat()\n  myBird.fly()\n```\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","source":"_posts/JavaScript/JavaScript实现继承的几种方式.md","raw":"---\ntitle: JavaScript实现继承的几种方式\ndate: 2019-06-09 13:39:07\ntoc: true\ncategories: JavaScript\n# thumbnail: img/shell.jpg\n---\n<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<!-- more -->\n\n以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。\n\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n```\n    function Animal() {\n        this.home = \"earth\"\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(color) {\n        this.color = color\n    }\n\n    // 原型对象等于另一个类型的实例\n    Cat.prototype = new Animal()\n\n    // 添加新方法\n    Cat.prototype.eat = function () {\n        return \"fish\"\n    }\n\n    var whiteCat = new Cat()\n    \n    alert(whiteCat.home) // \"earth\"\n    alert(whiteCat.say()) // \"hello\"\n    alert(whiteCat.eat()) // \"fish\"\n```\n\n<注>\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n```\n    function Animal() {\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    function Cat() {\n        Animal.call(this)\n    }\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors = \"black\"\n\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // \"black\"\n```\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n```\n    function Animal(age) {\n        this.age = age\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(age) {\n        // 继承属性\n        Animal.call(this, age)\n    }\n\n    // 继承方法\n    Cat.prototype = new Animal();\n\n    Cat.prototype.constructor = Cat;\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors.push(\"black\")\n\n    calico.say() // \"hello\"\n    blackCat.say() // \"hello\"\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // [\"red\", \"blue\", \"yellow\", \"black\"]\n\n```\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<注>\n    <p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p>\n\n<h4>寄生组合式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n```\n    function inheritPrototype(subType, superType){\n        var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)\n        prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性\n        subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型\n    }\n    function Animal(name) {\n        this.name = name;\n    }\n    Animal.prototype.sayName = function () {\n        alert(this.name);\n    };\n    function Cat(name, age) {\n        Animal.call(this,name);  //继承SuperType\n        this.age = age;       //扩展出age属性\n    }\n    inheritPrototype(Cat, Animal);\n    Cat.prototype.sayAge = function () {\n        alert(this.age);\n    };//扩展出sayAge方法\n\n    var calico=new Cat(\"linda\",2);\n    calico.sayName();\n    calico.sayAge();\n```\n\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<h4 style=\"color:blue;\">ES6实现继承</h4>\n<p style=\"text-indent:30px\"></p>\n```\nclass Animal {\n    //构造函数\n    constructor(props) {\n      this.name = props.name || '未知';\n    }\n\n    eat() {\n      alert(this.name + \"在吃东西...\");\n    }\n  }\n\n  //class继承\n  class Bird extends Animal {\n    //构造函数\n    constructor(props) {\n      //调用实现父类的构造函数\n      super(props);\n      this.type = props.type || \"未知\";\n    }\n\n    fly() {\n      alert(this.name + \"在飞...\");\n    }\n  }\n  var myBird = new Bird({\n    name: '鹦鹉'\n  })\n  myBird.eat()\n  myBird.fly()\n```\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","slug":"JavaScript/JavaScript实现继承的几种方式","published":1,"updated":"2021-01-01T05:33:16.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jp000jvbxxjqgmwm85","content":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<a id=\"more\"></a>\n<p>以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。</p>\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.home = &quot;earth&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(color) &#123;</span><br><span class=\"line\">    this.color = color</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 原型对象等于另一个类型的实例</span><br><span class=\"line\">Cat.prototype = new Animal()</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加新方法</span><br><span class=\"line\">Cat.prototype.eat = function () &#123;</span><br><span class=\"line\">    return &quot;fish&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var whiteCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(whiteCat.home) // &quot;earth&quot;</span><br><span class=\"line\">alert(whiteCat.say()) // &quot;hello&quot;</span><br><span class=\"line\">alert(whiteCat.eat()) // &quot;fish&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat() &#123;</span><br><span class=\"line\">    Animal.call(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors = &quot;black&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // &quot;black&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(age) &#123;</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(age) &#123;</span><br><span class=\"line\">    // 继承属性</span><br><span class=\"line\">    Animal.call(this, age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承方法</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors.push(&quot;black&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">calico.say() // &quot;hello&quot;</span><br><span class=\"line\">blackCat.say() // &quot;hello&quot;</span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<p>&lt;注&gt;\n    </p><p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p><p></p>\n<p></p><h4>寄生组合式继承</h4><p></p>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)</span><br><span class=\"line\">    prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性</span><br><span class=\"line\">    subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Animal(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sayName = function () &#123;</span><br><span class=\"line\">    alert(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Cat(name, age) &#123;</span><br><span class=\"line\">    Animal.call(this,name);  //继承SuperType</span><br><span class=\"line\">    this.age = age;       //扩展出age属性</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Cat, Animal);</span><br><span class=\"line\">Cat.prototype.sayAge = function () &#123;</span><br><span class=\"line\">    alert(this.age);</span><br><span class=\"line\">&#125;;//扩展出sayAge方法</span><br><span class=\"line\"></span><br><span class=\"line\">var calico=new Cat(&quot;linda&quot;,2);</span><br><span class=\"line\">calico.sayName();</span><br><span class=\"line\">calico.sayAge();</span><br></pre></td></tr></table></figure>\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<p></p><h4 style=\"color:blue;\">ES6实现继承</h4><p></p>\n<p></p><p style=\"text-indent:30px\"></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &apos;未知&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在吃东西...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.type = props.type || &quot;未知&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在飞...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &apos;鹦鹉&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","site":{"data":{}},"excerpt":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>","more":"<p>以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。</p>\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.home = &quot;earth&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(color) &#123;</span><br><span class=\"line\">    this.color = color</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 原型对象等于另一个类型的实例</span><br><span class=\"line\">Cat.prototype = new Animal()</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加新方法</span><br><span class=\"line\">Cat.prototype.eat = function () &#123;</span><br><span class=\"line\">    return &quot;fish&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var whiteCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(whiteCat.home) // &quot;earth&quot;</span><br><span class=\"line\">alert(whiteCat.say()) // &quot;hello&quot;</span><br><span class=\"line\">alert(whiteCat.eat()) // &quot;fish&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat() &#123;</span><br><span class=\"line\">    Animal.call(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors = &quot;black&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // &quot;black&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(age) &#123;</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(age) &#123;</span><br><span class=\"line\">    // 继承属性</span><br><span class=\"line\">    Animal.call(this, age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承方法</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors.push(&quot;black&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">calico.say() // &quot;hello&quot;</span><br><span class=\"line\">blackCat.say() // &quot;hello&quot;</span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<p>&lt;注&gt;\n    </p><p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p><p></p>\n<p></p><h4>寄生组合式继承</h4><p></p>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)</span><br><span class=\"line\">    prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性</span><br><span class=\"line\">    subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Animal(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sayName = function () &#123;</span><br><span class=\"line\">    alert(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Cat(name, age) &#123;</span><br><span class=\"line\">    Animal.call(this,name);  //继承SuperType</span><br><span class=\"line\">    this.age = age;       //扩展出age属性</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Cat, Animal);</span><br><span class=\"line\">Cat.prototype.sayAge = function () &#123;</span><br><span class=\"line\">    alert(this.age);</span><br><span class=\"line\">&#125;;//扩展出sayAge方法</span><br><span class=\"line\"></span><br><span class=\"line\">var calico=new Cat(&quot;linda&quot;,2);</span><br><span class=\"line\">calico.sayName();</span><br><span class=\"line\">calico.sayAge();</span><br></pre></td></tr></table></figure>\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<p></p><h4 style=\"color:blue;\">ES6实现继承</h4><p></p>\n<p></p><p style=\"text-indent:30px\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &apos;未知&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在吃东西...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.type = props.type || &quot;未知&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在飞...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &apos;鹦鹉&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>"},{"title":"如何手动实现form表单提交的url","date":"2019-09-03T19:41:50.000Z","_content":"<p>这个问题比较有趣，记录一下！</p>\n\n<!-- more -->\n\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p>方法: Object.entries(for...in) + map</p>\n```\nconst params = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4\n}\n\nconst paramsString = Object.entries(params).map(item => {\n  return item[0] + '=' + item[1]\n}).join('&')\n\nconst url = 'https://www.google.com?' + paramsString\n\n// output: https://www.google.com?a=1&b=2&c=3&d=4\n\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  ```\n  const obj = { foo: 'bar', baz: 42 };\n  console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n  ```\n  </li>\n  <li>Object.entries()和for...in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for...in好，故用的也比较少。for...in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for...in</div>\n  </li>\n</ol>\n","source":"_posts/JavaScript/如何手动实现form表单提交的url.md","raw":"---\ntitle: 如何手动实现form表单提交的url\ndate: 2019-09-04 03:41:50\ntags:\ncategories: JavaScript\n---\n<p>这个问题比较有趣，记录一下！</p>\n\n<!-- more -->\n\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p>方法: Object.entries(for...in) + map</p>\n```\nconst params = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4\n}\n\nconst paramsString = Object.entries(params).map(item => {\n  return item[0] + '=' + item[1]\n}).join('&')\n\nconst url = 'https://www.google.com?' + paramsString\n\n// output: https://www.google.com?a=1&b=2&c=3&d=4\n\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  ```\n  const obj = { foo: 'bar', baz: 42 };\n  console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n  ```\n  </li>\n  <li>Object.entries()和for...in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for...in好，故用的也比较少。for...in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for...in</div>\n  </li>\n</ol>\n","slug":"JavaScript/如何手动实现form表单提交的url","published":1,"updated":"2021-01-01T05:32:54.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jq000nvbxxscvjhbik","content":"<p>这个问题比较有趣，记录一下！</p>\n\n<a id=\"more\"></a>\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&amp;”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p></p><p>方法: Object.entries(for…in) + map</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const params = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3,</span><br><span class=\"line\">  d: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const paramsString = Object.entries(params).map(item =&gt; &#123;</span><br><span class=\"line\">  return item[0] + &apos;=&apos; + item[1]</span><br><span class=\"line\">&#125;).join(&apos;&amp;&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const url = &apos;https://www.google.com?&apos; + paramsString</span><br><span class=\"line\"></span><br><span class=\"line\">// output: https://www.google.com?a=1&amp;b=2&amp;c=3&amp;d=4</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class=\"line\">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.entries()和for…in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for…in好，故用的也比较少。for…in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for…in</div>\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这个问题比较有趣，记录一下！</p>","more":"<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&amp;”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p></p><p>方法: Object.entries(for…in) + map</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const params = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3,</span><br><span class=\"line\">  d: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const paramsString = Object.entries(params).map(item =&gt; &#123;</span><br><span class=\"line\">  return item[0] + &apos;=&apos; + item[1]</span><br><span class=\"line\">&#125;).join(&apos;&amp;&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const url = &apos;https://www.google.com?&apos; + paramsString</span><br><span class=\"line\"></span><br><span class=\"line\">// output: https://www.google.com?a=1&amp;b=2&amp;c=3&amp;d=4</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class=\"line\">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.entries()和for…in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for…in好，故用的也比较少。for…in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for…in</div>\n  </li>\n</ol>"},{"title":"宏任务和微任务","date":"2021-01-07T04:40:00.000Z","_content":"\n<p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p>\n<p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p>\n\n<!-- more -->\n\n![事件循环](/img/eventloop.jpg)\n\n<h5>常见的宏任务</h5>\n<ul>\n  <li>主代码块</li>\n  <li>setTimeout</li>\n  <li>setInterval</li>\n  <li>setImmediate ()-Node</li>\n  <li>requestAnimationFrame ()-浏览器</li>\n</ul>\n\n<h5>常见微任务</h5>\n<ul>\n  <li>Promise.then()</li>\n  <li>process.nextTick ()-Node</li>\n  <li>catch</li>\n  <li>finally</li>\n  <li>Object.observe</li>\n  <li>MutationObserver</li>\n</ul>\n\n<h5>宏任务和微任务注意点：</h5>\n<ol>\n  <li>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</li>\n  <li>微任务和宏任务不在一个任务队列，不在一个任务队列</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>https://juejin.cn/post/6844904050543034376</li>\n  <li>https://cloud.tencent.com/developer/article/1701427</li>\n</ol>","source":"_posts/JavaScript/宏任务和微任务.md","raw":"---\ntitle: 宏任务和微任务\ndate: 2021-01-07 12:40:00\ntags: 编程语言\ncategories: JavaScript\n---\n\n<p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p>\n<p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p>\n\n<!-- more -->\n\n![事件循环](/img/eventloop.jpg)\n\n<h5>常见的宏任务</h5>\n<ul>\n  <li>主代码块</li>\n  <li>setTimeout</li>\n  <li>setInterval</li>\n  <li>setImmediate ()-Node</li>\n  <li>requestAnimationFrame ()-浏览器</li>\n</ul>\n\n<h5>常见微任务</h5>\n<ul>\n  <li>Promise.then()</li>\n  <li>process.nextTick ()-Node</li>\n  <li>catch</li>\n  <li>finally</li>\n  <li>Object.observe</li>\n  <li>MutationObserver</li>\n</ul>\n\n<h5>宏任务和微任务注意点：</h5>\n<ol>\n  <li>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</li>\n  <li>微任务和宏任务不在一个任务队列，不在一个任务队列</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>https://juejin.cn/post/6844904050543034376</li>\n  <li>https://cloud.tencent.com/developer/article/1701427</li>\n</ol>","slug":"JavaScript/宏任务和微任务","published":1,"updated":"2021-01-19T05:24:08.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3js000qvbxxg1a7ruxj","content":"<p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p>\n<p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p>\n\n<a id=\"more\"></a>\n<p><img src=\"/img/eventloop.jpg\" alt=\"事件循环\"></p>\n<p></p><h5>常见的宏任务</h5><p></p>\n<ul>\n  <li>主代码块</li>\n  <li>setTimeout</li>\n  <li>setInterval</li>\n  <li>setImmediate ()-Node</li>\n  <li>requestAnimationFrame ()-浏览器</li>\n</ul>\n\n<p></p><h5>常见微任务</h5><p></p>\n<ul>\n  <li>Promise.then()</li>\n  <li>process.nextTick ()-Node</li>\n  <li>catch</li>\n  <li>finally</li>\n  <li>Object.observe</li>\n  <li>MutationObserver</li>\n</ul>\n\n<p></p><h5>宏任务和微任务注意点：</h5><p></p>\n<ol>\n  <li>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</li>\n  <li>微任务和宏任务不在一个任务队列，不在一个任务队列</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904050543034376\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904050543034376</a></li>\n  <li><a href=\"https://cloud.tencent.com/developer/article/1701427\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1701427</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他</p>\n<p>我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务</p>","more":"<p><img src=\"/img/eventloop.jpg\" alt=\"事件循环\"></p>\n<p></p><h5>常见的宏任务</h5><p></p>\n<ul>\n  <li>主代码块</li>\n  <li>setTimeout</li>\n  <li>setInterval</li>\n  <li>setImmediate ()-Node</li>\n  <li>requestAnimationFrame ()-浏览器</li>\n</ul>\n\n<p></p><h5>常见微任务</h5><p></p>\n<ul>\n  <li>Promise.then()</li>\n  <li>process.nextTick ()-Node</li>\n  <li>catch</li>\n  <li>finally</li>\n  <li>Object.observe</li>\n  <li>MutationObserver</li>\n</ul>\n\n<p></p><h5>宏任务和微任务注意点：</h5><p></p>\n<ol>\n  <li>浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务</li>\n  <li>微任务和宏任务不在一个任务队列，不在一个任务队列</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904050543034376\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904050543034376</a></li>\n  <li><a href=\"https://cloud.tencent.com/developer/article/1701427\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1701427</a></li>\n</ol>"},{"title":"手写一个reduce","date":"2021-01-13T11:05:14.000Z","thumbnail":"img/knowledge.png","_content":"\nreduce累加器的js实现\n<!-- more -->\n\n```\nArray.prototype.myReduce = function (callback, initVal) {\n  const arr = this\n\n  arr.forEach((item) => {\n    initVal = callback(item, initVal)\n  })\n\n  return initVal\n}\n```\n\n测试一下：\n```\nconst datas = [4, 8, 15, 16, 23, 42]\n\nconst sum = datas.myReduce(function (prev, next) {\n  return prev + next\n}, 0)\n\nconsole.log(sum) // 108\n```\n","source":"_posts/JavaScript/手写一个reduce.md","raw":"---\ntitle: 手写一个reduce\ndate: 2021-01-13 19:05:14\ntags: 编程语言\ncategories: JavaScript\nthumbnail: img/knowledge.png\n---\n\nreduce累加器的js实现\n<!-- more -->\n\n```\nArray.prototype.myReduce = function (callback, initVal) {\n  const arr = this\n\n  arr.forEach((item) => {\n    initVal = callback(item, initVal)\n  })\n\n  return initVal\n}\n```\n\n测试一下：\n```\nconst datas = [4, 8, 15, 16, 23, 42]\n\nconst sum = datas.myReduce(function (prev, next) {\n  return prev + next\n}, 0)\n\nconsole.log(sum) // 108\n```\n","slug":"JavaScript/手写一个reduce","published":1,"updated":"2021-01-25T06:08:49.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3js000tvbxx8kmlidll","content":"<p>reduce累加器的js实现\n<a id=\"more\"></a></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (callback, initVal) &#123;</span><br><span class=\"line\">  const arr = this</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.forEach((item) =&gt; &#123;</span><br><span class=\"line\">    initVal = callback(item, initVal)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return initVal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const datas = [4, 8, 15, 16, 23, 42]</span><br><span class=\"line\"></span><br><span class=\"line\">const sum = datas.myReduce(function (prev, next) &#123;</span><br><span class=\"line\">  return prev + next</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum) // 108</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>reduce累加器的js实现</p>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (callback, initVal) &#123;</span><br><span class=\"line\">  const arr = this</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.forEach((item) =&gt; &#123;</span><br><span class=\"line\">    initVal = callback(item, initVal)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return initVal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const datas = [4, 8, 15, 16, 23, 42]</span><br><span class=\"line\"></span><br><span class=\"line\">const sum = datas.myReduce(function (prev, next) &#123;</span><br><span class=\"line\">  return prev + next</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum) // 108</span><br></pre></td></tr></table></figure></p>"},{"title":"手写一个compose","date":"2021-01-13T15:58:42.000Z","_content":"\n<p>从右到左循环调用</p>\n\n<!-- more -->\n\n```\nfunction compose (...args) {\n  return function (x) {\n    return args.reduceRight((prev, cur) => {\n      return cur(prev)\n    }, x)\n  }\n}\n```\n\n测试一下：\n```\nfunction toUpperCase (str) {\n  return str.toUpperCase()\n}\n\nfunction add (str) {\n  return str += '!'\n}\n\nconst fn = compose(add, toUpperCase)\nconsole.log(fn('hello')) // 'HELLO!'\n```","source":"_posts/JavaScript/手写一个compose.md","raw":"---\ntitle: 手写一个compose\ndate: 2021-01-13 23:58:42\ntags: 编程语言\ncategories: JavaScript\n---\n\n<p>从右到左循环调用</p>\n\n<!-- more -->\n\n```\nfunction compose (...args) {\n  return function (x) {\n    return args.reduceRight((prev, cur) => {\n      return cur(prev)\n    }, x)\n  }\n}\n```\n\n测试一下：\n```\nfunction toUpperCase (str) {\n  return str.toUpperCase()\n}\n\nfunction add (str) {\n  return str += '!'\n}\n\nconst fn = compose(add, toUpperCase)\nconsole.log(fn('hello')) // 'HELLO!'\n```","slug":"JavaScript/手写一个compose","published":1,"updated":"2021-01-25T06:08:24.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jt000wvbxx83wip9yp","content":"<p>从右到左循环调用</p>\n\n<a id=\"more\"></a>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose (...args) &#123;</span><br><span class=\"line\">  return function (x) &#123;</span><br><span class=\"line\">    return args.reduceRight((prev, cur) =&gt; &#123;</span><br><span class=\"line\">      return cur(prev)</span><br><span class=\"line\">    &#125;, x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toUpperCase (str) &#123;</span><br><span class=\"line\">  return str.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function add (str) &#123;</span><br><span class=\"line\">  return str += &apos;!&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const fn = compose(add, toUpperCase)</span><br><span class=\"line\">console.log(fn(&apos;hello&apos;)) // &apos;HELLO!&apos;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>从右到左循环调用</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function compose (...args) &#123;</span><br><span class=\"line\">  return function (x) &#123;</span><br><span class=\"line\">    return args.reduceRight((prev, cur) =&gt; &#123;</span><br><span class=\"line\">      return cur(prev)</span><br><span class=\"line\">    &#125;, x)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function toUpperCase (str) &#123;</span><br><span class=\"line\">  return str.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function add (str) &#123;</span><br><span class=\"line\">  return str += &apos;!&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const fn = compose(add, toUpperCase)</span><br><span class=\"line\">console.log(fn(&apos;hello&apos;)) // &apos;HELLO!&apos;</span><br></pre></td></tr></table></figure></p>"},{"title":"请求后台数据的几种方式","date":"2019-07-03T07:35:58.000Z","_content":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<!-- more -->\n\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        ```\n        var xmlhttp;\n        function loadXMLDoc(url)\n        {\n            xmlhttp=null;\n            if (window.XMLHttpRequest)\n            {   \n                xmlhttp=new XMLHttpRequest();\n            } else if (window.ActiveXObject) {\n                // for IE5 and IE6\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            if (xmlhttp != null)\n            {\n                xmlhttp.onreadystatechange=state_Change;\n                // Get请求\n                xmlhttp.open(\"GET\",url,true);\n                xmlhttp.send(null);\n                // POST请求\n                <!-- xhr.open('POST', '/user/login');\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                var param = {\n                    name = 'peter'\n                }\n                xmlHttp.send(param) -->\n            } else {\n                alert(\"Your browser does not support XMLHTTP.\");\n            }\n        }\n\n        function state_Change()\n        {\n            if (xmlhttp.readyState==4)\n            {\n                // 4 = \"loaded\"\n                if (xmlhttp.status==200)\n                {\n                    // 200 = OK\n                    console.log(JSON.parse(xhr.responseText))\n                } else {\n                    alert(\"Problem retrieving XML data\");\n                }\n            }\n        }\n        ```\n        <div>\n           <p> more：</p>\n            http://www.w3school.com.cn/xml/xml_http.asp\n            https://www.cnblogs.com/aimeeblogs/articles/9501946.html\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        ```\n        $.ajax({\n            type: 'POST',\n            url: url,\n            data: data,\n            dataType: dataType,\n            success: function () {},\n            error: function () {}\n        );\n        ```\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        ```\n        axios.get('/user', {\n            params: {\n                ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n        ```\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： https://www.kancloud.cn/yunye/axios/234845</p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：https://segmentfault.com/a/1190000012836882</p>\n    </li>\n</ol>","source":"_posts/JavaScript/请求后台数据的几种方式.md","raw":"---\ntitle: 请求后台数据的几种方式\ndate: 2019-07-03 15:35:58\ntags: 前后端分离\ncategories: JavaScript\n---\n<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<!-- more -->\n\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        ```\n        var xmlhttp;\n        function loadXMLDoc(url)\n        {\n            xmlhttp=null;\n            if (window.XMLHttpRequest)\n            {   \n                xmlhttp=new XMLHttpRequest();\n            } else if (window.ActiveXObject) {\n                // for IE5 and IE6\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            if (xmlhttp != null)\n            {\n                xmlhttp.onreadystatechange=state_Change;\n                // Get请求\n                xmlhttp.open(\"GET\",url,true);\n                xmlhttp.send(null);\n                // POST请求\n                <!-- xhr.open('POST', '/user/login');\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                var param = {\n                    name = 'peter'\n                }\n                xmlHttp.send(param) -->\n            } else {\n                alert(\"Your browser does not support XMLHTTP.\");\n            }\n        }\n\n        function state_Change()\n        {\n            if (xmlhttp.readyState==4)\n            {\n                // 4 = \"loaded\"\n                if (xmlhttp.status==200)\n                {\n                    // 200 = OK\n                    console.log(JSON.parse(xhr.responseText))\n                } else {\n                    alert(\"Problem retrieving XML data\");\n                }\n            }\n        }\n        ```\n        <div>\n           <p> more：</p>\n            http://www.w3school.com.cn/xml/xml_http.asp\n            https://www.cnblogs.com/aimeeblogs/articles/9501946.html\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        ```\n        $.ajax({\n            type: 'POST',\n            url: url,\n            data: data,\n            dataType: dataType,\n            success: function () {},\n            error: function () {}\n        );\n        ```\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        ```\n        axios.get('/user', {\n            params: {\n                ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n        ```\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： https://www.kancloud.cn/yunye/axios/234845</p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：https://segmentfault.com/a/1190000012836882</p>\n    </li>\n</ol>","slug":"JavaScript/请求后台数据的几种方式","published":1,"updated":"2021-01-01T05:32:49.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ju000zvbxxjxdvjjcp","content":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<a id=\"more\"></a>\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp=null;</span><br><span class=\"line\">    if (window.XMLHttpRequest)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">    &#125; else if (window.ActiveXObject) &#123;</span><br><span class=\"line\">        // for IE5 and IE6</span><br><span class=\"line\">        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (xmlhttp != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">        // Get请求</span><br><span class=\"line\">        xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">        xmlhttp.send(null);</span><br><span class=\"line\">        // POST请求</span><br><span class=\"line\">        &lt;!-- xhr.open(&apos;POST&apos;, &apos;/user/login&apos;);</span><br><span class=\"line\">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">        var param = &#123;</span><br><span class=\"line\">            name = &apos;peter&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xmlHttp.send(param) --&gt;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState==4)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 4 = &quot;loaded&quot;</span><br><span class=\"line\">        if (xmlhttp.status==200)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 200 = OK</span><br><span class=\"line\">            console.log(JSON.parse(xhr.responseText))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            alert(&quot;Problem retrieving XML data&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n        <div>\n           <p> more：</p>\n            <a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a>\n            <a href=\"https://www.cnblogs.com/aimeeblogs/articles/9501946.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aimeeblogs/articles/9501946.html</a>\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;POST&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    dataType: dataType,</span><br><span class=\"line\">    success: function () &#123;&#125;,</span><br><span class=\"line\">    error: function () &#123;&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： <a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/yunye/axios/234845</a></p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：<a href=\"https://segmentfault.com/a/1190000012836882\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012836882</a></p>\n    </li>\n</ol>","site":{"data":{}},"excerpt":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>","more":"<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp=null;</span><br><span class=\"line\">    if (window.XMLHttpRequest)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">    &#125; else if (window.ActiveXObject) &#123;</span><br><span class=\"line\">        // for IE5 and IE6</span><br><span class=\"line\">        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (xmlhttp != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">        // Get请求</span><br><span class=\"line\">        xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">        xmlhttp.send(null);</span><br><span class=\"line\">        // POST请求</span><br><span class=\"line\">        &lt;!-- xhr.open(&apos;POST&apos;, &apos;/user/login&apos;);</span><br><span class=\"line\">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">        var param = &#123;</span><br><span class=\"line\">            name = &apos;peter&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xmlHttp.send(param) --&gt;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState==4)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 4 = &quot;loaded&quot;</span><br><span class=\"line\">        if (xmlhttp.status==200)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 200 = OK</span><br><span class=\"line\">            console.log(JSON.parse(xhr.responseText))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            alert(&quot;Problem retrieving XML data&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n        <div>\n           <p> more：</p>\n            <a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a>\n            <a href=\"https://www.cnblogs.com/aimeeblogs/articles/9501946.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aimeeblogs/articles/9501946.html</a>\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;POST&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    dataType: dataType,</span><br><span class=\"line\">    success: function () &#123;&#125;,</span><br><span class=\"line\">    error: function () &#123;&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： <a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/yunye/axios/234845</a></p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：<a href=\"https://segmentfault.com/a/1190000012836882\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012836882</a></p>\n    </li>\n</ol>"},{"title":"深拷贝&浅拷贝","date":"2020-12-21T15:52:27.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6908606240356581389</li>\n</ol>\n","source":"_posts/JavaScript/深拷贝&浅拷贝.md","raw":"---\ntitle: 深拷贝&浅拷贝\ndate: 2020-12-21 23:52:27\ntags: 编程语言\ncategories: JavaScript\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6908606240356581389</li>\n</ol>\n","slug":"JavaScript/深拷贝&浅拷贝","published":1,"updated":"2021-01-01T05:32:58.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jv0012vbxx56dvntq9","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6908606240356581389\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6908606240356581389</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6908606240356581389\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6908606240356581389</a></li>\n</ol>\n"},{"title":"函数防抖和节流","date":"2021-01-11T15:13:25.000Z","_content":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<!-- more -->\n\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        ```\n        var timer;\n        function debounce (fn, delay, ...args) {\n          clearTimeout(timer)\n          timer = setTimeout(() => {\n            console.log(args)\n            fn(args)\n          }, delay)\n        }\n\n        document.onclick = function () {\n          debounce(testDebounce, 5000, 1111, 2222)\n        }\n\n        function testDebounce (...args) {\n          console.log(args)\n        }\n        ```\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        ```\n        function throttle (fn, delay) {\n          var previous = 0\n          // 使用闭包返回一个函数并且用到闭包函数外面的变量previous\n          return function () {\n            var _this = this\n            var args = arguments\n            var now = new Date()\n            if (now - previous > delay) {\n              fn.apply(_this, args)\n\n              previous = now\n            }\n          }\n        }\n\n        var testThrottleFn = throttle(testThrottle, 5000) // 节流函数\n\n        document.onclick = function (e) {\n          testThrottleFn(e, 'throttle') // 给节流函数传参\n        }\n\n        function testThrottle (e, content) {\n          console.log(e, content)\n        }\n        ```\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","source":"_posts/JavaScript/防抖和节流.md","raw":"---\ntitle: 函数防抖和节流\ndate: 2021-01-11 23:13:25\ntags:\ncategories: JavaScript\n---\n<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<!-- more -->\n\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        ```\n        var timer;\n        function debounce (fn, delay, ...args) {\n          clearTimeout(timer)\n          timer = setTimeout(() => {\n            console.log(args)\n            fn(args)\n          }, delay)\n        }\n\n        document.onclick = function () {\n          debounce(testDebounce, 5000, 1111, 2222)\n        }\n\n        function testDebounce (...args) {\n          console.log(args)\n        }\n        ```\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        ```\n        function throttle (fn, delay) {\n          var previous = 0\n          // 使用闭包返回一个函数并且用到闭包函数外面的变量previous\n          return function () {\n            var _this = this\n            var args = arguments\n            var now = new Date()\n            if (now - previous > delay) {\n              fn.apply(_this, args)\n\n              previous = now\n            }\n          }\n        }\n\n        var testThrottleFn = throttle(testThrottle, 5000) // 节流函数\n\n        document.onclick = function (e) {\n          testThrottleFn(e, 'throttle') // 给节流函数传参\n        }\n\n        function testThrottle (e, content) {\n          console.log(e, content)\n        }\n        ```\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","slug":"JavaScript/防抖和节流","published":1,"updated":"2021-01-12T03:09:32.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jv0015vbxx9y0bb67q","content":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<a id=\"more\"></a>\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timer;</span><br><span class=\"line\">function debounce (fn, delay, ...args) &#123;</span><br><span class=\"line\">  clearTimeout(timer)</span><br><span class=\"line\">  timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(args)</span><br><span class=\"line\">    fn(args)</span><br><span class=\"line\">  &#125;, delay)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function () &#123;</span><br><span class=\"line\">  debounce(testDebounce, 5000, 1111, 2222)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testDebounce (...args) &#123;</span><br><span class=\"line\">  console.log(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle (fn, delay) &#123;</span><br><span class=\"line\">  var previous = 0</span><br><span class=\"line\">  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    var _this = this</span><br><span class=\"line\">    var args = arguments</span><br><span class=\"line\">    var now = new Date()</span><br><span class=\"line\">    if (now - previous &gt; delay) &#123;</span><br><span class=\"line\">      fn.apply(_this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var testThrottleFn = throttle(testThrottle, 5000) // 节流函数</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">  testThrottleFn(e, &apos;throttle&apos;) // 给节流函数传参</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testThrottle (e, content) &#123;</span><br><span class=\"line\">  console.log(e, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>","more":"<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timer;</span><br><span class=\"line\">function debounce (fn, delay, ...args) &#123;</span><br><span class=\"line\">  clearTimeout(timer)</span><br><span class=\"line\">  timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(args)</span><br><span class=\"line\">    fn(args)</span><br><span class=\"line\">  &#125;, delay)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function () &#123;</span><br><span class=\"line\">  debounce(testDebounce, 5000, 1111, 2222)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testDebounce (...args) &#123;</span><br><span class=\"line\">  console.log(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle (fn, delay) &#123;</span><br><span class=\"line\">  var previous = 0</span><br><span class=\"line\">  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    var _this = this</span><br><span class=\"line\">    var args = arguments</span><br><span class=\"line\">    var now = new Date()</span><br><span class=\"line\">    if (now - previous &gt; delay) &#123;</span><br><span class=\"line\">      fn.apply(_this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var testThrottleFn = throttle(testThrottle, 5000) // 节流函数</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">  testThrottleFn(e, &apos;throttle&apos;) // 给节流函数传参</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testThrottle (e, content) &#123;</span><br><span class=\"line\">  console.log(e, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>"},{"title":"手写一个简易版promise","date":"2021-01-13T15:58:42.000Z","_content":"\n<p>promise解决的问题：javascript是单线程，避免阻塞。</p>\n\n<style type=\"text/css\">\n.red {color: red;}\n.blue {color: blue;}\n</style>\n<!-- more -->\n\n<h5>解决的问题有：</h5>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<h5>运用到的设计模式：</h5>\n<p>发布订阅模式：收集依赖 -> 触发通知 -> 取出依赖执行</p>\n\n\n```\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nclass Promise {\n  constructor (executor) {\n    this.status = PENDING\n    this.value = null\n    this.reason = null\n    // 存放依赖\n    this.onRejectedCallbacks = []\n    this.onResolvedCallbacks = []\n\n    // 触发通知\n    const resolve = (value) => {\n      if (this.status === PENDING) {\n        this.status = FULFILLED\n        this.value = value\n\n        // 执行依赖\n        this.onResolvedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    // 触发通知\n    const reject = (value) => {\n      if (this.status === PENDING) {\n        this.status = REJECTED\n        this.reason = value\n\n        // 执行依赖\n        this.onRejectedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  then (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.reason)\n    }\n\n    // 收集依赖\n    if (this.status === PENDING) {\n      this.onResolvedCallbacks.push(() => {\n        onFulfilled(this.value)\n      })\n\n      this.onRejectedCallbacks.push(() => {\n        onRejected(this.reason)\n      })\n    }\n  }\n}\n```\n\n<h5>测试一下：</h5>\n```\nnew Promise((resolve, reject) => {\n  resolve('success')\n}).then((data) => {\n  console.log(data) // 'success'\n}, (err) => {\n  console.log(err)\n})\n```\n\n\n```\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  }, 100)\n}).then((data) => {\n  console.log(data) // 'success'\n}, (error) => {\n  console.log(error)\n})\n```\n\n<ol>\n  <li>\n    <p>Promise.all：按队列依次返回结果</p>\n    ```\n    const promise1 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 1000, 'promise1')\n    })\n\n    const promise2 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 2000, 'promise2')\n    })\n\n    const promise3 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 3000, 'promise3')\n    })\n\n    Promise.all([promise1, promise2, promise3]).then((result) => {\n      console.log(result) // [\"promise1\", \"promise2\", \"promise3\"]\n    }).catch((error) => {\n      console.log(error)\n    })\n    ```\n\n    <p>手写一个Promise.all</p>\n    ```\n    function all (promises) {\n      return new Promise((resolve, reject) => {\n        var result = []\n        promises.forEach((promise) => {\n          promise.then((values) => {\n            result.push(values)\n            result.length === promises.length && resolve(result)\n          }, (error) => {\n            reject(error)\n          })\n        })\n      })\n    }\n    ```\n\n    <p>测试一下：</p>\n    ```\n    all([promise1, promise2, promise3]).then((result) => {\n      console.log(result) // [\"promise1\", \"promise2\", \"promise3\"]\n    }).catch((error) => {\n      console.log(error)\n    })\n    ```\n  </li>\n  <li>\n    <p>Promise.race：采用<span class=\"red\">第一个promise的值</span>作为它的值。无论堆栈中后面的promise是resolve还是reject都会取第一个返回的结果</p>\n    <ol>\n      <li>返回结果与<span class=\"red\">Promise的结果(resolve和reject)</span>无关，仅与返回的顺序。</li>\n      <li>promise中存在<span class=\"red\">setTimeout</span>，会影响返回结果。</li>\n    </ol>\n    <div>\n      <p>手写一个Promise.race</p>\n      ```\n      function race (promises) {\n        var hasValue = false\n        var hasError = false\n        return new Promise((resolve, reject) => {\n          promises.forEach(promise => {\n            promise.then((value) => {\n              !hasValue && !hasError && resolve(value)\n              hasValue = true\n            }, (error) => {\n              !hasValue && !hasError && reject(error)\n              hasError = true\n            })\n          })\n        })\n      }\n      ```\n      <p>测试一下：</p>\n\n      ```\n      race([promise1, promise2, promise3]).then(values => {\n        console.log(values) // \"promise1\"\n      })\n      ```\n    </div>\n  </li>\n  <li>\n    <p>Promise.allSettled：返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n    ```\n      Promise.allSettled([promise1, promise2, promise3]).then((result) => {\n        result.forEach(item => console.log(item))\n        // {status: \"fulfilled\", value: \"promise1\"}\n        // {status: \"fulfilled\", value: \"promise2\"}\n        // {status: \"fulfilled\", value: \"promise3\"}\n      })\n    ```\n  </li>\n  <li>\n    <p>只要其中的一个 promise 成功，就返回那个已经成功的 promise：只要其中的一个 promise 成功，就返回那个已经成功的 promise。</p>\n    ```\n      Promise.any([promise1, promise2, promise3]).then((value) => {\n        console.log(value);\n      })\n    ```\n  </li>\n  <li>\n    <p>Promise.resolve：</p>\n    ```\n      Promise.resolve(5).then((values) => {console.log(values)}) // \"5\"\n    ```\n  </li>\n  <li>\n    <p>Promise.reject：</p>\n    ```\n      Promise.reject('error').then(()=>{}, (error)=> {console.log(error)}) // \"reject\"\n    ```\n  </li>\n</ol>\n\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>https://promisesaplus.com/</li>\n  <li>https://github.com/promises-aplus</li>\n  <li>https://www.promisejs.org/patterns/</li>\n</ol>\n","source":"_posts/JavaScript/手写一个简易版promise.md","raw":"---\ntitle: 手写一个简易版promise\ndate: 2021-01-13 23:58:42\ntags: 编程语言\ncategories: JavaScript\n---\n\n<p>promise解决的问题：javascript是单线程，避免阻塞。</p>\n\n<style type=\"text/css\">\n.red {color: red;}\n.blue {color: blue;}\n</style>\n<!-- more -->\n\n<h5>解决的问题有：</h5>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<h5>运用到的设计模式：</h5>\n<p>发布订阅模式：收集依赖 -> 触发通知 -> 取出依赖执行</p>\n\n\n```\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nclass Promise {\n  constructor (executor) {\n    this.status = PENDING\n    this.value = null\n    this.reason = null\n    // 存放依赖\n    this.onRejectedCallbacks = []\n    this.onResolvedCallbacks = []\n\n    // 触发通知\n    const resolve = (value) => {\n      if (this.status === PENDING) {\n        this.status = FULFILLED\n        this.value = value\n\n        // 执行依赖\n        this.onResolvedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    // 触发通知\n    const reject = (value) => {\n      if (this.status === PENDING) {\n        this.status = REJECTED\n        this.reason = value\n\n        // 执行依赖\n        this.onRejectedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  then (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.reason)\n    }\n\n    // 收集依赖\n    if (this.status === PENDING) {\n      this.onResolvedCallbacks.push(() => {\n        onFulfilled(this.value)\n      })\n\n      this.onRejectedCallbacks.push(() => {\n        onRejected(this.reason)\n      })\n    }\n  }\n}\n```\n\n<h5>测试一下：</h5>\n```\nnew Promise((resolve, reject) => {\n  resolve('success')\n}).then((data) => {\n  console.log(data) // 'success'\n}, (err) => {\n  console.log(err)\n})\n```\n\n\n```\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  }, 100)\n}).then((data) => {\n  console.log(data) // 'success'\n}, (error) => {\n  console.log(error)\n})\n```\n\n<ol>\n  <li>\n    <p>Promise.all：按队列依次返回结果</p>\n    ```\n    const promise1 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 1000, 'promise1')\n    })\n\n    const promise2 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 2000, 'promise2')\n    })\n\n    const promise3 = new Promise((resolve, reject) => {\n      setTimeout(resolve, 3000, 'promise3')\n    })\n\n    Promise.all([promise1, promise2, promise3]).then((result) => {\n      console.log(result) // [\"promise1\", \"promise2\", \"promise3\"]\n    }).catch((error) => {\n      console.log(error)\n    })\n    ```\n\n    <p>手写一个Promise.all</p>\n    ```\n    function all (promises) {\n      return new Promise((resolve, reject) => {\n        var result = []\n        promises.forEach((promise) => {\n          promise.then((values) => {\n            result.push(values)\n            result.length === promises.length && resolve(result)\n          }, (error) => {\n            reject(error)\n          })\n        })\n      })\n    }\n    ```\n\n    <p>测试一下：</p>\n    ```\n    all([promise1, promise2, promise3]).then((result) => {\n      console.log(result) // [\"promise1\", \"promise2\", \"promise3\"]\n    }).catch((error) => {\n      console.log(error)\n    })\n    ```\n  </li>\n  <li>\n    <p>Promise.race：采用<span class=\"red\">第一个promise的值</span>作为它的值。无论堆栈中后面的promise是resolve还是reject都会取第一个返回的结果</p>\n    <ol>\n      <li>返回结果与<span class=\"red\">Promise的结果(resolve和reject)</span>无关，仅与返回的顺序。</li>\n      <li>promise中存在<span class=\"red\">setTimeout</span>，会影响返回结果。</li>\n    </ol>\n    <div>\n      <p>手写一个Promise.race</p>\n      ```\n      function race (promises) {\n        var hasValue = false\n        var hasError = false\n        return new Promise((resolve, reject) => {\n          promises.forEach(promise => {\n            promise.then((value) => {\n              !hasValue && !hasError && resolve(value)\n              hasValue = true\n            }, (error) => {\n              !hasValue && !hasError && reject(error)\n              hasError = true\n            })\n          })\n        })\n      }\n      ```\n      <p>测试一下：</p>\n\n      ```\n      race([promise1, promise2, promise3]).then(values => {\n        console.log(values) // \"promise1\"\n      })\n      ```\n    </div>\n  </li>\n  <li>\n    <p>Promise.allSettled：返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n    ```\n      Promise.allSettled([promise1, promise2, promise3]).then((result) => {\n        result.forEach(item => console.log(item))\n        // {status: \"fulfilled\", value: \"promise1\"}\n        // {status: \"fulfilled\", value: \"promise2\"}\n        // {status: \"fulfilled\", value: \"promise3\"}\n      })\n    ```\n  </li>\n  <li>\n    <p>只要其中的一个 promise 成功，就返回那个已经成功的 promise：只要其中的一个 promise 成功，就返回那个已经成功的 promise。</p>\n    ```\n      Promise.any([promise1, promise2, promise3]).then((value) => {\n        console.log(value);\n      })\n    ```\n  </li>\n  <li>\n    <p>Promise.resolve：</p>\n    ```\n      Promise.resolve(5).then((values) => {console.log(values)}) // \"5\"\n    ```\n  </li>\n  <li>\n    <p>Promise.reject：</p>\n    ```\n      Promise.reject('error').then(()=>{}, (error)=> {console.log(error)}) // \"reject\"\n    ```\n  </li>\n</ol>\n\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>https://promisesaplus.com/</li>\n  <li>https://github.com/promises-aplus</li>\n  <li>https://www.promisejs.org/patterns/</li>\n</ol>\n","slug":"JavaScript/手写一个简易版promise","published":1,"updated":"2021-01-23T14:44:06.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jw0018vbxxtl2x6c99","content":"<p>promise解决的问题：javascript是单线程，避免阻塞。</p>\n\n<p><style type=\"text/css\">\n.red {color: red;}\n.blue {color: blue;}\n</style>\n<a id=\"more\"></a></p>\n<p></p><h5>解决的问题有：</h5><p></p>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<p></p><h5>运用到的设计模式：</h5><p></p>\n<p>发布订阅模式：收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</p>\n\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PENDING = &apos;PENDING&apos;</span><br><span class=\"line\">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class=\"line\">const REJECTED = &apos;REJECTED&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">  constructor (executor) &#123;</span><br><span class=\"line\">    this.status = PENDING</span><br><span class=\"line\">    this.value = null</span><br><span class=\"line\">    this.reason = null</span><br><span class=\"line\">    // 存放依赖</span><br><span class=\"line\">    this.onRejectedCallbacks = []</span><br><span class=\"line\">    this.onResolvedCallbacks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const resolve = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = FULFILLED</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onResolvedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const reject = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = REJECTED</span><br><span class=\"line\">        this.reason = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onRejectedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      executor(resolve, reject)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">      onFulfilled(this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (this.status === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(this.reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集依赖</span><br><span class=\"line\">    if (this.status === PENDING) &#123;</span><br><span class=\"line\">      this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onFulfilled(this.value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onRejected(this.reason)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p></p><h5>测试一下：</h5>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;success&apos;)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;success&apos;)</span><br><span class=\"line\">  &#125;, 100)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n  <li>\n    <p>Promise.all：按队列依次返回结果</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 1000, &apos;promise1&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 2000, &apos;promise2&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 3000, &apos;promise3&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    <p>手写一个Promise.all</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function all (promises) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var result = []</span><br><span class=\"line\">    promises.forEach((promise) =&gt; &#123;</span><br><span class=\"line\">      promise.then((values) =&gt; &#123;</span><br><span class=\"line\">        result.push(values)</span><br><span class=\"line\">        result.length === promises.length &amp;&amp; resolve(result)</span><br><span class=\"line\">      &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    <p>测试一下：</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.race：采用<span class=\"red\">第一个promise的值</span>作为它的值。无论堆栈中后面的promise是resolve还是reject都会取第一个返回的结果</p>\n    <ol>\n      <li>返回结果与<span class=\"red\">Promise的结果(resolve和reject)</span>无关，仅与返回的顺序。</li>\n      <li>promise中存在<span class=\"red\">setTimeout</span>，会影响返回结果。</li>\n    </ol>\n    <div>\n      <p>手写一个Promise.race</p>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function race (promises) &#123;</span><br><span class=\"line\">  var hasValue = false</span><br><span class=\"line\">  var hasError = false</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    promises.forEach(promise =&gt; &#123;</span><br><span class=\"line\">      promise.then((value) =&gt; &#123;</span><br><span class=\"line\">        !hasValue &amp;&amp; !hasError &amp;&amp; resolve(value)</span><br><span class=\"line\">        hasValue = true</span><br><span class=\"line\">      &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">        !hasValue &amp;&amp; !hasError &amp;&amp; reject(error)</span><br><span class=\"line\">        hasError = true</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      <p>测试一下：</p>\n\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">race([promise1, promise2, promise3]).then(values =&gt; &#123;</span><br><span class=\"line\">  console.log(values) // &quot;promise1&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>\n    <p>Promise.allSettled：返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.allSettled([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  result.forEach(item =&gt; console.log(item))</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise1&quot;&#125;</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise2&quot;&#125;</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise3&quot;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>只要其中的一个 promise 成功，就返回那个已经成功的 promise：只要其中的一个 promise 成功，就返回那个已经成功的 promise。</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.any([promise1, promise2, promise3]).then((value) =&gt; &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.resolve：</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(5).then((values) =&gt; &#123;console.log(values)&#125;) // &quot;5&quot;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.reject：</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.reject(&apos;error&apos;).then(()=&gt;&#123;&#125;, (error)=&gt; &#123;console.log(error)&#125;) // &quot;reject&quot;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">https://promisesaplus.com/</a></li>\n  <li><a href=\"https://github.com/promises-aplus\" target=\"_blank\" rel=\"noopener\">https://github.com/promises-aplus</a></li>\n  <li><a href=\"https://www.promisejs.org/patterns/\" target=\"_blank\" rel=\"noopener\">https://www.promisejs.org/patterns/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>promise解决的问题：javascript是单线程，避免阻塞。</p>\n\n<p><style type=\"text/css\">\n.red {color: red;}\n.blue {color: blue;}\n</style></p>","more":"</p>\n<p></p><h5>解决的问题有：</h5><p></p>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<p></p><h5>运用到的设计模式：</h5><p></p>\n<p>发布订阅模式：收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</p>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PENDING = &apos;PENDING&apos;</span><br><span class=\"line\">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class=\"line\">const REJECTED = &apos;REJECTED&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">  constructor (executor) &#123;</span><br><span class=\"line\">    this.status = PENDING</span><br><span class=\"line\">    this.value = null</span><br><span class=\"line\">    this.reason = null</span><br><span class=\"line\">    // 存放依赖</span><br><span class=\"line\">    this.onRejectedCallbacks = []</span><br><span class=\"line\">    this.onResolvedCallbacks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const resolve = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = FULFILLED</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onResolvedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const reject = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = REJECTED</span><br><span class=\"line\">        this.reason = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onRejectedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      executor(resolve, reject)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">      onFulfilled(this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (this.status === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(this.reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集依赖</span><br><span class=\"line\">    if (this.status === PENDING) &#123;</span><br><span class=\"line\">      this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onFulfilled(this.value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onRejected(this.reason)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p></p><h5>测试一下：</h5>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;success&apos;)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;success&apos;)</span><br><span class=\"line\">  &#125;, 100)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ol>\n  <li>\n    <p>Promise.all：按队列依次返回结果</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 1000, &apos;promise1&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 2000, &apos;promise2&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">const promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 3000, &apos;promise3&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    <p>手写一个Promise.all</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function all (promises) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var result = []</span><br><span class=\"line\">    promises.forEach((promise) =&gt; &#123;</span><br><span class=\"line\">      promise.then((values) =&gt; &#123;</span><br><span class=\"line\">        result.push(values)</span><br><span class=\"line\">        result.length === promises.length &amp;&amp; resolve(result)</span><br><span class=\"line\">      &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    <p>测试一下：</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]</span><br><span class=\"line\">&#125;).catch((error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.race：采用<span class=\"red\">第一个promise的值</span>作为它的值。无论堆栈中后面的promise是resolve还是reject都会取第一个返回的结果</p>\n    <ol>\n      <li>返回结果与<span class=\"red\">Promise的结果(resolve和reject)</span>无关，仅与返回的顺序。</li>\n      <li>promise中存在<span class=\"red\">setTimeout</span>，会影响返回结果。</li>\n    </ol>\n    <div>\n      <p>手写一个Promise.race</p>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function race (promises) &#123;</span><br><span class=\"line\">  var hasValue = false</span><br><span class=\"line\">  var hasError = false</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    promises.forEach(promise =&gt; &#123;</span><br><span class=\"line\">      promise.then((value) =&gt; &#123;</span><br><span class=\"line\">        !hasValue &amp;&amp; !hasError &amp;&amp; resolve(value)</span><br><span class=\"line\">        hasValue = true</span><br><span class=\"line\">      &#125;, (error) =&gt; &#123;</span><br><span class=\"line\">        !hasValue &amp;&amp; !hasError &amp;&amp; reject(error)</span><br><span class=\"line\">        hasError = true</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      <p>测试一下：</p>\n\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">race([promise1, promise2, promise3]).then(values =&gt; &#123;</span><br><span class=\"line\">  console.log(values) // &quot;promise1&quot;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>\n    <p>Promise.allSettled：返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.allSettled([promise1, promise2, promise3]).then((result) =&gt; &#123;</span><br><span class=\"line\">  result.forEach(item =&gt; console.log(item))</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise1&quot;&#125;</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise2&quot;&#125;</span><br><span class=\"line\">  // &#123;status: &quot;fulfilled&quot;, value: &quot;promise3&quot;&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>只要其中的一个 promise 成功，就返回那个已经成功的 promise：只要其中的一个 promise 成功，就返回那个已经成功的 promise。</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.any([promise1, promise2, promise3]).then((value) =&gt; &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.resolve：</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve(5).then((values) =&gt; &#123;console.log(values)&#125;) // &quot;5&quot;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>Promise.reject：</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.reject(&apos;error&apos;).then(()=&gt;&#123;&#125;, (error)=&gt; &#123;console.log(error)&#125;) // &quot;reject&quot;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://promisesaplus.com/\" target=\"_blank\" rel=\"noopener\">https://promisesaplus.com/</a></li>\n  <li><a href=\"https://github.com/promises-aplus\" target=\"_blank\" rel=\"noopener\">https://github.com/promises-aplus</a></li>\n  <li><a href=\"https://www.promisejs.org/patterns/\" target=\"_blank\" rel=\"noopener\">https://www.promisejs.org/patterns/</a></li>\n</ol>"},{"title":"IE及移动端兼容性&其他问题汇总","date":"2019-03-06T15:30:28.000Z","toc":true,"_content":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<!-- more -->\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用\"canvas\"，ie8及低版本用\"shape形状\"</li>\n  <li>a标签兼容性问题：\n    ```\n    <a href=\"javascript:void(0);\" target=\"_blank\"></a>\n    ```\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：https://www.cnblogs.com/august-8/p/4537685.html</div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    ```\n    position: static;\n    ```\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ''+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    ```\n    str = str.replace(/\\s+/g,\"\");\n    ```\n    </p>\n    <p>去除两头空格:\n    ```\n    str = str.replace(/^\\s+|\\s+$/g,\"\");\n    ```\n    </p>\n    <p>去除左空格：\n    ```\n    str = str.replace( /^\\s/, '');\n    ```\n    </p>\n    <p>去除右空格：\n    ```\n    str = str.replace(/(\\s$)/g, \"\");\n    ```\n    </p>\n  </li>\n  <li>页面种cookie：\n    ```\n     document.cookie = 'userId=123;test=456'\n    ```\n  </li>\n  <li>for循环性能比对：\n    <p>for>forEach>for...in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      ```\n      $(\"#input1\").bind(\"input propertychange\",function(event){\n        console.log($(\"#input1\").val())\n      });\n      ```\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for...in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=\"_blank\"打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li>http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","source":"_posts/css/IE及移动端兼容性问题&其他汇总.md","raw":"---\ntitle: IE及移动端兼容性&其他问题汇总\ndate: 2019-03-06 23:30:28\ntoc: true\ncategories: css\ntags:\n---\n<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<!-- more -->\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用\"canvas\"，ie8及低版本用\"shape形状\"</li>\n  <li>a标签兼容性问题：\n    ```\n    <a href=\"javascript:void(0);\" target=\"_blank\"></a>\n    ```\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：https://www.cnblogs.com/august-8/p/4537685.html</div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    ```\n    position: static;\n    ```\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ''+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    ```\n    str = str.replace(/\\s+/g,\"\");\n    ```\n    </p>\n    <p>去除两头空格:\n    ```\n    str = str.replace(/^\\s+|\\s+$/g,\"\");\n    ```\n    </p>\n    <p>去除左空格：\n    ```\n    str = str.replace( /^\\s/, '');\n    ```\n    </p>\n    <p>去除右空格：\n    ```\n    str = str.replace(/(\\s$)/g, \"\");\n    ```\n    </p>\n  </li>\n  <li>页面种cookie：\n    ```\n     document.cookie = 'userId=123;test=456'\n    ```\n  </li>\n  <li>for循环性能比对：\n    <p>for>forEach>for...in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      ```\n      $(\"#input1\").bind(\"input propertychange\",function(event){\n        console.log($(\"#input1\").val())\n      });\n      ```\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for...in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=\"_blank\"打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li>http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","slug":"css/IE及移动端兼容性问题&其他汇总","published":1,"updated":"2021-01-13T14:29:58.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jx001avbxxyyzp2y7z","content":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<a id=\"more\"></a>\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用”canvas”，ie8及低版本用”shape形状”</li>\n  <li>a标签兼容性问题：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:void(0);&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：<a href=\"https://www.cnblogs.com/august-8/p/4537685.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/august-8/p/4537685.html</a></div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: static;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ‘’+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/\\s+/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除两头空格:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/^\\s+|\\s+$/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除左空格：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace( /^\\s/, &apos;&apos;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除右空格：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/(\\s$)/g, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n  </li>\n  <li>页面种cookie：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie = &apos;userId=123;test=456&apos;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>for循环性能比对：\n    <p>for&gt;forEach&gt;for…in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event)&#123;</span><br><span class=\"line\">  console.log($(&quot;#input1&quot;).val())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for…in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=”_blank”打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","site":{"data":{}},"excerpt":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>","more":"<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用”canvas”，ie8及低版本用”shape形状”</li>\n  <li>a标签兼容性问题：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:void(0);&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：<a href=\"https://www.cnblogs.com/august-8/p/4537685.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/august-8/p/4537685.html</a></div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: static;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ‘’+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/\\s+/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除两头空格:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/^\\s+|\\s+$/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除左空格：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace( /^\\s/, &apos;&apos;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除右空格：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/(\\s$)/g, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n  </li>\n  <li>页面种cookie：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie = &apos;userId=123;test=456&apos;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>for循环性能比对：\n    <p>for&gt;forEach&gt;for…in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event)&#123;</span><br><span class=\"line\">  console.log($(&quot;#input1&quot;).val())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for…in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=”_blank”打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"巨人的陨落－观感","date":"2019-10-10T14:19:52.000Z","thumbnail":"img/cactus.jpg","_content":"\n<p style=\"text-indent:30px\">《巨人的陨落》与《世界的凛冬》,《永恒的边缘》称为世纪三部曲，巨人的陨落分为三部，断断续续读了第一部的部分章节。整册书浩瀚壮阔，若整书看完写观感，恐有遗漏，故采用边看边写的方式记录这点点滴滴的感悟。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">故事是以第三人称描述的，章节紧凑而跌宕起伏。小男孩比利在他十三岁生日那天，开始了他的职业生涯，成为了一名学徒矿工。那天他也要第一次下井工作来贴补家用，下井并不是件轻松的事情，镇子里二十五岁的大卫第一天就在井下哭了鼻子落了个\"戴哭宝\"的外号。比利希望自己下井时能尽可能像个男子汉一样，不要出丑。</p>\n\n<p style=\"text-indent:30px\">比利的父亲一名矿工代理人，受雇于英国最强大的工人同盟，也可理解为工会，为工人向资本家争取各项权益，维护工人的利益。矿上的人都认识他的父亲，对他父亲也是有人拥护有人憎恨。矿工负责人显然站在了他父亲的对立面。</p>\n\n<p style=\"text-indent:30px\">幼小的比利此时已站在了井口等待下井了，一同的还有与他年龄相当的另一个小男孩，被放在了升降吊笼里。在\"砰\"的一声爆响后，比利随吊笼的下降害怕到大声尖叫，感觉十分强烈，他就要憋不住眼泪了。边上的小男孩更是一脸刷白。吊笼渐缓，慢慢停了下来，比利颤抖着走了出来。普莱斯负责将他们带到工区，走过马厩时，放下了另一个小男孩，他们继续向另一个更旧、更狭窄的通道走去，在检修口处放下了比利，吩咐比利将垃圾铲到道车里，普莱斯还将自己的矿灯换了比利的矿灯走掉了。</p>\n\n<p style=\"text-indent:30px\">年幼的比利将矿灯放在高处开始干活，殊不知没过会矿灯灭掉了，四周漆黑一片。此时的比利惊恐而害怕，万般绝望下想到了妈妈说的在他出门前跟他说的耶稣与你同在，无奈下比利唱起了颂歌，同时按惯性将垃圾铲向道车。心想普莱斯会在吃中饭时过来找他。但事实往往更残酷，吃中饭时普莱斯都没来找他，他在漆黑中摸到了妈妈准备的便当，将三明治送入口中周围老鼠一遍遍的顺着他的胳膊爬到他的手跟前，他只能加快吃掉。赶忙吃完中饭后，比利又一次拿起了铁锹唱起了颂歌，将垃圾一次次的铲向了道车。</p>\n\n<p style=\"text-indent:30px\">又过了一段时间，普莱斯来找他了。但同时也被眼前的一幕惊呆了，比利有力的挥舞着铁锹，一面坚定高昂的唱着颂歌。显然，普莱斯因为比利父亲的缘故故意为难比利，而比利却并没有被困难吓到，而是战胜了内心的恐惧，寻求了生的希望。从而也成就了更强大的比利，出井后，比利有了个新绰号，大家叫他\"耶稣的比利\"。</p>\n\n<p style=\"text-indent:30px\">绝望中寻找希望人生终究辉煌！</p>\n\n<p style=\"text-indent:30px\">未完待续，书中类似的故事穿插着还有许多，有时间会再整理一些。作者总是在尽可能的形成强烈的对比，来展现出不同人物性格在不同境况表现出来的不同的特征。谨以此篇献给每个热烈活着的鲜活个体，因为你们生命而更绚烂！</p>","source":"_posts/书虫/巨人的陨落.md","raw":"---\ntitle: 巨人的陨落－观感\ndate: 2019-10-10 22:19:52\ncategories: 书虫\ntags: 书籍\nthumbnail: img/cactus.jpg\n---\n\n<p style=\"text-indent:30px\">《巨人的陨落》与《世界的凛冬》,《永恒的边缘》称为世纪三部曲，巨人的陨落分为三部，断断续续读了第一部的部分章节。整册书浩瀚壮阔，若整书看完写观感，恐有遗漏，故采用边看边写的方式记录这点点滴滴的感悟。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">故事是以第三人称描述的，章节紧凑而跌宕起伏。小男孩比利在他十三岁生日那天，开始了他的职业生涯，成为了一名学徒矿工。那天他也要第一次下井工作来贴补家用，下井并不是件轻松的事情，镇子里二十五岁的大卫第一天就在井下哭了鼻子落了个\"戴哭宝\"的外号。比利希望自己下井时能尽可能像个男子汉一样，不要出丑。</p>\n\n<p style=\"text-indent:30px\">比利的父亲一名矿工代理人，受雇于英国最强大的工人同盟，也可理解为工会，为工人向资本家争取各项权益，维护工人的利益。矿上的人都认识他的父亲，对他父亲也是有人拥护有人憎恨。矿工负责人显然站在了他父亲的对立面。</p>\n\n<p style=\"text-indent:30px\">幼小的比利此时已站在了井口等待下井了，一同的还有与他年龄相当的另一个小男孩，被放在了升降吊笼里。在\"砰\"的一声爆响后，比利随吊笼的下降害怕到大声尖叫，感觉十分强烈，他就要憋不住眼泪了。边上的小男孩更是一脸刷白。吊笼渐缓，慢慢停了下来，比利颤抖着走了出来。普莱斯负责将他们带到工区，走过马厩时，放下了另一个小男孩，他们继续向另一个更旧、更狭窄的通道走去，在检修口处放下了比利，吩咐比利将垃圾铲到道车里，普莱斯还将自己的矿灯换了比利的矿灯走掉了。</p>\n\n<p style=\"text-indent:30px\">年幼的比利将矿灯放在高处开始干活，殊不知没过会矿灯灭掉了，四周漆黑一片。此时的比利惊恐而害怕，万般绝望下想到了妈妈说的在他出门前跟他说的耶稣与你同在，无奈下比利唱起了颂歌，同时按惯性将垃圾铲向道车。心想普莱斯会在吃中饭时过来找他。但事实往往更残酷，吃中饭时普莱斯都没来找他，他在漆黑中摸到了妈妈准备的便当，将三明治送入口中周围老鼠一遍遍的顺着他的胳膊爬到他的手跟前，他只能加快吃掉。赶忙吃完中饭后，比利又一次拿起了铁锹唱起了颂歌，将垃圾一次次的铲向了道车。</p>\n\n<p style=\"text-indent:30px\">又过了一段时间，普莱斯来找他了。但同时也被眼前的一幕惊呆了，比利有力的挥舞着铁锹，一面坚定高昂的唱着颂歌。显然，普莱斯因为比利父亲的缘故故意为难比利，而比利却并没有被困难吓到，而是战胜了内心的恐惧，寻求了生的希望。从而也成就了更强大的比利，出井后，比利有了个新绰号，大家叫他\"耶稣的比利\"。</p>\n\n<p style=\"text-indent:30px\">绝望中寻找希望人生终究辉煌！</p>\n\n<p style=\"text-indent:30px\">未完待续，书中类似的故事穿插着还有许多，有时间会再整理一些。作者总是在尽可能的形成强烈的对比，来展现出不同人物性格在不同境况表现出来的不同的特征。谨以此篇献给每个热烈活着的鲜活个体，因为你们生命而更绚烂！</p>","slug":"书虫/巨人的陨落","published":1,"updated":"2021-01-18T08:50:28.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jy001dvbxxmgvoy6jx","content":"<p style=\"text-indent:30px\">《巨人的陨落》与《世界的凛冬》,《永恒的边缘》称为世纪三部曲，巨人的陨落分为三部，断断续续读了第一部的部分章节。整册书浩瀚壮阔，若整书看完写观感，恐有遗漏，故采用边看边写的方式记录这点点滴滴的感悟。</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">故事是以第三人称描述的，章节紧凑而跌宕起伏。小男孩比利在他十三岁生日那天，开始了他的职业生涯，成为了一名学徒矿工。那天他也要第一次下井工作来贴补家用，下井并不是件轻松的事情，镇子里二十五岁的大卫第一天就在井下哭了鼻子落了个”戴哭宝”的外号。比利希望自己下井时能尽可能像个男子汉一样，不要出丑。</p>\n\n<p style=\"text-indent:30px\">比利的父亲一名矿工代理人，受雇于英国最强大的工人同盟，也可理解为工会，为工人向资本家争取各项权益，维护工人的利益。矿上的人都认识他的父亲，对他父亲也是有人拥护有人憎恨。矿工负责人显然站在了他父亲的对立面。</p>\n\n<p style=\"text-indent:30px\">幼小的比利此时已站在了井口等待下井了，一同的还有与他年龄相当的另一个小男孩，被放在了升降吊笼里。在”砰”的一声爆响后，比利随吊笼的下降害怕到大声尖叫，感觉十分强烈，他就要憋不住眼泪了。边上的小男孩更是一脸刷白。吊笼渐缓，慢慢停了下来，比利颤抖着走了出来。普莱斯负责将他们带到工区，走过马厩时，放下了另一个小男孩，他们继续向另一个更旧、更狭窄的通道走去，在检修口处放下了比利，吩咐比利将垃圾铲到道车里，普莱斯还将自己的矿灯换了比利的矿灯走掉了。</p>\n\n<p style=\"text-indent:30px\">年幼的比利将矿灯放在高处开始干活，殊不知没过会矿灯灭掉了，四周漆黑一片。此时的比利惊恐而害怕，万般绝望下想到了妈妈说的在他出门前跟他说的耶稣与你同在，无奈下比利唱起了颂歌，同时按惯性将垃圾铲向道车。心想普莱斯会在吃中饭时过来找他。但事实往往更残酷，吃中饭时普莱斯都没来找他，他在漆黑中摸到了妈妈准备的便当，将三明治送入口中周围老鼠一遍遍的顺着他的胳膊爬到他的手跟前，他只能加快吃掉。赶忙吃完中饭后，比利又一次拿起了铁锹唱起了颂歌，将垃圾一次次的铲向了道车。</p>\n\n<p style=\"text-indent:30px\">又过了一段时间，普莱斯来找他了。但同时也被眼前的一幕惊呆了，比利有力的挥舞着铁锹，一面坚定高昂的唱着颂歌。显然，普莱斯因为比利父亲的缘故故意为难比利，而比利却并没有被困难吓到，而是战胜了内心的恐惧，寻求了生的希望。从而也成就了更强大的比利，出井后，比利有了个新绰号，大家叫他”耶稣的比利”。</p>\n\n<p style=\"text-indent:30px\">绝望中寻找希望人生终究辉煌！</p>\n\n<p style=\"text-indent:30px\">未完待续，书中类似的故事穿插着还有许多，有时间会再整理一些。作者总是在尽可能的形成强烈的对比，来展现出不同人物性格在不同境况表现出来的不同的特征。谨以此篇献给每个热烈活着的鲜活个体，因为你们生命而更绚烂！</p>","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">《巨人的陨落》与《世界的凛冬》,《永恒的边缘》称为世纪三部曲，巨人的陨落分为三部，断断续续读了第一部的部分章节。整册书浩瀚壮阔，若整书看完写观感，恐有遗漏，故采用边看边写的方式记录这点点滴滴的感悟。</p>","more":"<p style=\"text-indent:30px\">故事是以第三人称描述的，章节紧凑而跌宕起伏。小男孩比利在他十三岁生日那天，开始了他的职业生涯，成为了一名学徒矿工。那天他也要第一次下井工作来贴补家用，下井并不是件轻松的事情，镇子里二十五岁的大卫第一天就在井下哭了鼻子落了个”戴哭宝”的外号。比利希望自己下井时能尽可能像个男子汉一样，不要出丑。</p>\n\n<p style=\"text-indent:30px\">比利的父亲一名矿工代理人，受雇于英国最强大的工人同盟，也可理解为工会，为工人向资本家争取各项权益，维护工人的利益。矿上的人都认识他的父亲，对他父亲也是有人拥护有人憎恨。矿工负责人显然站在了他父亲的对立面。</p>\n\n<p style=\"text-indent:30px\">幼小的比利此时已站在了井口等待下井了，一同的还有与他年龄相当的另一个小男孩，被放在了升降吊笼里。在”砰”的一声爆响后，比利随吊笼的下降害怕到大声尖叫，感觉十分强烈，他就要憋不住眼泪了。边上的小男孩更是一脸刷白。吊笼渐缓，慢慢停了下来，比利颤抖着走了出来。普莱斯负责将他们带到工区，走过马厩时，放下了另一个小男孩，他们继续向另一个更旧、更狭窄的通道走去，在检修口处放下了比利，吩咐比利将垃圾铲到道车里，普莱斯还将自己的矿灯换了比利的矿灯走掉了。</p>\n\n<p style=\"text-indent:30px\">年幼的比利将矿灯放在高处开始干活，殊不知没过会矿灯灭掉了，四周漆黑一片。此时的比利惊恐而害怕，万般绝望下想到了妈妈说的在他出门前跟他说的耶稣与你同在，无奈下比利唱起了颂歌，同时按惯性将垃圾铲向道车。心想普莱斯会在吃中饭时过来找他。但事实往往更残酷，吃中饭时普莱斯都没来找他，他在漆黑中摸到了妈妈准备的便当，将三明治送入口中周围老鼠一遍遍的顺着他的胳膊爬到他的手跟前，他只能加快吃掉。赶忙吃完中饭后，比利又一次拿起了铁锹唱起了颂歌，将垃圾一次次的铲向了道车。</p>\n\n<p style=\"text-indent:30px\">又过了一段时间，普莱斯来找他了。但同时也被眼前的一幕惊呆了，比利有力的挥舞着铁锹，一面坚定高昂的唱着颂歌。显然，普莱斯因为比利父亲的缘故故意为难比利，而比利却并没有被困难吓到，而是战胜了内心的恐惧，寻求了生的希望。从而也成就了更强大的比利，出井后，比利有了个新绰号，大家叫他”耶稣的比利”。</p>\n\n<p style=\"text-indent:30px\">绝望中寻找希望人生终究辉煌！</p>\n\n<p style=\"text-indent:30px\">未完待续，书中类似的故事穿插着还有许多，有时间会再整理一些。作者总是在尽可能的形成强烈的对比，来展现出不同人物性格在不同境况表现出来的不同的特征。谨以此篇献给每个热烈活着的鲜活个体，因为你们生命而更绚烂！</p>"},{"title":"偷影子的人－观感","date":"2019-05-11T14:32:25.000Z","thumbnail":"img/shadow.jpeg","_content":"\n<p style=\"text-indent:30px\">空闲时间书为伴，每本书如一位好友般娓娓道来。叙述着一段段不同的人生。有平淡的小美好，有跌宕起伏的人生磨难，有历史长河的波澜壮阔，也有生活中平淡无奇的琐事。故将美好的事情记录下来，无论怎样，每一天都值得好好的对待！</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">书作者Marc Levy，对作者并不熟悉，暂略。</p>\n\n<p style=\"text-indent:30px\">故事是以一个小男孩的视角去描述的。目前看了二分之一。之所以止住不看，是因为对另一句描述影子的话深感恐惧。一句话有时候可以给人力量，同时也足以让人深感恐惧，所以暂写二分之一的观感。想描述一下光明面的影子。</p>\n\n<p style=\"text-indent:30px\">书中瘦弱的小男孩，拥有“超能力”，能够“偷别人的影子”，能透过影子看到他人，听见人们心中不愿意说出口的秘密。他心中的善良，让他成为需要帮助者的心灵伙伴，为每个“偷来影子的人”找到点亮生命的小小光芒。</p>\n\n<p style=\"text-indent:30px\">故事的开始，小男孩爸爸和妈妈的感情不和，让小男孩家庭破碎，小男孩和妈妈相依生活。小男孩对父亲的爱并没有减少，将思念深藏心底。</p>\n\n<p style=\"text-indent:30px\">伊凡是小男孩的好朋友，也是学校的警卫，在煤气炉爆炸时，小男孩在他人的帮助下救出在煤气炉中的伊凡，救出的伊凡十分痛苦，由于妈妈留给他的最后一封信和照片还在煤气炉中，可能会被烧毁，而小男孩透过那悲伤的影子，知道伊凡从出生就没见到过自己的妈妈。他妈妈在生他时就难产去世了（这块有点老套剧情的意思，忽略）。伊凡瞬间眼角湿润，小男孩回去后找自己的妈妈写了封信，请自己妈妈写出他还没出生时，她想跟他说得话。小男孩小心翼翼的将信藏在了伊凡的煤气炉的箱子底下，足足等了一周，伊凡来找他。伊凡辞职了，来跟他告别，这封信让伊凡意识到了他一直被童年禁锢，他要追寻他美好的人生了。</p>\n\n<p style=\"text-indent:30px\">这段是我目前为止最喜欢的一个情节，心思巧妙动人心弦。其它情节如吕克、伊利沙白、克雷儿相比会稍加逊色。善良的人很多，能够巧妙的让人舒服的善良很难得。而这份善良有可能会改变一个人的一生。</p>\n\n<p style=\"text-indent:30px\">文采不好，将这些文字埋在角落。如有幸您读到了，感恩您花时间阅读。</p>\n\n<p style=\"text-indent:30px\">现在读书的感觉很好，有了部分人生阅历之后，一些浅显的东西也更能看得更深刻，更了解明白作者想表达内容，是件美好的事情。</p>\n","source":"_posts/书虫/偷影子的人.md","raw":"---\ntitle: 偷影子的人－观感\ndate: 2019-05-11 22:32:25\ncategories: 书虫\ntags: 书籍\nthumbnail: img/shadow.jpeg\n---\n\n<p style=\"text-indent:30px\">空闲时间书为伴，每本书如一位好友般娓娓道来。叙述着一段段不同的人生。有平淡的小美好，有跌宕起伏的人生磨难，有历史长河的波澜壮阔，也有生活中平淡无奇的琐事。故将美好的事情记录下来，无论怎样，每一天都值得好好的对待！</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">书作者Marc Levy，对作者并不熟悉，暂略。</p>\n\n<p style=\"text-indent:30px\">故事是以一个小男孩的视角去描述的。目前看了二分之一。之所以止住不看，是因为对另一句描述影子的话深感恐惧。一句话有时候可以给人力量，同时也足以让人深感恐惧，所以暂写二分之一的观感。想描述一下光明面的影子。</p>\n\n<p style=\"text-indent:30px\">书中瘦弱的小男孩，拥有“超能力”，能够“偷别人的影子”，能透过影子看到他人，听见人们心中不愿意说出口的秘密。他心中的善良，让他成为需要帮助者的心灵伙伴，为每个“偷来影子的人”找到点亮生命的小小光芒。</p>\n\n<p style=\"text-indent:30px\">故事的开始，小男孩爸爸和妈妈的感情不和，让小男孩家庭破碎，小男孩和妈妈相依生活。小男孩对父亲的爱并没有减少，将思念深藏心底。</p>\n\n<p style=\"text-indent:30px\">伊凡是小男孩的好朋友，也是学校的警卫，在煤气炉爆炸时，小男孩在他人的帮助下救出在煤气炉中的伊凡，救出的伊凡十分痛苦，由于妈妈留给他的最后一封信和照片还在煤气炉中，可能会被烧毁，而小男孩透过那悲伤的影子，知道伊凡从出生就没见到过自己的妈妈。他妈妈在生他时就难产去世了（这块有点老套剧情的意思，忽略）。伊凡瞬间眼角湿润，小男孩回去后找自己的妈妈写了封信，请自己妈妈写出他还没出生时，她想跟他说得话。小男孩小心翼翼的将信藏在了伊凡的煤气炉的箱子底下，足足等了一周，伊凡来找他。伊凡辞职了，来跟他告别，这封信让伊凡意识到了他一直被童年禁锢，他要追寻他美好的人生了。</p>\n\n<p style=\"text-indent:30px\">这段是我目前为止最喜欢的一个情节，心思巧妙动人心弦。其它情节如吕克、伊利沙白、克雷儿相比会稍加逊色。善良的人很多，能够巧妙的让人舒服的善良很难得。而这份善良有可能会改变一个人的一生。</p>\n\n<p style=\"text-indent:30px\">文采不好，将这些文字埋在角落。如有幸您读到了，感恩您花时间阅读。</p>\n\n<p style=\"text-indent:30px\">现在读书的感觉很好，有了部分人生阅历之后，一些浅显的东西也更能看得更深刻，更了解明白作者想表达内容，是件美好的事情。</p>\n","slug":"书虫/偷影子的人","published":1,"updated":"2021-01-18T08:50:25.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jy001hvbxxjrpe0c8p","content":"<p style=\"text-indent:30px\">空闲时间书为伴，每本书如一位好友般娓娓道来。叙述着一段段不同的人生。有平淡的小美好，有跌宕起伏的人生磨难，有历史长河的波澜壮阔，也有生活中平淡无奇的琐事。故将美好的事情记录下来，无论怎样，每一天都值得好好的对待！</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">书作者Marc Levy，对作者并不熟悉，暂略。</p>\n\n<p style=\"text-indent:30px\">故事是以一个小男孩的视角去描述的。目前看了二分之一。之所以止住不看，是因为对另一句描述影子的话深感恐惧。一句话有时候可以给人力量，同时也足以让人深感恐惧，所以暂写二分之一的观感。想描述一下光明面的影子。</p>\n\n<p style=\"text-indent:30px\">书中瘦弱的小男孩，拥有“超能力”，能够“偷别人的影子”，能透过影子看到他人，听见人们心中不愿意说出口的秘密。他心中的善良，让他成为需要帮助者的心灵伙伴，为每个“偷来影子的人”找到点亮生命的小小光芒。</p>\n\n<p style=\"text-indent:30px\">故事的开始，小男孩爸爸和妈妈的感情不和，让小男孩家庭破碎，小男孩和妈妈相依生活。小男孩对父亲的爱并没有减少，将思念深藏心底。</p>\n\n<p style=\"text-indent:30px\">伊凡是小男孩的好朋友，也是学校的警卫，在煤气炉爆炸时，小男孩在他人的帮助下救出在煤气炉中的伊凡，救出的伊凡十分痛苦，由于妈妈留给他的最后一封信和照片还在煤气炉中，可能会被烧毁，而小男孩透过那悲伤的影子，知道伊凡从出生就没见到过自己的妈妈。他妈妈在生他时就难产去世了（这块有点老套剧情的意思，忽略）。伊凡瞬间眼角湿润，小男孩回去后找自己的妈妈写了封信，请自己妈妈写出他还没出生时，她想跟他说得话。小男孩小心翼翼的将信藏在了伊凡的煤气炉的箱子底下，足足等了一周，伊凡来找他。伊凡辞职了，来跟他告别，这封信让伊凡意识到了他一直被童年禁锢，他要追寻他美好的人生了。</p>\n\n<p style=\"text-indent:30px\">这段是我目前为止最喜欢的一个情节，心思巧妙动人心弦。其它情节如吕克、伊利沙白、克雷儿相比会稍加逊色。善良的人很多，能够巧妙的让人舒服的善良很难得。而这份善良有可能会改变一个人的一生。</p>\n\n<p style=\"text-indent:30px\">文采不好，将这些文字埋在角落。如有幸您读到了，感恩您花时间阅读。</p>\n\n<p style=\"text-indent:30px\">现在读书的感觉很好，有了部分人生阅历之后，一些浅显的东西也更能看得更深刻，更了解明白作者想表达内容，是件美好的事情。</p>\n","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">空闲时间书为伴，每本书如一位好友般娓娓道来。叙述着一段段不同的人生。有平淡的小美好，有跌宕起伏的人生磨难，有历史长河的波澜壮阔，也有生活中平淡无奇的琐事。故将美好的事情记录下来，无论怎样，每一天都值得好好的对待！</p>","more":"<p style=\"text-indent:30px\">书作者Marc Levy，对作者并不熟悉，暂略。</p>\n\n<p style=\"text-indent:30px\">故事是以一个小男孩的视角去描述的。目前看了二分之一。之所以止住不看，是因为对另一句描述影子的话深感恐惧。一句话有时候可以给人力量，同时也足以让人深感恐惧，所以暂写二分之一的观感。想描述一下光明面的影子。</p>\n\n<p style=\"text-indent:30px\">书中瘦弱的小男孩，拥有“超能力”，能够“偷别人的影子”，能透过影子看到他人，听见人们心中不愿意说出口的秘密。他心中的善良，让他成为需要帮助者的心灵伙伴，为每个“偷来影子的人”找到点亮生命的小小光芒。</p>\n\n<p style=\"text-indent:30px\">故事的开始，小男孩爸爸和妈妈的感情不和，让小男孩家庭破碎，小男孩和妈妈相依生活。小男孩对父亲的爱并没有减少，将思念深藏心底。</p>\n\n<p style=\"text-indent:30px\">伊凡是小男孩的好朋友，也是学校的警卫，在煤气炉爆炸时，小男孩在他人的帮助下救出在煤气炉中的伊凡，救出的伊凡十分痛苦，由于妈妈留给他的最后一封信和照片还在煤气炉中，可能会被烧毁，而小男孩透过那悲伤的影子，知道伊凡从出生就没见到过自己的妈妈。他妈妈在生他时就难产去世了（这块有点老套剧情的意思，忽略）。伊凡瞬间眼角湿润，小男孩回去后找自己的妈妈写了封信，请自己妈妈写出他还没出生时，她想跟他说得话。小男孩小心翼翼的将信藏在了伊凡的煤气炉的箱子底下，足足等了一周，伊凡来找他。伊凡辞职了，来跟他告别，这封信让伊凡意识到了他一直被童年禁锢，他要追寻他美好的人生了。</p>\n\n<p style=\"text-indent:30px\">这段是我目前为止最喜欢的一个情节，心思巧妙动人心弦。其它情节如吕克、伊利沙白、克雷儿相比会稍加逊色。善良的人很多，能够巧妙的让人舒服的善良很难得。而这份善良有可能会改变一个人的一生。</p>\n\n<p style=\"text-indent:30px\">文采不好，将这些文字埋在角落。如有幸您读到了，感恩您花时间阅读。</p>\n\n<p style=\"text-indent:30px\">现在读书的感觉很好，有了部分人生阅历之后，一些浅显的东西也更能看得更深刻，更了解明白作者想表达内容，是件美好的事情。</p>"},{"title":"跨平台多端适配","date":"2021-01-07T11:16:22.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    Weex:https://weex.apache.org/zh/\n  </li>\n</ol>","source":"_posts/兼容性问题处理/多端适配.md","raw":"---\ntitle: 跨平台多端适配\ndate: 2021-01-07 19:16:22\ntags: 架构\ncategories: 架构\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    Weex:https://weex.apache.org/zh/\n  </li>\n</ol>","slug":"兼容性问题处理/多端适配","published":1,"updated":"2021-01-15T21:23:15.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3jz001kvbxxe59ipade","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    Weex:<a href=\"https://weex.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">https://weex.apache.org/zh/</a>\n  </li>\n</ol>","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    Weex:<a href=\"https://weex.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">https://weex.apache.org/zh/</a>\n  </li>\n</ol>"},{"title":"Mac安装和卸载HomeBrew","date":"2019-07-21T10:09:50.000Z","_content":"\n<a href=\"https://brew.sh/\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。\n\n<!-- more -->\n\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \n```\n\n<h4>卸载</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n![报错信息](/img/HomeBrew/1.png)\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n然后重新安装即可。\n","source":"_posts/工具/Mac安装和卸载HomeBrew.md","raw":"---\ntitle: Mac安装和卸载HomeBrew\ndate: 2019-07-21 18:09:50\ntags: 工具\ncategories: 工具\n---\n\n<a href=\"https://brew.sh/\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。\n\n<!-- more -->\n\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \n```\n\n<h4>卸载</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n![报错信息](/img/HomeBrew/1.png)\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n然后重新安装即可。\n","slug":"工具/Mac安装和卸载HomeBrew","published":1,"updated":"2020-12-21T13:04:43.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k0001mvbxxpuav5zp1","content":"<p><a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p>\n<a id=\"more\"></a>\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4>卸载</h4>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n<img src=\"/img/HomeBrew/1.png\" alt=\"报错信息\">\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n<p>然后重新安装即可。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p>","more":"<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4>卸载</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n<img src=\"/img/HomeBrew/1.png\" alt=\"报错信息\">\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n<p>然后重新安装即可。</p>"},{"title":"Git使用过程中遇到的问题","date":"2019-09-03T19:08:44.000Z","_content":"<p>此篇用于记录Git使用过程中遇到的问题。</p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      ```\n      ssh-add -K ~/.ssh/keyname\n      ```\n      <span class=\"fb\">参考：</span>https://segmentfault.com/q/1010000000835302\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset --hard</p>\n      ```\n      git reflog \n      git reset --hard HEAD@{index} // 如 index=rebase前的索引\n      ```\n      <span class=\"fb\">参考：</span>https://www.cnblogs.com/suanec/p/7511137.html\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    ```\n    git add -u\n    git reset -- XXX.txt\n    ```\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    ```\n    git branch       // 本地分支\n    git branch -r    // 远程分支\n    ```\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    ```\n    // 本地分支\n    git branch -D BranchName\n\n    // 远程分支\n    git branch -r -D origin/BranchName\n    git push origin -d BranchName    \n    ```\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    ```\n    git log A ^B\n    ```\n    </div>\n    <div>查看B有A没有\n    ```\n    git log B ^A\n    ```\n    </div>\n    <div>查看A比Bd多了哪些？\n    ```\n    git log A..B\n    ```\n    </div>\n    <div>查看B比A多了哪些？\n    ```\n    git log B..A\n    ```\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    ```\n    git diff topic master\n    git diff topic..master\n    ```\n    </div>\n    <span class=\"fb\">参考：</span>https://blog.csdn.net/u011240877/article/details/52586664\n  </li>\n</ol>\n","source":"_posts/工具/Git使用过程中遇到的问题.md","raw":"---\ntitle: Git使用过程中遇到的问题\ndate: 2019-09-04 03:08:44\ntags: 工具\ncategories: 工具\n---\n<p>此篇用于记录Git使用过程中遇到的问题。</p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      ```\n      ssh-add -K ~/.ssh/keyname\n      ```\n      <span class=\"fb\">参考：</span>https://segmentfault.com/q/1010000000835302\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset --hard</p>\n      ```\n      git reflog \n      git reset --hard HEAD@{index} // 如 index=rebase前的索引\n      ```\n      <span class=\"fb\">参考：</span>https://www.cnblogs.com/suanec/p/7511137.html\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    ```\n    git add -u\n    git reset -- XXX.txt\n    ```\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    ```\n    git branch       // 本地分支\n    git branch -r    // 远程分支\n    ```\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    ```\n    // 本地分支\n    git branch -D BranchName\n\n    // 远程分支\n    git branch -r -D origin/BranchName\n    git push origin -d BranchName    \n    ```\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    ```\n    git log A ^B\n    ```\n    </div>\n    <div>查看B有A没有\n    ```\n    git log B ^A\n    ```\n    </div>\n    <div>查看A比Bd多了哪些？\n    ```\n    git log A..B\n    ```\n    </div>\n    <div>查看B比A多了哪些？\n    ```\n    git log B..A\n    ```\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    ```\n    git diff topic master\n    git diff topic..master\n    ```\n    </div>\n    <span class=\"fb\">参考：</span>https://blog.csdn.net/u011240877/article/details/52586664\n  </li>\n</ol>\n","slug":"工具/Git使用过程中遇到的问题","published":1,"updated":"2021-01-19T07:54:58.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k1001pvbxxhidqf8ho","content":"<p></p><p>此篇用于记录Git使用过程中遇到的问题。</p><p></p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n\n<a id=\"more\"></a>\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -K ~/.ssh/keyname</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://segmentfault.com/q/1010000000835302\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000000835302</a>\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset –hard</p>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog </span><br><span class=\"line\">git reset --hard HEAD@&#123;index&#125; // 如 index=rebase前的索引</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://www.cnblogs.com/suanec/p/7511137.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/suanec/p/7511137.html</a>\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -u</span><br><span class=\"line\">git reset -- XXX.txt</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch       // 本地分支</span><br><span class=\"line\">git branch -r    // 远程分支</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地分支</span><br><span class=\"line\">git branch -D BranchName</span><br><span class=\"line\"></span><br><span class=\"line\">// 远程分支</span><br><span class=\"line\">git branch -r -D origin/BranchName</span><br><span class=\"line\">git push origin -d BranchName</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A ^B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B有A没有\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B ^A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看A比Bd多了哪些？\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A..B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B比A多了哪些？\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B..A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff topic master</span><br><span class=\"line\">git diff topic..master</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <span class=\"fb\">参考：</span><a href=\"https://blog.csdn.net/u011240877/article/details/52586664\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011240877/article/details/52586664</a>\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p></p><p>此篇用于记录Git使用过程中遇到的问题。</p><p></p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>","more":"<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -K ~/.ssh/keyname</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://segmentfault.com/q/1010000000835302\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000000835302</a>\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset –hard</p>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog </span><br><span class=\"line\">git reset --hard HEAD@&#123;index&#125; // 如 index=rebase前的索引</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://www.cnblogs.com/suanec/p/7511137.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/suanec/p/7511137.html</a>\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -u</span><br><span class=\"line\">git reset -- XXX.txt</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch       // 本地分支</span><br><span class=\"line\">git branch -r    // 远程分支</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地分支</span><br><span class=\"line\">git branch -D BranchName</span><br><span class=\"line\"></span><br><span class=\"line\">// 远程分支</span><br><span class=\"line\">git branch -r -D origin/BranchName</span><br><span class=\"line\">git push origin -d BranchName</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A ^B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B有A没有\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B ^A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看A比Bd多了哪些？\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A..B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B比A多了哪些？\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B..A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff topic master</span><br><span class=\"line\">git diff topic..master</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <span class=\"fb\">参考：</span><a href=\"https://blog.csdn.net/u011240877/article/details/52586664\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011240877/article/details/52586664</a>\n  </li>\n</ol>"},{"title":"巨人的陨落－观感2","date":"2020-01-27T15:05:04.000Z","thumbnail":"img/pen.jpg","_content":"<style type=\"text/css\">\n.td{text-indent:30px;}\n</style>\n\n<p class=\"td\">\n  每个人都是自己的掌舵人，都会被世界接纳...\n</p>\n\n<!-- more -->\n\n<p class=\"td\">\n  此篇内容来自《巨人的陨落1》中部分章节中情节描述，点滴记录读此篇章时的部分感悟。如有不当，还请指正。\n</p>\n\n<p class=\"td\">\n  如果把生命比作一段旅程，这段旅程中有开心、有难过、有感动、有悲伤...不同的感情温度对应不同的色值，有些感情饱满而深厚，有些平淡无华，有些波折难熬，有些幸福难忘......随着时间流逝，日渐模糊了记忆，褪去了浮华，凝结成属于每个人每个生命体的本原色，也造就了个体的不同属性。\n</p>\n\n<p class=\"td\">\n  故事要从煤矿发生爆炸说起，爆炸的起因可能有多种，矿井下通风不畅甲烷浓度过高，稍有不慎便会引发爆炸，爆炸引发粉尘燃烧进而引发火灾，矿工身处八百米以下头上有数百万吨的土石只有很少木梁支撑的地下，由于矿厂主为了降低成本“呼吸器”等设备并不齐全，缺氧和火灾会使矿工岌岌可危，这也是矿工们最担心的一件事情。\n</p>\n\n<p class=\"td\">\n  此刻菲茨伯爵的梅费尔宅邸中正在宴请国王，精致的器皿，精心搭配的水果餐食及按不同喜好布置的精致房屋，在“轰”的一声中，将聚会的欢乐时光一扫而光。矿难造成八人死亡，另五十人伤势严重。艾尔瑟是比利的姐姐，同时也是菲茨伯爵家中的女管家。由于矿难，再安排国王列队检阅显得不合时宜，菲茨猜测国王可能会关心一下矿难，便将艾瑟尔引荐给国王，艾瑟尔在表达自己的见解后提出了一个更为大胆的建议“访问死者家属...”\n</p>\n\n<p class=\"td\">\n  马车驶出豪华的大铁门，门里门外形成了鲜明的反差，门里一切整齐有序，到处是迷人的美景，外面则是一片现实的丑陋。在国王访问过后，艾瑟尔请求回家探亲，回家后艾瑟尔父亲对国王访问这场闹剧表示不满。认为这转移了大家对矿厂危险和非法操作的视线，平息了对矿业的愤怒。无形中化解了一场工人运动。\n</p>\n\n<p class=\"td\">\n  事实也是如此，此后没多久，丧失丈夫的妇人们，因家中无人在矿业做工而惨遭驱散无家可归。而年幼的艾瑟尔对父亲不理解自己为矿难家属做出的感情慰问深感懊恼，在回到伯爵府后向菲茨哭诉。此后菲茨为艾瑟尔非凡的表现而倾心，他们之间有过快乐的时光，之后却在自己的妻子碧公主和艾瑟尔同时怀孕时无情的抛弃了艾瑟尔。正当艾瑟尔走投无路之时回到家中，由于她父亲年幼时背负了祖父母名誉的影响极度愤怒，并将艾瑟尔赶出家门。艾瑟尔整理好行李便赶去伦敦的火车，比利送她去了车站。\n</p>\n\n<p class=\"td\">\n  章节中还穿插了菲茨的妹妹茉黛的感情线，她和沃尔特相爱，但却因政治原因备受左右及奥托父亲对茉黛特立独行的行为举止不满意，沃尔特出生在德国的外交世家，父亲奥托身处要职，而德国与英国的外交紧张近乎敌对状态，一旦沃尔特娶了英国人，他的家族将不受该阶层的信任，沃尔特也将无法在他的外交事业上施展才华。迫使相爱的两个人想要在一起遇到重重困境。\n</p>\n\n<p class=\"td\">\n  另一侧格戈雷里的父亲因为在碧公主的土地上放牛，而被指侵犯特权无情处死，格戈雷的母亲在一场工人斗争中被无情镇压而亡，格戈雷里和弟弟相依为命，攒了9年去美国的船票钱，那是他对一切未来的希望，而在即将上船的那刻，他弟弟因谋杀而无法呆在俄国，向他请求将船票给他，那刻他迟疑了片刻便将护照船票生活费倾尽所有的给了弟弟…弟弟满怀希望的坐船去美国赚钱给哥哥攒船票，几天几夜后偷渡船并没有把他放在美国，而是更近的临近国家…（偷渡船为了赚钱而欺骗了大家…\n</p>\n\n<p class=\"td\">\n  书中细节部分的描述强烈的烘托形成了鲜明的对比，将上层社会的冷漠现实和下层人民的贫穷疾苦多灾多难淋淋尽致的表现出来，不偏不倚的描述出世界的两面，对两面的描写是如此的细致入微而客观，精彩的转折将人物的性格和感情表达的直观而强烈。展现出历史背景下无人幸免的悲苦世界的同时，又描述出生命本真的每个人的内心渴求。\n</p>\n\n","source":"_posts/书虫/巨人的陨落－观感2.md","raw":"---\ntitle: 巨人的陨落－观感2\ndate: 2020-01-27 23:05:04\ncategories: 书虫\ntags: 书籍\nthumbnail: img/pen.jpg\n---\n<style type=\"text/css\">\n.td{text-indent:30px;}\n</style>\n\n<p class=\"td\">\n  每个人都是自己的掌舵人，都会被世界接纳...\n</p>\n\n<!-- more -->\n\n<p class=\"td\">\n  此篇内容来自《巨人的陨落1》中部分章节中情节描述，点滴记录读此篇章时的部分感悟。如有不当，还请指正。\n</p>\n\n<p class=\"td\">\n  如果把生命比作一段旅程，这段旅程中有开心、有难过、有感动、有悲伤...不同的感情温度对应不同的色值，有些感情饱满而深厚，有些平淡无华，有些波折难熬，有些幸福难忘......随着时间流逝，日渐模糊了记忆，褪去了浮华，凝结成属于每个人每个生命体的本原色，也造就了个体的不同属性。\n</p>\n\n<p class=\"td\">\n  故事要从煤矿发生爆炸说起，爆炸的起因可能有多种，矿井下通风不畅甲烷浓度过高，稍有不慎便会引发爆炸，爆炸引发粉尘燃烧进而引发火灾，矿工身处八百米以下头上有数百万吨的土石只有很少木梁支撑的地下，由于矿厂主为了降低成本“呼吸器”等设备并不齐全，缺氧和火灾会使矿工岌岌可危，这也是矿工们最担心的一件事情。\n</p>\n\n<p class=\"td\">\n  此刻菲茨伯爵的梅费尔宅邸中正在宴请国王，精致的器皿，精心搭配的水果餐食及按不同喜好布置的精致房屋，在“轰”的一声中，将聚会的欢乐时光一扫而光。矿难造成八人死亡，另五十人伤势严重。艾尔瑟是比利的姐姐，同时也是菲茨伯爵家中的女管家。由于矿难，再安排国王列队检阅显得不合时宜，菲茨猜测国王可能会关心一下矿难，便将艾瑟尔引荐给国王，艾瑟尔在表达自己的见解后提出了一个更为大胆的建议“访问死者家属...”\n</p>\n\n<p class=\"td\">\n  马车驶出豪华的大铁门，门里门外形成了鲜明的反差，门里一切整齐有序，到处是迷人的美景，外面则是一片现实的丑陋。在国王访问过后，艾瑟尔请求回家探亲，回家后艾瑟尔父亲对国王访问这场闹剧表示不满。认为这转移了大家对矿厂危险和非法操作的视线，平息了对矿业的愤怒。无形中化解了一场工人运动。\n</p>\n\n<p class=\"td\">\n  事实也是如此，此后没多久，丧失丈夫的妇人们，因家中无人在矿业做工而惨遭驱散无家可归。而年幼的艾瑟尔对父亲不理解自己为矿难家属做出的感情慰问深感懊恼，在回到伯爵府后向菲茨哭诉。此后菲茨为艾瑟尔非凡的表现而倾心，他们之间有过快乐的时光，之后却在自己的妻子碧公主和艾瑟尔同时怀孕时无情的抛弃了艾瑟尔。正当艾瑟尔走投无路之时回到家中，由于她父亲年幼时背负了祖父母名誉的影响极度愤怒，并将艾瑟尔赶出家门。艾瑟尔整理好行李便赶去伦敦的火车，比利送她去了车站。\n</p>\n\n<p class=\"td\">\n  章节中还穿插了菲茨的妹妹茉黛的感情线，她和沃尔特相爱，但却因政治原因备受左右及奥托父亲对茉黛特立独行的行为举止不满意，沃尔特出生在德国的外交世家，父亲奥托身处要职，而德国与英国的外交紧张近乎敌对状态，一旦沃尔特娶了英国人，他的家族将不受该阶层的信任，沃尔特也将无法在他的外交事业上施展才华。迫使相爱的两个人想要在一起遇到重重困境。\n</p>\n\n<p class=\"td\">\n  另一侧格戈雷里的父亲因为在碧公主的土地上放牛，而被指侵犯特权无情处死，格戈雷的母亲在一场工人斗争中被无情镇压而亡，格戈雷里和弟弟相依为命，攒了9年去美国的船票钱，那是他对一切未来的希望，而在即将上船的那刻，他弟弟因谋杀而无法呆在俄国，向他请求将船票给他，那刻他迟疑了片刻便将护照船票生活费倾尽所有的给了弟弟…弟弟满怀希望的坐船去美国赚钱给哥哥攒船票，几天几夜后偷渡船并没有把他放在美国，而是更近的临近国家…（偷渡船为了赚钱而欺骗了大家…\n</p>\n\n<p class=\"td\">\n  书中细节部分的描述强烈的烘托形成了鲜明的对比，将上层社会的冷漠现实和下层人民的贫穷疾苦多灾多难淋淋尽致的表现出来，不偏不倚的描述出世界的两面，对两面的描写是如此的细致入微而客观，精彩的转折将人物的性格和感情表达的直观而强烈。展现出历史背景下无人幸免的悲苦世界的同时，又描述出生命本真的每个人的内心渴求。\n</p>\n\n","slug":"书虫/巨人的陨落－观感2","published":1,"updated":"2021-01-18T08:50:30.635Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k2001tvbxxaanxiuib","content":"<style type=\"text/css\">\n.td{text-indent:30px;}\n</style>\n\n<p class=\"td\">\n  每个人都是自己的掌舵人，都会被世界接纳…\n</p>\n\n<a id=\"more\"></a>\n<p class=\"td\">\n  此篇内容来自《巨人的陨落1》中部分章节中情节描述，点滴记录读此篇章时的部分感悟。如有不当，还请指正。\n</p>\n\n<p class=\"td\">\n  如果把生命比作一段旅程，这段旅程中有开心、有难过、有感动、有悲伤…不同的感情温度对应不同的色值，有些感情饱满而深厚，有些平淡无华，有些波折难熬，有些幸福难忘……随着时间流逝，日渐模糊了记忆，褪去了浮华，凝结成属于每个人每个生命体的本原色，也造就了个体的不同属性。\n</p>\n\n<p class=\"td\">\n  故事要从煤矿发生爆炸说起，爆炸的起因可能有多种，矿井下通风不畅甲烷浓度过高，稍有不慎便会引发爆炸，爆炸引发粉尘燃烧进而引发火灾，矿工身处八百米以下头上有数百万吨的土石只有很少木梁支撑的地下，由于矿厂主为了降低成本“呼吸器”等设备并不齐全，缺氧和火灾会使矿工岌岌可危，这也是矿工们最担心的一件事情。\n</p>\n\n<p class=\"td\">\n  此刻菲茨伯爵的梅费尔宅邸中正在宴请国王，精致的器皿，精心搭配的水果餐食及按不同喜好布置的精致房屋，在“轰”的一声中，将聚会的欢乐时光一扫而光。矿难造成八人死亡，另五十人伤势严重。艾尔瑟是比利的姐姐，同时也是菲茨伯爵家中的女管家。由于矿难，再安排国王列队检阅显得不合时宜，菲茨猜测国王可能会关心一下矿难，便将艾瑟尔引荐给国王，艾瑟尔在表达自己的见解后提出了一个更为大胆的建议“访问死者家属…”\n</p>\n\n<p class=\"td\">\n  马车驶出豪华的大铁门，门里门外形成了鲜明的反差，门里一切整齐有序，到处是迷人的美景，外面则是一片现实的丑陋。在国王访问过后，艾瑟尔请求回家探亲，回家后艾瑟尔父亲对国王访问这场闹剧表示不满。认为这转移了大家对矿厂危险和非法操作的视线，平息了对矿业的愤怒。无形中化解了一场工人运动。\n</p>\n\n<p class=\"td\">\n  事实也是如此，此后没多久，丧失丈夫的妇人们，因家中无人在矿业做工而惨遭驱散无家可归。而年幼的艾瑟尔对父亲不理解自己为矿难家属做出的感情慰问深感懊恼，在回到伯爵府后向菲茨哭诉。此后菲茨为艾瑟尔非凡的表现而倾心，他们之间有过快乐的时光，之后却在自己的妻子碧公主和艾瑟尔同时怀孕时无情的抛弃了艾瑟尔。正当艾瑟尔走投无路之时回到家中，由于她父亲年幼时背负了祖父母名誉的影响极度愤怒，并将艾瑟尔赶出家门。艾瑟尔整理好行李便赶去伦敦的火车，比利送她去了车站。\n</p>\n\n<p class=\"td\">\n  章节中还穿插了菲茨的妹妹茉黛的感情线，她和沃尔特相爱，但却因政治原因备受左右及奥托父亲对茉黛特立独行的行为举止不满意，沃尔特出生在德国的外交世家，父亲奥托身处要职，而德国与英国的外交紧张近乎敌对状态，一旦沃尔特娶了英国人，他的家族将不受该阶层的信任，沃尔特也将无法在他的外交事业上施展才华。迫使相爱的两个人想要在一起遇到重重困境。\n</p>\n\n<p class=\"td\">\n  另一侧格戈雷里的父亲因为在碧公主的土地上放牛，而被指侵犯特权无情处死，格戈雷的母亲在一场工人斗争中被无情镇压而亡，格戈雷里和弟弟相依为命，攒了9年去美国的船票钱，那是他对一切未来的希望，而在即将上船的那刻，他弟弟因谋杀而无法呆在俄国，向他请求将船票给他，那刻他迟疑了片刻便将护照船票生活费倾尽所有的给了弟弟…弟弟满怀希望的坐船去美国赚钱给哥哥攒船票，几天几夜后偷渡船并没有把他放在美国，而是更近的临近国家…（偷渡船为了赚钱而欺骗了大家…\n</p>\n\n<p class=\"td\">\n  书中细节部分的描述强烈的烘托形成了鲜明的对比，将上层社会的冷漠现实和下层人民的贫穷疾苦多灾多难淋淋尽致的表现出来，不偏不倚的描述出世界的两面，对两面的描写是如此的细致入微而客观，精彩的转折将人物的性格和感情表达的直观而强烈。展现出历史背景下无人幸免的悲苦世界的同时，又描述出生命本真的每个人的内心渴求。\n</p>\n\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.td{text-indent:30px;}\n</style>\n\n<p class=\"td\">\n  每个人都是自己的掌舵人，都会被世界接纳…\n</p>","more":"<p class=\"td\">\n  此篇内容来自《巨人的陨落1》中部分章节中情节描述，点滴记录读此篇章时的部分感悟。如有不当，还请指正。\n</p>\n\n<p class=\"td\">\n  如果把生命比作一段旅程，这段旅程中有开心、有难过、有感动、有悲伤…不同的感情温度对应不同的色值，有些感情饱满而深厚，有些平淡无华，有些波折难熬，有些幸福难忘……随着时间流逝，日渐模糊了记忆，褪去了浮华，凝结成属于每个人每个生命体的本原色，也造就了个体的不同属性。\n</p>\n\n<p class=\"td\">\n  故事要从煤矿发生爆炸说起，爆炸的起因可能有多种，矿井下通风不畅甲烷浓度过高，稍有不慎便会引发爆炸，爆炸引发粉尘燃烧进而引发火灾，矿工身处八百米以下头上有数百万吨的土石只有很少木梁支撑的地下，由于矿厂主为了降低成本“呼吸器”等设备并不齐全，缺氧和火灾会使矿工岌岌可危，这也是矿工们最担心的一件事情。\n</p>\n\n<p class=\"td\">\n  此刻菲茨伯爵的梅费尔宅邸中正在宴请国王，精致的器皿，精心搭配的水果餐食及按不同喜好布置的精致房屋，在“轰”的一声中，将聚会的欢乐时光一扫而光。矿难造成八人死亡，另五十人伤势严重。艾尔瑟是比利的姐姐，同时也是菲茨伯爵家中的女管家。由于矿难，再安排国王列队检阅显得不合时宜，菲茨猜测国王可能会关心一下矿难，便将艾瑟尔引荐给国王，艾瑟尔在表达自己的见解后提出了一个更为大胆的建议“访问死者家属…”\n</p>\n\n<p class=\"td\">\n  马车驶出豪华的大铁门，门里门外形成了鲜明的反差，门里一切整齐有序，到处是迷人的美景，外面则是一片现实的丑陋。在国王访问过后，艾瑟尔请求回家探亲，回家后艾瑟尔父亲对国王访问这场闹剧表示不满。认为这转移了大家对矿厂危险和非法操作的视线，平息了对矿业的愤怒。无形中化解了一场工人运动。\n</p>\n\n<p class=\"td\">\n  事实也是如此，此后没多久，丧失丈夫的妇人们，因家中无人在矿业做工而惨遭驱散无家可归。而年幼的艾瑟尔对父亲不理解自己为矿难家属做出的感情慰问深感懊恼，在回到伯爵府后向菲茨哭诉。此后菲茨为艾瑟尔非凡的表现而倾心，他们之间有过快乐的时光，之后却在自己的妻子碧公主和艾瑟尔同时怀孕时无情的抛弃了艾瑟尔。正当艾瑟尔走投无路之时回到家中，由于她父亲年幼时背负了祖父母名誉的影响极度愤怒，并将艾瑟尔赶出家门。艾瑟尔整理好行李便赶去伦敦的火车，比利送她去了车站。\n</p>\n\n<p class=\"td\">\n  章节中还穿插了菲茨的妹妹茉黛的感情线，她和沃尔特相爱，但却因政治原因备受左右及奥托父亲对茉黛特立独行的行为举止不满意，沃尔特出生在德国的外交世家，父亲奥托身处要职，而德国与英国的外交紧张近乎敌对状态，一旦沃尔特娶了英国人，他的家族将不受该阶层的信任，沃尔特也将无法在他的外交事业上施展才华。迫使相爱的两个人想要在一起遇到重重困境。\n</p>\n\n<p class=\"td\">\n  另一侧格戈雷里的父亲因为在碧公主的土地上放牛，而被指侵犯特权无情处死，格戈雷的母亲在一场工人斗争中被无情镇压而亡，格戈雷里和弟弟相依为命，攒了9年去美国的船票钱，那是他对一切未来的希望，而在即将上船的那刻，他弟弟因谋杀而无法呆在俄国，向他请求将船票给他，那刻他迟疑了片刻便将护照船票生活费倾尽所有的给了弟弟…弟弟满怀希望的坐船去美国赚钱给哥哥攒船票，几天几夜后偷渡船并没有把他放在美国，而是更近的临近国家…（偷渡船为了赚钱而欺骗了大家…\n</p>\n\n<p class=\"td\">\n  书中细节部分的描述强烈的烘托形成了鲜明的对比，将上层社会的冷漠现实和下层人民的贫穷疾苦多灾多难淋淋尽致的表现出来，不偏不倚的描述出世界的两面，对两面的描写是如此的细致入微而客观，精彩的转折将人物的性格和感情表达的直观而强烈。展现出历史背景下无人幸免的悲苦世界的同时，又描述出生命本真的每个人的内心渴求。\n</p>"},{"title":"VSCode常用快捷键","date":"2019-10-17T03:48:38.000Z","_content":"\n<p></p>\n\n<!-- more -->\n\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","source":"_posts/工具/VSCode常用快捷键.md","raw":"---\ntitle: VSCode常用快捷键\ndate: 2019-10-17 11:48:38\ntags: 工具\ncategories: 工具\n---\n\n<p></p>\n\n<!-- more -->\n\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","slug":"工具/VSCode常用快捷键","published":1,"updated":"2021-01-01T11:27:41.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k3001wvbxxb5m9bu3u","content":"<p></p>\n\n<a id=\"more\"></a>\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p></p>","more":"<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>"},{"title":"手动实现一个koa-logger中间件","date":"2021-01-19T13:04:46.000Z","_content":"\n<p>koa2对async/await支持。</p>\n\n<style>\n.red {\n  color: red;\n}\n</style>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>编写koa-logger.js文件</p>\n    ```\n      module.exports = async (ctx, next) => {\n        const start = new Date().getTime()\n        // 中间件异步处理\n        await next()\n        const end = new Date().getTime()\n        // 打印出耗时还有长度\n        console.log(ctx.request.url, end - start, ctx.body.length, 'log')\n      }\n    ```\n  </li>\n  <li>\n    <p>注册koa-logger中间件</p>\n    ```\n    const Koa = require('koa')\n\n    const app = new Koa()\n\n    const logger = require('./koa-logger')\n\n    // 注册中间件\n    app.use(logger)\n    ```\n  </li>\n</ol>\n\n<ul>\n  <li>koa2核心原理：compose通过递归对中间件队列进行了<span class=\"red\">反序遍历</span></li>\n</ul>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Node.js中间件模式: https://juejin.cn/post/6844903619209199624</li>\n</ol>\n","source":"_posts/工具/手动实现一个koa-logger中间件.md","raw":"---\ntitle: 手动实现一个koa-logger中间件\ndate: 2021-01-19 21:04:46\ntags: 工具\ncategories: 工具\n---\n\n<p>koa2对async/await支持。</p>\n\n<style>\n.red {\n  color: red;\n}\n</style>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>编写koa-logger.js文件</p>\n    ```\n      module.exports = async (ctx, next) => {\n        const start = new Date().getTime()\n        // 中间件异步处理\n        await next()\n        const end = new Date().getTime()\n        // 打印出耗时还有长度\n        console.log(ctx.request.url, end - start, ctx.body.length, 'log')\n      }\n    ```\n  </li>\n  <li>\n    <p>注册koa-logger中间件</p>\n    ```\n    const Koa = require('koa')\n\n    const app = new Koa()\n\n    const logger = require('./koa-logger')\n\n    // 注册中间件\n    app.use(logger)\n    ```\n  </li>\n</ol>\n\n<ul>\n  <li>koa2核心原理：compose通过递归对中间件队列进行了<span class=\"red\">反序遍历</span></li>\n</ul>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Node.js中间件模式: https://juejin.cn/post/6844903619209199624</li>\n</ol>\n","slug":"工具/手动实现一个koa-logger中间件","published":1,"updated":"2021-01-19T15:22:38.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k40020vbxxamwz2h4a","content":"<p>koa2对async/await支持。</p>\n\n<style>\n.red {\n  color: red;\n}\n</style>\n\n<a id=\"more\"></a>\n<ol>\n  <li>\n    <p>编写koa-logger.js文件</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  const start = new Date().getTime()</span><br><span class=\"line\">  // 中间件异步处理</span><br><span class=\"line\">  await next()</span><br><span class=\"line\">  const end = new Date().getTime()</span><br><span class=\"line\">  // 打印出耗时还有长度</span><br><span class=\"line\">  console.log(ctx.request.url, end - start, ctx.body.length, &apos;log&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>注册koa-logger中间件</p>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Koa = require(&apos;koa&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">const logger = require(&apos;./koa-logger&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册中间件</span><br><span class=\"line\">app.use(logger)</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<ul>\n  <li>koa2核心原理：compose通过递归对中间件队列进行了<span class=\"red\">反序遍历</span></li>\n</ul>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Node.js中间件模式: <a href=\"https://juejin.cn/post/6844903619209199624\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903619209199624</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>koa2对async/await支持。</p>\n\n<style>\n.red {\n  color: red;\n}\n</style>","more":"<ol>\n  <li>\n    <p>编写koa-logger.js文件</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = async (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  const start = new Date().getTime()</span><br><span class=\"line\">  // 中间件异步处理</span><br><span class=\"line\">  await next()</span><br><span class=\"line\">  const end = new Date().getTime()</span><br><span class=\"line\">  // 打印出耗时还有长度</span><br><span class=\"line\">  console.log(ctx.request.url, end - start, ctx.body.length, &apos;log&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>\n    <p>注册koa-logger中间件</p>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Koa = require(&apos;koa&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const app = new Koa()</span><br><span class=\"line\"></span><br><span class=\"line\">const logger = require(&apos;./koa-logger&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 注册中间件</span><br><span class=\"line\">app.use(logger)</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<ul>\n  <li>koa2核心原理：compose通过递归对中间件队列进行了<span class=\"red\">反序遍历</span></li>\n</ul>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Node.js中间件模式: <a href=\"https://juejin.cn/post/6844903619209199624\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903619209199624</a></li>\n</ol>"},{"title":"unit-tests","date":"2019-10-27T13:41:39.000Z","_content":"\nI don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS\n\n<!-- more -->\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://sinonjs.org/</li>\n  <li>https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</li>\n</ol>","source":"_posts/工具/unit-tests.md","raw":"---\ntitle: unit-tests\ndate: 2019-10-27 21:41:39\ntags: 工具\ncategories: 工具\n---\n\nI don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS\n\n<!-- more -->\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://sinonjs.org/</li>\n  <li>https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</li>\n</ol>","slug":"工具/unit-tests","published":1,"updated":"2020-12-21T13:24:25.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k40024vbxx99qefdh0","content":"<p>I don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS</p>\n<a id=\"more\"></a>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"noopener\">https://sinonjs.org/</a></li>\n  <li><a href=\"https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html\" target=\"_blank\" rel=\"noopener\">https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>I don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS</p>","more":"<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"noopener\">https://sinonjs.org/</a></li>\n  <li><a href=\"https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html\" target=\"_blank\" rel=\"noopener\">https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</a></li>\n</ol>"},{"title":"使用Mocha进行自动化测试","date":"2021-01-30T13:30:02.000Z","_content":"\n\nhttps://zh.javascript.info/testing-mocha\n\n重要：\nhttps://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880\n\n前端测试框架：\nhttps://juejin.cn/post/6844903800302469128\n\n","source":"_posts/工具/使用Mocha进行自动化测试.md","raw":"---\ntitle: 使用Mocha进行自动化测试\ndate: 2021-01-30 21:30:02\ntags: 工具\ncategories: 工具\n---\n\n\nhttps://zh.javascript.info/testing-mocha\n\n重要：\nhttps://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880\n\n前端测试框架：\nhttps://juejin.cn/post/6844903800302469128\n\n","slug":"工具/使用Mocha进行自动化测试","published":1,"updated":"2021-01-30T13:45:12.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k50027vbxxpr3a6net","content":"<p><a href=\"https://zh.javascript.info/testing-mocha\" target=\"_blank\" rel=\"noopener\">https://zh.javascript.info/testing-mocha</a></p>\n<p>重要：\n<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880</a></p>\n<p>前端测试框架：\n<a href=\"https://juejin.cn/post/6844903800302469128\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903800302469128</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://zh.javascript.info/testing-mocha\" target=\"_blank\" rel=\"noopener\">https://zh.javascript.info/testing-mocha</a></p>\n<p>重要：\n<a href=\"https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880\" target=\"_blank\" rel=\"noopener\">https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880</a></p>\n<p>前端测试框架：\n<a href=\"https://juejin.cn/post/6844903800302469128\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903800302469128</a></p>\n"},{"title":"编写自己的webpack Loader","date":"2021-01-01T07:50:33.000Z","_content":"\nhttps://www.webpackjs.com/contribute/writing-a-loader/\n","source":"_posts/工具/编写自己的webpack-loader.md","raw":"---\ntitle: 编写自己的webpack Loader\ndate: 2021-01-01 15:50:33\ntags: 工具\ncategories: 工具\n---\n\nhttps://www.webpackjs.com/contribute/writing-a-loader/\n","slug":"工具/编写自己的webpack-loader","published":1,"updated":"2021-01-19T16:56:29.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k6002bvbxx5hd77h9k","content":"<p><a href=\"https://www.webpackjs.com/contribute/writing-a-loader/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/contribute/writing-a-loader/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.webpackjs.com/contribute/writing-a-loader/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/contribute/writing-a-loader/</a></p>\n"},{"title":"babel编译过程","date":"2019-10-17T03:48:38.000Z","_content":"","source":"_posts/工具/babel编译过程.md","raw":"---\ntitle: babel编译过程\ndate: 2019-10-17 11:48:38\ntags: 工具\ncategories: 工具\n---\n","slug":"工具/babel编译过程","published":1,"updated":"2021-01-19T07:56:41.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k7002evbxxu650efky","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"工程化概述","date":"2020-12-21T12:06:13.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6844903588553048077</li>\n</ol>\n","source":"_posts/工程化/工程化概述.md","raw":"---\ntitle: 工程化概述\ndate: 2020-12-21 20:06:13\ntags:\ncategories: 工程化\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6844903588553048077</li>\n</ol>\n","slug":"工程化/工程化概述","published":1,"updated":"2021-01-01T05:31:01.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k8002ivbxxamyva0ir","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6844903588553048077\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903588553048077</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6844903588553048077\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903588553048077</a></li>\n</ol>\n"},{"title":"webpack编译过程","date":"2019-10-17T03:48:38.000Z","_content":"\n","source":"_posts/工具/webpack编译过程.md","raw":"---\ntitle: webpack编译过程\ndate: 2019-10-17 11:48:38\ntags: 工具\ncategories: 工具\n---\n\n","slug":"工具/webpack编译过程","published":1,"updated":"2021-01-19T07:56:02.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3k9002lvbxxtjcxosar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"前端异常处理","date":"2021-01-10T02:44:51.000Z","_content":"\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>http://jartto.wang/2018/11/20/js-exception-handling/</li>\n  <li>https://juejin.cn/post/6875955097864994823</li>\n</ol>","source":"_posts/异常&性能/前端异常处理.md","raw":"---\ntitle: 前端异常处理\ndate: 2021-01-10 10:44:51\ntags: 异常&性能\ncategories: 异常&性能\n\n---\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>http://jartto.wang/2018/11/20/js-exception-handling/</li>\n  <li>https://juejin.cn/post/6875955097864994823</li>\n</ol>","slug":"异常&性能/前端异常处理","published":1,"updated":"2021-01-22T07:53:45.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ka002pvbxxxn162jy0","content":"<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"http://jartto.wang/2018/11/20/js-exception-handling/\" target=\"_blank\" rel=\"noopener\">http://jartto.wang/2018/11/20/js-exception-handling/</a></li>\n  <li><a href=\"https://juejin.cn/post/6875955097864994823\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6875955097864994823</a></li>\n</ol>","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"http://jartto.wang/2018/11/20/js-exception-handling/\" target=\"_blank\" rel=\"noopener\">http://jartto.wang/2018/11/20/js-exception-handling/</a></li>\n  <li><a href=\"https://juejin.cn/post/6875955097864994823\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6875955097864994823</a></li>\n</ol>"},{"title":"Performance Monitor性能指标","date":"2021-01-10T14:28:17.000Z","_content":"\n查看性能指标，页面性能调优。\n\n<!--more-->\n\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://juejin.cn/post/6844904045774110733</li>\n</ol>","source":"_posts/异常&性能/Performance-Monitor性能指标.md","raw":"---\ntitle: Performance Monitor性能指标\ndate: 2021-01-10 22:28:17\ntags: 异常&性能\ncategories: 异常&性能\n---\n\n查看性能指标，页面性能调优。\n\n<!--more-->\n\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://juejin.cn/post/6844904045774110733</li>\n</ol>","slug":"异常&性能/Performance-Monitor性能指标","published":1,"updated":"2021-01-17T17:51:47.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kb002tvbxxqu0xt9om","content":"<p>查看性能指标，页面性能调优。</p>\n<a id=\"more\"></a>\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904045774110733\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904045774110733</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>查看性能指标，页面性能调优。</p>","more":"<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904045774110733\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904045774110733</a></li>\n</ol>"},{"title":"编写自己的webpack Plugins","date":"2021-01-01T07:50:33.000Z","_content":"\nhttps://www.webpackjs.com/contribute/writing-a-plugin/\n","source":"_posts/工具/编写自己的webpack-plugins.md","raw":"---\ntitle: 编写自己的webpack Plugins\ndate: 2021-01-01 15:50:33\ntags: 工具\ncategories: 工具\n---\n\nhttps://www.webpackjs.com/contribute/writing-a-plugin/\n","slug":"工具/编写自己的webpack-plugins","published":1,"updated":"2021-01-19T16:56:27.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kc002xvbxx2fklep8z","content":"<p><a href=\"https://www.webpackjs.com/contribute/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/contribute/writing-a-plugin/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.webpackjs.com/contribute/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/contribute/writing-a-plugin/</a></p>\n"},{"title":"常见缓存算法和缓存策略","date":"2020-12-13T02:27:19.000Z","_content":"\nLRU算法\n\n<!--more-->\n\n<ol>\n  <li>\n   <p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>\n   ```\n   javascript实现待补充\n   ```\n  </li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>LRU算法原理与实践: https://www.jianshu.com/p/720dda0c418f</li>\n  <li>https://zhuanlan.zhihu.com/p/34989978</li>\n  <li>https://blog.vimge.com/archives/architecture/cache-strategy.html</li>\n</ol>\n","source":"_posts/数据结构&算法/常见缓存算法和缓存策略.md","raw":"---\ntitle: 常见缓存算法和缓存策略\ndate: 2020-12-13 10:27:19\ntags: 算法\ncategories: 数据结构&算法\n---\n\nLRU算法\n\n<!--more-->\n\n<ol>\n  <li>\n   <p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>\n   ```\n   javascript实现待补充\n   ```\n  </li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>LRU算法原理与实践: https://www.jianshu.com/p/720dda0c418f</li>\n  <li>https://zhuanlan.zhihu.com/p/34989978</li>\n  <li>https://blog.vimge.com/archives/architecture/cache-strategy.html</li>\n</ol>\n","slug":"数据结构&算法/常见缓存算法和缓存策略","published":1,"updated":"2021-01-19T19:34:34.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kd0031vbxxq65q8vnh","content":"<p>LRU算法</p>\n<a id=\"more\"></a>\n<ol>\n  <li>\n   <p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>\n   <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript实现待补充</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>LRU算法原理与实践: <a href=\"https://www.jianshu.com/p/720dda0c418f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/720dda0c418f</a></li>\n  <li><a href=\"https://zhuanlan.zhihu.com/p/34989978\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34989978</a></li>\n  <li><a href=\"https://blog.vimge.com/archives/architecture/cache-strategy.html\" target=\"_blank\" rel=\"noopener\">https://blog.vimge.com/archives/architecture/cache-strategy.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>LRU算法</p>","more":"<ol>\n  <li>\n   <p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javascript实现待补充</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>LRU算法原理与实践: <a href=\"https://www.jianshu.com/p/720dda0c418f\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/720dda0c418f</a></li>\n  <li><a href=\"https://zhuanlan.zhihu.com/p/34989978\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/34989978</a></li>\n  <li><a href=\"https://blog.vimge.com/archives/architecture/cache-strategy.html\" target=\"_blank\" rel=\"noopener\">https://blog.vimge.com/archives/architecture/cache-strategy.html</a></li>\n</ol>"},{"title":"SEO原理","date":"2021-01-01T06:35:11.000Z","_content":"\nhttps://juejin.cn/post/6844903616772309000\n","source":"_posts/总结/SEO原理.md","raw":"---\ntitle: SEO原理\ndate: 2021-01-01 14:35:11\ntags:\ncategories: 总结\n---\n\nhttps://juejin.cn/post/6844903616772309000\n","slug":"总结/SEO原理","published":1,"updated":"2021-01-25T09:50:27.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ke0035vbxxe0ty59c8","content":"<p><a href=\"https://juejin.cn/post/6844903616772309000\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903616772309000</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://juejin.cn/post/6844903616772309000\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903616772309000</a></p>\n"},{"title":"Javascript数组去重和排序","date":"2020-12-13T02:27:19.000Z","_content":"\n<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n数组去重和排序\n\n<!--more-->\n\n<h4>数组去重: 包含null/undefined</h4>\n<ol>\n  <li>es6的Set\n    ```\n    function unique (arr) {\n      return [...new Set(arr)]\n    }\n\n    function unique (arr) {\n      return Array.from(new Set(arr));\n    }\n\n    unique(['a', 'a', 'b', 'c']) // ['a', 'b', 'c']\n    ```\n  </li>\n  <li>indexOf()结合for...of/forEach/for...in\n    ```\n    const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];\n\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (newArr.indexOf(item) === -1) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>includes()结合for...of/forEach/for...in\n    ```\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (!newArr.includes(item)) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    ```\n    function unique (arr) {\n      const newArr = []\n      let isRepeat = false\n      for (let item of arr) {\n        isRepeat = false\n        for (let newItem of newArr) {\n          if (item === newItem) {\n            isRepeat = true\n          }\n        }\n\n        if (!isRepeat) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n\n    优化版\n    ```\n    function unique (arr) {\n      const newArr = []\n      const len = arr.length\n      for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n          if (arr[i] === arr[j]) {\n            j = ++i\n          }\n        }\n        newArr.push(arr[i])\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n</ol>\n\n<h4>数组排序</h4>\n<ol>\n  <li>sort()\n    ```\n    const arr=[1, 11, 2, 3, 6]\n    arr.sort((a, b) => {\n      return a - b\n    })\n    arr // output: [1, 2, 3, 6, 11]\n    ```\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","source":"_posts/数据结构&算法/Javascript数组去重和排序.md","raw":"---\ntitle: Javascript数组去重和排序\ndate: 2020-12-13 10:27:19\ntags: 算法\ncategories: 数据结构&算法\n---\n\n<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n数组去重和排序\n\n<!--more-->\n\n<h4>数组去重: 包含null/undefined</h4>\n<ol>\n  <li>es6的Set\n    ```\n    function unique (arr) {\n      return [...new Set(arr)]\n    }\n\n    function unique (arr) {\n      return Array.from(new Set(arr));\n    }\n\n    unique(['a', 'a', 'b', 'c']) // ['a', 'b', 'c']\n    ```\n  </li>\n  <li>indexOf()结合for...of/forEach/for...in\n    ```\n    const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];\n\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (newArr.indexOf(item) === -1) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>includes()结合for...of/forEach/for...in\n    ```\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (!newArr.includes(item)) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    ```\n    function unique (arr) {\n      const newArr = []\n      let isRepeat = false\n      for (let item of arr) {\n        isRepeat = false\n        for (let newItem of newArr) {\n          if (item === newItem) {\n            isRepeat = true\n          }\n        }\n\n        if (!isRepeat) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n\n    优化版\n    ```\n    function unique (arr) {\n      const newArr = []\n      const len = arr.length\n      for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n          if (arr[i] === arr[j]) {\n            j = ++i\n          }\n        }\n        newArr.push(arr[i])\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n</ol>\n\n<h4>数组排序</h4>\n<ol>\n  <li>sort()\n    ```\n    const arr=[1, 11, 2, 3, 6]\n    arr.sort((a, b) => {\n      return a - b\n    })\n    arr // output: [1, 2, 3, 6, 11]\n    ```\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","slug":"数据结构&算法/Javascript数组去重和排序","published":1,"updated":"2021-01-19T19:11:31.546Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kf0039vbxxyyytjogs","content":"<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n<p>数组去重和排序</p>\n<a id=\"more\"></a>\n<p></p><h4>数组去重: 包含null/undefined</h4><p></p>\n<ol>\n  <li>es6的Set\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>indexOf()结合for…of/forEach/for…in\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (newArr.indexOf(item) === -1) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>includes()结合for…of/forEach/for…in\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (!newArr.includes(item)) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  let isRepeat = false</span><br><span class=\"line\">  for (let item of arr) &#123;</span><br><span class=\"line\">    isRepeat = false</span><br><span class=\"line\">    for (let newItem of newArr) &#123;</span><br><span class=\"line\">      if (item === newItem) &#123;</span><br><span class=\"line\">        isRepeat = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!isRepeat) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    优化版\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  const len = arr.length</span><br><span class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">      if (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        j = ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    newArr.push(arr[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4>数组排序</h4><p></p>\n<ol>\n  <li>sort()\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr=[1, 11, 2, 3, 6]</span><br><span class=\"line\">arr.sort((a, b) =&gt; &#123;</span><br><span class=\"line\">  return a - b</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">arr // output: [1, 2, 3, 6, 11]</span><br></pre></td></tr></table></figure>\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n<p>数组去重和排序</p>","more":"<p></p><h4>数组去重: 包含null/undefined</h4><p></p>\n<ol>\n  <li>es6的Set\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>indexOf()结合for…of/forEach/for…in\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (newArr.indexOf(item) === -1) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>includes()结合for…of/forEach/for…in\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (!newArr.includes(item)) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  let isRepeat = false</span><br><span class=\"line\">  for (let item of arr) &#123;</span><br><span class=\"line\">    isRepeat = false</span><br><span class=\"line\">    for (let newItem of newArr) &#123;</span><br><span class=\"line\">      if (item === newItem) &#123;</span><br><span class=\"line\">        isRepeat = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!isRepeat) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    优化版\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  const len = arr.length</span><br><span class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">      if (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        j = ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    newArr.push(arr[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4>数组排序</h4><p></p>\n<ol>\n  <li>sort()\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr=[1, 11, 2, 3, 6]</span><br><span class=\"line\">arr.sort((a, b) =&gt; &#123;</span><br><span class=\"line\">  return a - b</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">arr // output: [1, 2, 3, 6, 11]</span><br></pre></td></tr></table></figure>\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>"},{"title":"前端性能优化","date":"2019-05-10T04:09:04.000Z","thumbnail":"img/plant.jpg","_content":"\n本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》\n\n<!-- more -->\n\n<h4>JavaScript篇</h4>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<h4>css篇</h4>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<h4>网络篇</h4>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    ```\n    Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；\n    Cache-Control: private immutable \n    //不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；\n    Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；\n    Cache-Control: public max-age=3600 s-maxage=7200 \n    //本地缓存 1 小时，CDN 上缓存 2 小时；\n    Cache-Control: public max-age=3600 proxy-revalidate  \n    //本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源\n    ```\n    </li>\n</ol>\n\n<h4>其他</h4>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：https://www.cnblogs.com/yingsong/p/6170780.html</p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：https://www.cnblogs.com/softidea/p/5308489.html</p>\n    </li>\n</ol>\n","source":"_posts/异常&性能/前端性能优化.md","raw":"---\ntitle: 前端性能优化\ndate: 2019-05-10 12:09:04\ntags: 异常&性能\ncategories: 异常&性能\nthumbnail: img/plant.jpg\n---\n\n本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》\n\n<!-- more -->\n\n<h4>JavaScript篇</h4>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<h4>css篇</h4>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<h4>网络篇</h4>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    ```\n    Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；\n    Cache-Control: private immutable \n    //不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；\n    Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；\n    Cache-Control: public max-age=3600 s-maxage=7200 \n    //本地缓存 1 小时，CDN 上缓存 2 小时；\n    Cache-Control: public max-age=3600 proxy-revalidate  \n    //本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源\n    ```\n    </li>\n</ol>\n\n<h4>其他</h4>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：https://www.cnblogs.com/yingsong/p/6170780.html</p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：https://www.cnblogs.com/softidea/p/5308489.html</p>\n    </li>\n</ol>\n","slug":"异常&性能/前端性能优化","published":1,"updated":"2021-01-14T02:46:47.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kg003dvbxxj9d8u5rb","content":"<p>本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》</p>\n<a id=\"more\"></a>\n<p></p><h4>JavaScript篇</h4><p></p>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<p></p><h4>css篇</h4><p></p>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<p></p><h4>网络篇</h4><p></p>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；</span><br><span class=\"line\">Cache-Control: private immutable </span><br><span class=\"line\">//不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；</span><br><span class=\"line\">Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；</span><br><span class=\"line\">Cache-Control: public max-age=3600 s-maxage=7200 </span><br><span class=\"line\">//本地缓存 1 小时，CDN 上缓存 2 小时；</span><br><span class=\"line\">Cache-Control: public max-age=3600 proxy-revalidate  </span><br><span class=\"line\">//本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源</span><br></pre></td></tr></table></figure>\n\n    </li>\n</ol>\n\n<p></p><h4>其他</h4><p></p>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：<a href=\"https://www.cnblogs.com/yingsong/p/6170780.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yingsong/p/6170780.html</a></p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：<a href=\"https://www.cnblogs.com/softidea/p/5308489.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/softidea/p/5308489.html</a></p>\n    </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》</p>","more":"<p></p><h4>JavaScript篇</h4><p></p>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<p></p><h4>css篇</h4><p></p>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<p></p><h4>网络篇</h4><p></p>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；</span><br><span class=\"line\">Cache-Control: private immutable </span><br><span class=\"line\">//不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；</span><br><span class=\"line\">Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；</span><br><span class=\"line\">Cache-Control: public max-age=3600 s-maxage=7200 </span><br><span class=\"line\">//本地缓存 1 小时，CDN 上缓存 2 小时；</span><br><span class=\"line\">Cache-Control: public max-age=3600 proxy-revalidate  </span><br><span class=\"line\">//本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源</span><br></pre></td></tr></table></figure>\n\n    </li>\n</ol>\n\n<p></p><h4>其他</h4><p></p>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：<a href=\"https://www.cnblogs.com/yingsong/p/6170780.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yingsong/p/6170780.html</a></p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：<a href=\"https://www.cnblogs.com/softidea/p/5308489.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/softidea/p/5308489.html</a></p>\n    </li>\n</ol>"},{"title":"UNIX编程艺术","date":"2021-01-06T06:54:57.000Z","_content":"\n<p>孔子云：\"取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣\"。</p>\n","source":"_posts/架构/UNIX编程艺术.md","raw":"---\ntitle: UNIX编程艺术\ndate: 2021-01-06 14:54:57\ncategories: 架构\ntags: 架构\n---\n\n<p>孔子云：\"取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣\"。</p>\n","slug":"架构/UNIX编程艺术","published":1,"updated":"2021-01-09T14:28:41.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kh003gvbxxy8cwt7v8","content":"<p>孔子云：”取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>孔子云：”取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。</p>\n"},{"title":"前端跨域解决方案","date":"2021-01-01T05:42:52.000Z","_content":"\n<p>浏览器同源策略：协议、域名、端口都相同触发同源策略限制。</p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>document.domain + iframe跨域</p>\n    \n  </li>\n  <li>\n    <p>location.hash + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.name + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.postMessage跨域</p>\n\n  </li>\n  <li>\n    <p>JSONP跨域</p>\n\n  </li>\n  <li>\n    <p>CORS跨域资源共享</p>\n  </li>\n  <li>\n    <p>Nginx代理跨域</p>\n  </li>\n  <li>\n    <p>Node代理跨域</p>\n  </li>\n  <li>\n    <p>WebSocket跨域</p>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>https://juejin.cn/post/6850037265595858952#heading-23</li>\n</ol>","source":"_posts/总结/前端跨域解决方案.md","raw":"---\ntitle: 前端跨域解决方案\ndate: 2021-01-01 13:42:52\ntags:\ncategories: 总结\n---\n\n<p>浏览器同源策略：协议、域名、端口都相同触发同源策略限制。</p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>document.domain + iframe跨域</p>\n    \n  </li>\n  <li>\n    <p>location.hash + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.name + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.postMessage跨域</p>\n\n  </li>\n  <li>\n    <p>JSONP跨域</p>\n\n  </li>\n  <li>\n    <p>CORS跨域资源共享</p>\n  </li>\n  <li>\n    <p>Nginx代理跨域</p>\n  </li>\n  <li>\n    <p>Node代理跨域</p>\n  </li>\n  <li>\n    <p>WebSocket跨域</p>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>https://juejin.cn/post/6850037265595858952#heading-23</li>\n</ol>","slug":"总结/前端跨域解决方案","published":1,"updated":"2021-01-19T16:55:10.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ki003kvbxx5yj6wev6","content":"<p>浏览器同源策略：协议、域名、端口都相同触发同源策略限制。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>\n    <p>document.domain + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>location.hash + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.name + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.postMessage跨域</p>\n\n  </li>\n  <li>\n    <p>JSONP跨域</p>\n\n  </li>\n  <li>\n    <p>CORS跨域资源共享</p>\n  </li>\n  <li>\n    <p>Nginx代理跨域</p>\n  </li>\n  <li>\n    <p>Node代理跨域</p>\n  </li>\n  <li>\n    <p>WebSocket跨域</p>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6850037265595858952#heading-23\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6850037265595858952#heading-23</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>浏览器同源策略：协议、域名、端口都相同触发同源策略限制。</p>","more":"<ol>\n  <li>\n    <p>document.domain + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>location.hash + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.name + iframe跨域</p>\n\n  </li>\n  <li>\n    <p>window.postMessage跨域</p>\n\n  </li>\n  <li>\n    <p>JSONP跨域</p>\n\n  </li>\n  <li>\n    <p>CORS跨域资源共享</p>\n  </li>\n  <li>\n    <p>Nginx代理跨域</p>\n  </li>\n  <li>\n    <p>Node代理跨域</p>\n  </li>\n  <li>\n    <p>WebSocket跨域</p>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6850037265595858952#heading-23\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6850037265595858952#heading-23</a></li>\n</ol>"},{"title":"Chrome架构","date":"2020-04-02T06:01:04.000Z","_content":"\n<ul>\n  <li>进程线程：https://cloud.tencent.com/developer/news/414508</li>\n</ul>\n","source":"_posts/架构/Chrome架构.md","raw":"---\ntitle: Chrome架构\ndate: 2020-04-02 14:01:04\ncategories: 架构\ntags: 架构\n---\n\n<ul>\n  <li>进程线程：https://cloud.tencent.com/developer/news/414508</li>\n</ul>\n","slug":"架构/Chrome架构","published":1,"updated":"2021-01-01T05:31:31.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kj003nvbxxj983fcc7","content":"<ul>\n  <li>进程线程：<a href=\"https://cloud.tencent.com/developer/news/414508\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/414508</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n  <li>进程线程：<a href=\"https://cloud.tencent.com/developer/news/414508\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/414508</a></li>\n</ul>\n"},{"title":"无服务器架构","date":"2020-02-18T04:42:11.000Z","_content":"\n无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。\n\n千万级流量业务的Serverless实践，看FaaS给前端带来的变化：https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\n\n深入理解无服务器架构(Faas/Serverless)：https://blog.csdn.net/xialingming/article/details/81369624\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</li>\n</ol>\n\n\n","source":"_posts/架构/无服务器架构.md","raw":"---\ntitle: 无服务器架构\ndate: 2020-02-18 12:42:11\ncategories: 架构\ntags: 架构\n---\n\n无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。\n\n千万级流量业务的Serverless实践，看FaaS给前端带来的变化：https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\n\n深入理解无服务器架构(Faas/Serverless)：https://blog.csdn.net/xialingming/article/details/81369624\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</li>\n</ol>\n\n\n","slug":"架构/无服务器架构","published":1,"updated":"2021-01-15T21:25:09.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kj003qvbxxdhakf3r3","content":"<p>无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。</p>\n<p>千万级流量业务的Serverless实践，看FaaS给前端带来的变化：<a href=\"https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q</a></p>\n<p>深入理解无服务器架构(Faas/Serverless)：<a href=\"https://blog.csdn.net/xialingming/article/details/81369624\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xialingming/article/details/81369624</a></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</a></li>\n</ol>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。</p>\n<p>千万级流量业务的Serverless实践，看FaaS给前端带来的变化：<a href=\"https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q</a></p>\n<p>深入理解无服务器架构(Faas/Serverless)：<a href=\"https://blog.csdn.net/xialingming/article/details/81369624\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xialingming/article/details/81369624</a></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</a></li>\n</ol>\n\n\n"},{"title":"使用Hexo+Github搭建属于自己的blog","date":"2019-02-18T14:24:22.000Z","toc":true,"_content":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<!-- more -->\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p>主要参考文章有：</p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\"  target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p>优化</p>\n<ul>\n    <li>热更新：https://github.com/hexojs/hexo-browsersync</li>\n</ul>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<h4>常用命令</h4>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new \"postName\" #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<h4>配置文件</h4>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<h4>Questions</h4>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题<p>\n        <p>只需要在_config.yml里增加如下配置即可</p>\n        ```\n        marked:\n            breaks: false\n        ```\n        <p>参考：http://1900.live/rep-hexo-marked/<p>\n    </li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：https://www.jianshu.com/p/366ff564a8f2</p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：https://segmentfault.com/a/1190000016267344</p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","source":"_posts/总结/使用Hexo-Github搭建属于自己的blog.md","raw":"---\ntitle: 使用Hexo+Github搭建属于自己的blog\ndate: 2019-02-18 22:24:22\ntoc: true\ncategories: 总结\ntags:\n---\n<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<!-- more -->\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p>主要参考文章有：</p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\"  target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p>优化</p>\n<ul>\n    <li>热更新：https://github.com/hexojs/hexo-browsersync</li>\n</ul>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<h4>常用命令</h4>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new \"postName\" #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<h4>配置文件</h4>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<h4>Questions</h4>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题<p>\n        <p>只需要在_config.yml里增加如下配置即可</p>\n        ```\n        marked:\n            breaks: false\n        ```\n        <p>参考：http://1900.live/rep-hexo-marked/<p>\n    </li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：https://www.jianshu.com/p/366ff564a8f2</p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：https://segmentfault.com/a/1190000016267344</p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","slug":"总结/使用Hexo-Github搭建属于自己的blog","published":1,"updated":"2020-12-21T13:23:45.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kk003uvbxxbbi2dxdq","content":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<a id=\"more\"></a>\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p></p><p>主要参考文章有：</p><p></p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\" target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p></p><p>优化</p><p></p>\n<ul>\n    <li>热更新：<a href=\"https://github.com/hexojs/hexo-browsersync\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo-browsersync</a></li>\n</ul>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><h4>常用命令</h4><p></p>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new “postName” #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<p></p><h4>配置文件</h4><p></p>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<p></p><h4>Questions</h4><p></p>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题</p><p>\n        </p><p>只需要在_config.yml里增加如下配置即可</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">    breaks: false</span><br></pre></td></tr></table></figure>\n\n        <p>参考：<a href=\"http://1900.live/rep-hexo-marked/\" target=\"_blank\" rel=\"noopener\">http://1900.live/rep-hexo-marked/</a></p><p>\n    </p></li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：<a href=\"https://www.jianshu.com/p/366ff564a8f2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/366ff564a8f2</a></p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：<a href=\"https://segmentfault.com/a/1190000016267344\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016267344</a></p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","site":{"data":{}},"excerpt":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>","more":"<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p></p><p>主要参考文章有：</p><p></p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\" target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p></p><p>优化</p><p></p>\n<ul>\n    <li>热更新：<a href=\"https://github.com/hexojs/hexo-browsersync\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo-browsersync</a></li>\n</ul>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><h4>常用命令</h4><p></p>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new “postName” #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<p></p><h4>配置文件</h4><p></p>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<p></p><h4>Questions</h4><p></p>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题</p><p>\n        </p><p>只需要在_config.yml里增加如下配置即可</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">    breaks: false</span><br></pre></td></tr></table></figure>\n\n        <p>参考：<a href=\"http://1900.live/rep-hexo-marked/\" target=\"_blank\" rel=\"noopener\">http://1900.live/rep-hexo-marked/</a></p><p>\n    </p></li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：<a href=\"https://www.jianshu.com/p/366ff564a8f2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/366ff564a8f2</a></p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：<a href=\"https://segmentfault.com/a/1190000016267344\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016267344</a></p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>"},{"title":"从零搭建vue/react项目","date":"2021-01-16T09:24:01.000Z","_content":"\n不借助vue-cil脚手架，基于webpack+vue搭建开发环境\n\ngithub:\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<!--more-->\n\n<h4 style=\"margin-top:50px;\">具体步骤:</h4>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n\n<ol>\n  <li>React hooks: https://juejin.cn/post/6844903975838285838</li>\n</ol>","source":"_posts/框架/从零搭建vue-react项目.md","raw":"---\ntitle: 从零搭建vue/react项目\ndate: 2021-01-16 17:24:01\ntags: 框架\ncategories: 框架\n---\n\n不借助vue-cil脚手架，基于webpack+vue搭建开发环境\n\ngithub:\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<!--more-->\n\n<h4 style=\"margin-top:50px;\">具体步骤:</h4>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n\n<ol>\n  <li>React hooks: https://juejin.cn/post/6844903975838285838</li>\n</ol>","slug":"框架/从零搭建vue-react项目","published":1,"updated":"2021-01-24T13:39:17.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kl003xvbxxx555q9wc","content":"<p>不借助vue-cil脚手架，基于webpack+vue搭建开发环境</p>\n<p>github:</p>\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<a id=\"more\"></a>\n<p></p><h4 style=\"margin-top:50px;\">具体步骤:</h4><p></p>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\" target=\"_blank\" rel=\"noopener\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：<p></p>\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n\n<ol>\n  <li>React hooks: <a href=\"https://juejin.cn/post/6844903975838285838\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903975838285838</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>不借助vue-cil脚手架，基于webpack+vue搭建开发环境</p>\n<p>github:</p>\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>","more":"<p></p><h4 style=\"margin-top:50px;\">具体步骤:</h4><p></p>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\" target=\"_blank\" rel=\"noopener\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：<p></p>\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n\n<ol>\n  <li>React hooks: <a href=\"https://juejin.cn/post/6844903975838285838\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903975838285838</a></li>\n</ol>"},{"title":"编程范式","date":"2021-01-14T09:34:19.000Z","thumbnail":"img/performance.jpg","_content":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.pt5{padding-top: 5px;}\n.content p.mb5{margin-bottom: 5px;}\n.red{color: red;}\n.bd{border: 1px solid #000}\n.pd{padding: 5px}\n</style>\n\n<p>基本思想：将程序分别抽象分解为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式。泛型式核心是抽象出算法后与数据分解。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    命令范式:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        其世界观是：程序由若干行动指令组成的有序列表。\n      </p>\n      <p>\n        其方法论是：用变量来存储数据，用语句来执行指令。\n      </p>\n    </div>\n  </li>\n  <li class=\"pt\">\n    声明范式:\n    <p class=\"pt5\">\n      是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。\n    </p>\n  </li>\n  <li class=\"pt\">\n    对象范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    并发范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    泛型范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    超级范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    AOP切面范式<span class=\"red\">（多角度看问题）</span>:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        AOP将程序抽象分解为切面。宏观角度，AOP无非是<span class=\"red\">SoC(Separation of Concerns)</span>原理和<span class=\"red\">DRY(Don't repeat yourself)</span>原则的一种应用。AOP的横向方向重用弥补了OOP的不足。\n      </p>\n      <p class=\"mb5\">\n        抽象与分解的原则：<span class=\"red\">单一化、正交化</span>。每个模块职责明确专一，模块之间相互独立，即高內聚，低耦合（high cohesion & low coupling）。\n      </p>\n      <p class=\"mb5\"><span class=\"red\">正交化</span>：在数学中，互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响。</p>\n      <div class=\"bd pd\">\n        <p>举个例子：在调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。</p>\n        <p>解决思路：将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来。</p>\n        <p>例如：调用某个对象的方法前后：符合预先指定条件的接入点集合称为切入点；所有以set为命名开头的方法：每段绑定的代码称为一个建议(advice)。\n        </p>\n      </div>\n      ![切面式编程](/img/paradigm/aop.jpg)\n      <ul>\n        <li>横向关注点指与程序的<span class=\"red\">纵向主流</span>执行方向<span class=\"red\">横向正交</span>的关注焦点。</li>\n        <li>接入点是<span class=\"red\">附加行为</span>----建议(advice)的执行点，切入点(pointcut)是指定的接入点(join point)集合，这些接入点共享一段插入代码。切入点与建议组成了切面(aspect)，是模块化的横切关注点</li>\n        <li>编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。编织分<span class=\"red\">静态编织</span>和<span class=\"red\">动态编织</span>两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。</li>\n        <li>AOP的实施分3步：切面分解、切面实现和切面合成。</li>\n        <li>OOP只能<span class=\"red\">沿继承树的纵向方向</span>重用，AOP可以沿<span class=\"red\">横向方向</span>重用。</li>\n      </ul>\n    </div>\n  </li>\n  <li class=\"pt\">\n    事件驱动:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    函数范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    逻辑范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    汇总范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    情景范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>\n    <a href=\"https://mendylee.gitbooks.io/geeker-study-courses/content/ruan-jian-she-ji-pian/ruan-jian-she-ji.html\" target=\"_blank\">\n      软件设计\n    <a>\n  </li>\n  <li>\n    <a href=\"https://blog.zhenghui.org/tag/colonclass/\" target=\"_blank\">\n      冒号课堂\n    </a>\n  </li>\n</ol>\n\n<h5 style=\"margin-top:50px;\">名词注解</h5>\n<ol>\n  <li>模块化：抽象是前提，分解是方式，模块化是结果。</li>\n  <li>耦合：用来衡量模块之间的依赖程度。</li>\n  <li>内聚(cohesion)：用来衡量模块内在的关联强度。</li>\n</ol>","source":"_posts/架构/编程范式.md","raw":"---\ntitle: 编程范式\ndate: 2021-01-14 17:34:19\ncategories: 架构\ntags: 架构\nthumbnail: img/performance.jpg\n---\n<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.pt5{padding-top: 5px;}\n.content p.mb5{margin-bottom: 5px;}\n.red{color: red;}\n.bd{border: 1px solid #000}\n.pd{padding: 5px}\n</style>\n\n<p>基本思想：将程序分别抽象分解为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式。泛型式核心是抽象出算法后与数据分解。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    命令范式:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        其世界观是：程序由若干行动指令组成的有序列表。\n      </p>\n      <p>\n        其方法论是：用变量来存储数据，用语句来执行指令。\n      </p>\n    </div>\n  </li>\n  <li class=\"pt\">\n    声明范式:\n    <p class=\"pt5\">\n      是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。\n    </p>\n  </li>\n  <li class=\"pt\">\n    对象范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    并发范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    泛型范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    超级范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    AOP切面范式<span class=\"red\">（多角度看问题）</span>:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        AOP将程序抽象分解为切面。宏观角度，AOP无非是<span class=\"red\">SoC(Separation of Concerns)</span>原理和<span class=\"red\">DRY(Don't repeat yourself)</span>原则的一种应用。AOP的横向方向重用弥补了OOP的不足。\n      </p>\n      <p class=\"mb5\">\n        抽象与分解的原则：<span class=\"red\">单一化、正交化</span>。每个模块职责明确专一，模块之间相互独立，即高內聚，低耦合（high cohesion & low coupling）。\n      </p>\n      <p class=\"mb5\"><span class=\"red\">正交化</span>：在数学中，互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响。</p>\n      <div class=\"bd pd\">\n        <p>举个例子：在调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。</p>\n        <p>解决思路：将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来。</p>\n        <p>例如：调用某个对象的方法前后：符合预先指定条件的接入点集合称为切入点；所有以set为命名开头的方法：每段绑定的代码称为一个建议(advice)。\n        </p>\n      </div>\n      ![切面式编程](/img/paradigm/aop.jpg)\n      <ul>\n        <li>横向关注点指与程序的<span class=\"red\">纵向主流</span>执行方向<span class=\"red\">横向正交</span>的关注焦点。</li>\n        <li>接入点是<span class=\"red\">附加行为</span>----建议(advice)的执行点，切入点(pointcut)是指定的接入点(join point)集合，这些接入点共享一段插入代码。切入点与建议组成了切面(aspect)，是模块化的横切关注点</li>\n        <li>编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。编织分<span class=\"red\">静态编织</span>和<span class=\"red\">动态编织</span>两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。</li>\n        <li>AOP的实施分3步：切面分解、切面实现和切面合成。</li>\n        <li>OOP只能<span class=\"red\">沿继承树的纵向方向</span>重用，AOP可以沿<span class=\"red\">横向方向</span>重用。</li>\n      </ul>\n    </div>\n  </li>\n  <li class=\"pt\">\n    事件驱动:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    函数范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    逻辑范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    汇总范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    情景范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>\n    <a href=\"https://mendylee.gitbooks.io/geeker-study-courses/content/ruan-jian-she-ji-pian/ruan-jian-she-ji.html\" target=\"_blank\">\n      软件设计\n    <a>\n  </li>\n  <li>\n    <a href=\"https://blog.zhenghui.org/tag/colonclass/\" target=\"_blank\">\n      冒号课堂\n    </a>\n  </li>\n</ol>\n\n<h5 style=\"margin-top:50px;\">名词注解</h5>\n<ol>\n  <li>模块化：抽象是前提，分解是方式，模块化是结果。</li>\n  <li>耦合：用来衡量模块之间的依赖程度。</li>\n  <li>内聚(cohesion)：用来衡量模块内在的关联强度。</li>\n</ol>","slug":"架构/编程范式","published":1,"updated":"2021-01-17T18:31:35.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3km0041vbxx7ycw0mwt","content":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.pt5{padding-top: 5px;}\n.content p.mb5{margin-bottom: 5px;}\n.red{color: red;}\n.bd{border: 1px solid #000}\n.pd{padding: 5px}\n</style>\n\n<p>基本思想：将程序分别抽象分解为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式。泛型式核心是抽象出算法后与数据分解。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li class=\"pt\">\n    命令范式:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        其世界观是：程序由若干行动指令组成的有序列表。\n      </p>\n      <p>\n        其方法论是：用变量来存储数据，用语句来执行指令。\n      </p>\n    </div>\n  </li>\n  <li class=\"pt\">\n    声明范式:\n    <p class=\"pt5\">\n      是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。\n    </p>\n  </li>\n  <li class=\"pt\">\n    对象范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    并发范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    泛型范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    超级范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    AOP切面范式<span class=\"red\">（多角度看问题）</span>:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        AOP将程序抽象分解为切面。宏观角度，AOP无非是<span class=\"red\">SoC(Separation of Concerns)</span>原理和<span class=\"red\">DRY(Don’t repeat yourself)</span>原则的一种应用。AOP的横向方向重用弥补了OOP的不足。\n      </p>\n      <p class=\"mb5\">\n        抽象与分解的原则：<span class=\"red\">单一化、正交化</span>。每个模块职责明确专一，模块之间相互独立，即高內聚，低耦合（high cohesion &amp; low coupling）。\n      </p>\n      <p class=\"mb5\"><span class=\"red\">正交化</span>：在数学中，互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响。</p>\n      <div class=\"bd pd\">\n        <p>举个例子：在调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。</p>\n        <p>解决思路：将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来。</p>\n        <p>例如：调用某个对象的方法前后：符合预先指定条件的接入点集合称为切入点；所有以set为命名开头的方法：每段绑定的代码称为一个建议(advice)。\n        </p>\n      </div>\n      <img src=\"/img/paradigm/aop.jpg\" alt=\"切面式编程\">\n      <ul>\n        <li>横向关注点指与程序的<span class=\"red\">纵向主流</span>执行方向<span class=\"red\">横向正交</span>的关注焦点。</li>\n        <li>接入点是<span class=\"red\">附加行为</span>—-建议(advice)的执行点，切入点(pointcut)是指定的接入点(join point)集合，这些接入点共享一段插入代码。切入点与建议组成了切面(aspect)，是模块化的横切关注点</li>\n        <li>编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。编织分<span class=\"red\">静态编织</span>和<span class=\"red\">动态编织</span>两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。</li>\n        <li>AOP的实施分3步：切面分解、切面实现和切面合成。</li>\n        <li>OOP只能<span class=\"red\">沿继承树的纵向方向</span>重用，AOP可以沿<span class=\"red\">横向方向</span>重用。</li>\n      </ul>\n    </div>\n  </li>\n  <li class=\"pt\">\n    事件驱动:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    函数范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    逻辑范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    汇总范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    情景范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li>\n    <a href=\"https://mendylee.gitbooks.io/geeker-study-courses/content/ruan-jian-she-ji-pian/ruan-jian-she-ji.html\" target=\"_blank\">\n      软件设计\n    <a>\n  </a></a></li>\n  <li>\n    <a href=\"https://blog.zhenghui.org/tag/colonclass/\" target=\"_blank\">\n      冒号课堂\n    </a>\n  </li>\n</ol>\n\n<p></p><h5 style=\"margin-top:50px;\">名词注解</h5><p></p>\n<ol>\n  <li>模块化：抽象是前提，分解是方式，模块化是结果。</li>\n  <li>耦合：用来衡量模块之间的依赖程度。</li>\n  <li>内聚(cohesion)：用来衡量模块内在的关联强度。</li>\n</ol>","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.pt5{padding-top: 5px;}\n.content p.mb5{margin-bottom: 5px;}\n.red{color: red;}\n.bd{border: 1px solid #000}\n.pd{padding: 5px}\n</style>\n\n<p>基本思想：将程序分别抽象分解为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式。泛型式核心是抽象出算法后与数据分解。</p>","more":"<ol>\n  <li class=\"pt\">\n    命令范式:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        其世界观是：程序由若干行动指令组成的有序列表。\n      </p>\n      <p>\n        其方法论是：用变量来存储数据，用语句来执行指令。\n      </p>\n    </div>\n  </li>\n  <li class=\"pt\">\n    声明范式:\n    <p class=\"pt5\">\n      是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。\n    </p>\n  </li>\n  <li class=\"pt\">\n    对象范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    并发范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    泛型范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    超级范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    AOP切面范式<span class=\"red\">（多角度看问题）</span>:\n    <div class=\"pt\">\n      <p class=\"mb5\">\n        AOP将程序抽象分解为切面。宏观角度，AOP无非是<span class=\"red\">SoC(Separation of Concerns)</span>原理和<span class=\"red\">DRY(Don’t repeat yourself)</span>原则的一种应用。AOP的横向方向重用弥补了OOP的不足。\n      </p>\n      <p class=\"mb5\">\n        抽象与分解的原则：<span class=\"red\">单一化、正交化</span>。每个模块职责明确专一，模块之间相互独立，即高內聚，低耦合（high cohesion &amp; low coupling）。\n      </p>\n      <p class=\"mb5\"><span class=\"red\">正交化</span>：在数学中，互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响。</p>\n      <div class=\"bd pd\">\n        <p>举个例子：在调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。</p>\n        <p>解决思路：将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来。</p>\n        <p>例如：调用某个对象的方法前后：符合预先指定条件的接入点集合称为切入点；所有以set为命名开头的方法：每段绑定的代码称为一个建议(advice)。\n        </p>\n      </div>\n      <img src=\"/img/paradigm/aop.jpg\" alt=\"切面式编程\">\n      <ul>\n        <li>横向关注点指与程序的<span class=\"red\">纵向主流</span>执行方向<span class=\"red\">横向正交</span>的关注焦点。</li>\n        <li>接入点是<span class=\"red\">附加行为</span>—-建议(advice)的执行点，切入点(pointcut)是指定的接入点(join point)集合，这些接入点共享一段插入代码。切入点与建议组成了切面(aspect)，是模块化的横切关注点</li>\n        <li>编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。编织分<span class=\"red\">静态编织</span>和<span class=\"red\">动态编织</span>两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。</li>\n        <li>AOP的实施分3步：切面分解、切面实现和切面合成。</li>\n        <li>OOP只能<span class=\"red\">沿继承树的纵向方向</span>重用，AOP可以沿<span class=\"red\">横向方向</span>重用。</li>\n      </ul>\n    </div>\n  </li>\n  <li class=\"pt\">\n    事件驱动:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    函数范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    逻辑范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    汇总范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n  <li class=\"pt\">\n    情景范式:\n    <p class=\"pt5\">\n    </p>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li>\n    <a href=\"https://mendylee.gitbooks.io/geeker-study-courses/content/ruan-jian-she-ji-pian/ruan-jian-she-ji.html\" target=\"_blank\">\n      软件设计\n    <a>\n  </a></a></li>\n  <li>\n    <a href=\"https://blog.zhenghui.org/tag/colonclass/\" target=\"_blank\">\n      冒号课堂\n    </a>\n  </li>\n</ol>\n\n<p></p><h5 style=\"margin-top:50px;\">名词注解</h5><p></p>\n<ol>\n  <li>模块化：抽象是前提，分解是方式，模块化是结果。</li>\n  <li>耦合：用来衡量模块之间的依赖程度。</li>\n  <li>内聚(cohesion)：用来衡量模块内在的关联强度。</li>\n</ol>"},{"title":"Vue问题总结","date":"2019-10-28T15:09:34.000Z","_content":"\n<p>常见问题总结</p>\n\n<!-- more -->\n\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    ```\n    props: {\n      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n      propA: Number,\n      // 多个可能的类型\n      propB: [String, Number],\n      // 必填的字符串\n      propC: {\n        type: String,\n        required: true\n      },\n      // 带有默认值的数字\n      propD: {\n        type: Number,\n        default: 100\n      },\n      // 带有默认值的对象\n      propE: {\n        type: Object,\n        // 对象或数组默认值必须从一个工厂函数获取\n        default: function () {\n          return { message: 'hello' }\n        }\n      },\n      // 自定义验证函数\n      propF: {\n        validator: function (value) {\n          // 这个值必须匹配下列字符串中的一个\n          return ['success', 'warning', 'danger'].indexOf(value) !== -1\n        }\n      }\n    }\n    ```\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    ![vue生命周期执行过程](/img/execute.png)\n  </li>\n</ol>\n","source":"_posts/框架/Vue问题总结.md","raw":"---\ntitle: Vue问题总结\ndate: 2019-10-28 23:09:34\ntags: 框架\ncategories: 框架\n---\n\n<p>常见问题总结</p>\n\n<!-- more -->\n\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    ```\n    props: {\n      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n      propA: Number,\n      // 多个可能的类型\n      propB: [String, Number],\n      // 必填的字符串\n      propC: {\n        type: String,\n        required: true\n      },\n      // 带有默认值的数字\n      propD: {\n        type: Number,\n        default: 100\n      },\n      // 带有默认值的对象\n      propE: {\n        type: Object,\n        // 对象或数组默认值必须从一个工厂函数获取\n        default: function () {\n          return { message: 'hello' }\n        }\n      },\n      // 自定义验证函数\n      propF: {\n        validator: function (value) {\n          // 这个值必须匹配下列字符串中的一个\n          return ['success', 'warning', 'danger'].indexOf(value) !== -1\n        }\n      }\n    }\n    ```\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    ![vue生命周期执行过程](/img/execute.png)\n  </li>\n</ol>\n","slug":"框架/Vue问题总结","published":1,"updated":"2021-01-15T20:14:26.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kn0045vbxxge8yid2x","content":"<p>常见问题总结</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class=\"line\">  propA: Number,</span><br><span class=\"line\">  // 多个可能的类型</span><br><span class=\"line\">  propB: [String, Number],</span><br><span class=\"line\">  // 必填的字符串</span><br><span class=\"line\">  propC: &#123;</span><br><span class=\"line\">    type: String,</span><br><span class=\"line\">    required: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的数字</span><br><span class=\"line\">  propD: &#123;</span><br><span class=\"line\">    type: Number,</span><br><span class=\"line\">    default: 100</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的对象</span><br><span class=\"line\">  propE: &#123;</span><br><span class=\"line\">    type: Object,</span><br><span class=\"line\">    // 对象或数组默认值必须从一个工厂函数获取</span><br><span class=\"line\">    default: function () &#123;</span><br><span class=\"line\">      return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 自定义验证函数</span><br><span class=\"line\">  propF: &#123;</span><br><span class=\"line\">    validator: function (value) &#123;</span><br><span class=\"line\">      // 这个值必须匹配下列字符串中的一个</span><br><span class=\"line\">      return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    <img src=\"/img/execute.png\" alt=\"vue生命周期执行过程\">\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>常见问题总结</p>","more":"<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class=\"line\">  propA: Number,</span><br><span class=\"line\">  // 多个可能的类型</span><br><span class=\"line\">  propB: [String, Number],</span><br><span class=\"line\">  // 必填的字符串</span><br><span class=\"line\">  propC: &#123;</span><br><span class=\"line\">    type: String,</span><br><span class=\"line\">    required: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的数字</span><br><span class=\"line\">  propD: &#123;</span><br><span class=\"line\">    type: Number,</span><br><span class=\"line\">    default: 100</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的对象</span><br><span class=\"line\">  propE: &#123;</span><br><span class=\"line\">    type: Object,</span><br><span class=\"line\">    // 对象或数组默认值必须从一个工厂函数获取</span><br><span class=\"line\">    default: function () &#123;</span><br><span class=\"line\">      return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 自定义验证函数</span><br><span class=\"line\">  propF: &#123;</span><br><span class=\"line\">    validator: function (value) &#123;</span><br><span class=\"line\">      // 这个值必须匹配下列字符串中的一个</span><br><span class=\"line\">      return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    <img src=\"/img/execute.png\" alt=\"vue生命周期执行过程\">\n  </li>\n</ol>"},{"title":"「vue-router源码」页面问题：菜单路由连续点击无响应","date":"2021-01-15T03:10:56.000Z","_content":"\n<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<!-- more -->\n\n![控制台报错信息](/img/vuerouter/error.png)\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 -- promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p>触发该报错信息条件：</p>\n```\n// in the case the route map has been dynamically appended to\n```\n![触发条件-vuerouter源码](/img/vuerouter/samerouter.png)\n\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\nmatched机制说明：\n<ol>\n  <li>matched的map源码实现：\n  ![matched-vuerouter源码](/img/vuerouter/matched.png)</li>\n</ol>\n","source":"_posts/框架/菜单路由连续点击无响应.md","raw":"---\ntitle: 「vue-router源码」页面问题：菜单路由连续点击无响应\ndate: 2021-01-15 11:10:56\ntags: 框架\ncategories: 框架\n---\n\n<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<!-- more -->\n\n![控制台报错信息](/img/vuerouter/error.png)\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 -- promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p>触发该报错信息条件：</p>\n```\n// in the case the route map has been dynamically appended to\n```\n![触发条件-vuerouter源码](/img/vuerouter/samerouter.png)\n\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\nmatched机制说明：\n<ol>\n  <li>matched的map源码实现：\n  ![matched-vuerouter源码](/img/vuerouter/matched.png)</li>\n</ol>\n","slug":"框架/菜单路由连续点击无响应","published":1,"updated":"2021-01-15T21:56:49.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ko0049vbxxdc93maq9","content":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<a id=\"more\"></a>\n\n<img src=\"/img/vuerouter/error.png\" alt=\"控制台报错信息\">\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 – promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p></p><p>触发该报错信息条件：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// in the case the route map has been dynamically appended to</span><br></pre></td></tr></table></figure><p></p>\n<p><img src=\"/img/vuerouter/samerouter.png\" alt=\"触发条件-vuerouter源码\"></p>\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\nmatched机制说明：<p></p>\n<ol>\n  <li>matched的map源码实现：\n  <img src=\"/img/vuerouter/matched.png\" alt=\"matched-vuerouter源码\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>","more":"<img src=\"/img/vuerouter/error.png\" alt=\"控制台报错信息\">\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 – promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p></p><p>触发该报错信息条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// in the case the route map has been dynamically appended to</span><br></pre></td></tr></table></figure><p></p>\n<p><img src=\"/img/vuerouter/samerouter.png\" alt=\"触发条件-vuerouter源码\"></p>\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\nmatched机制说明：<p></p>\n<ol>\n  <li>matched的map源码实现：\n  <img src=\"/img/vuerouter/matched.png\" alt=\"matched-vuerouter源码\"></li>\n</ol>"},{"title":"骨架屏","date":"2019-04-26T11:56:38.000Z","thumbnail":"img/flower.jpg","_content":"骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<!-- more -->\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> -->\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：https://github.com/egoist/vue-content-loader</p>\n","source":"_posts/框架/骨架屏.md","raw":"---\ntitle: 骨架屏\ndate: 2019-04-26 19:56:38\ntags: 框架\ncategories: 框架\nthumbnail: img/flower.jpg\n---\n骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<!-- more -->\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> -->\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：https://github.com/egoist/vue-content-loader</p>\n","slug":"框架/骨架屏","published":1,"updated":"2021-01-01T05:31:40.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kp004cvbxxmpjo4u7i","content":"<p>骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<a id=\"more\"></a>\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> --></p>\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：<a href=\"https://github.com/egoist/vue-content-loader\" target=\"_blank\" rel=\"noopener\">https://github.com/egoist/vue-content-loader</a></p>\n","site":{"data":{}},"excerpt":"<p>骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。</p>","more":"<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> --></p>\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：<a href=\"https://github.com/egoist/vue-content-loader\" target=\"_blank\" rel=\"noopener\">https://github.com/egoist/vue-content-loader</a></p>"},{"title":"浏览器中的EventLoop","date":"2019-09-30T03:37:05.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://www.ruanyifeng.com/blog/2014/10/event-loop.html</li>\n  <li>https://wangdoc.com/javascript/events/model.html</li>\n</ol>\n","source":"_posts/浏览器/浏览器中的EventLoop.md","raw":"---\ntitle: 浏览器中的EventLoop\ndate: 2019-09-30 11:37:05\ntags: 浏览器\ncategories: 浏览器\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://www.ruanyifeng.com/blog/2014/10/event-loop.html</li>\n  <li>https://wangdoc.com/javascript/events/model.html</li>\n</ol>\n","slug":"浏览器/浏览器中的EventLoop","published":1,"updated":"2021-01-01T05:32:06.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kq004hvbxxyrxfo100","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>\n  <li><a href=\"https://wangdoc.com/javascript/events/model.html\" target=\"_blank\" rel=\"noopener\">https://wangdoc.com/javascript/events/model.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>\n  <li><a href=\"https://wangdoc.com/javascript/events/model.html\" target=\"_blank\" rel=\"noopener\">https://wangdoc.com/javascript/events/model.html</a></li>\n</ol>\n"},{"title":"「chromium源码解读」浏览器事件机制","date":"2021-01-14T18:33:56.000Z","_content":"\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    ![事件模型](/img/chrome/eventmodel.jpg)\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    ![订阅-发布源码](/img/chrome/soucecode.jpg)\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    ![事件处理过程](/img/chrome/procedure.jpg)\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    ![DOM事件流](/img/chrome/eventflow.jpg)\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    ![addEventListener](/img/chrome/addEventListener.jpg)\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    ![事件模型](/img/chrome/observer.jpg)\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>源码解析：https://zhuanlan.zhihu.com/p/25095179</li>\n</ol>\n","source":"_posts/浏览器/浏览器事件机制.md","raw":"---\ntitle: 「chromium源码解读」浏览器事件机制\ndate: 2021-01-15 02:33:56\ntags: 浏览器\ncategories: 浏览器\n---\n\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    ![事件模型](/img/chrome/eventmodel.jpg)\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    ![订阅-发布源码](/img/chrome/soucecode.jpg)\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    ![事件处理过程](/img/chrome/procedure.jpg)\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    ![DOM事件流](/img/chrome/eventflow.jpg)\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    ![addEventListener](/img/chrome/addEventListener.jpg)\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    ![事件模型](/img/chrome/observer.jpg)\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>源码解析：https://zhuanlan.zhihu.com/p/25095179</li>\n</ol>\n","slug":"浏览器/浏览器事件机制","published":1,"updated":"2021-01-17T15:44:21.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kr004kvbxxz3astksi","content":"<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    <img src=\"/img/chrome/eventmodel.jpg\" alt=\"事件模型\">\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    <img src=\"/img/chrome/soucecode.jpg\" alt=\"订阅-发布源码\">\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    <img src=\"/img/chrome/procedure.jpg\" alt=\"事件处理过程\">\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    <img src=\"/img/chrome/eventflow.jpg\" alt=\"DOM事件流\">\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    <img src=\"/img/chrome/addEventListener.jpg\" alt=\"addEventListener\">\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    <img src=\"/img/chrome/observer.jpg\" alt=\"事件模型\">\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li>源码解析：<a href=\"https://zhuanlan.zhihu.com/p/25095179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25095179</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>","more":"<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    <img src=\"/img/chrome/eventmodel.jpg\" alt=\"事件模型\">\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    <img src=\"/img/chrome/soucecode.jpg\" alt=\"订阅-发布源码\">\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    <img src=\"/img/chrome/procedure.jpg\" alt=\"事件处理过程\">\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    <img src=\"/img/chrome/eventflow.jpg\" alt=\"DOM事件流\">\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    <img src=\"/img/chrome/addEventListener.jpg\" alt=\"addEventListener\">\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    <img src=\"/img/chrome/observer.jpg\" alt=\"事件模型\">\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li>源码解析：<a href=\"https://zhuanlan.zhihu.com/p/25095179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25095179</a></li>\n</ol>"},{"title":"UML类图与交互图","date":"2019-08-09T07:10:40.000Z","_content":"<p>总结UML类图与交互图相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\nhttps://www.jianshu.com/p/08015c0ca2f1","source":"_posts/程序设计/UML类图与交互图.md","raw":"---\ntitle: UML类图与交互图\ndate: 2019-08-09 15:10:40\ntags: 程序设计\ncategories: 程序设计\n---\n<p>总结UML类图与交互图相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\nhttps://www.jianshu.com/p/08015c0ca2f1","slug":"程序设计/UML类图与交互图","published":1,"updated":"2021-01-01T11:25:14.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ks004pvbxxneqqsnsg","content":"<p></p><p>总结UML类图与交互图相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p><a href=\"https://www.jianshu.com/p/08015c0ca2f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08015c0ca2f1</a></p>\n","site":{"data":{}},"excerpt":"<p></p><p>总结UML类图与交互图相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p><a href=\"https://www.jianshu.com/p/08015c0ca2f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08015c0ca2f1</a></p>"},{"title":"浏览器缓存机制","date":"2019-09-30T08:55:50.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://bbs.qcloud.com/thread-3775-1-1.html</li>\n  <li>https://www.jb51.net/article/51951.htm</li>\n  <li>https://segmentfault.com/a/1190000016265991</li>\n  <li>https://juejin.im/entry/5ad86c16f265da505a77dca4</li>\n</ol>\n","source":"_posts/浏览器/浏览器缓存机制.md","raw":"---\ntitle: 浏览器缓存机制\ndate: 2019-09-30 16:55:50\ntags: 浏览器\ncategories: 浏览器\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://bbs.qcloud.com/thread-3775-1-1.html</li>\n  <li>https://www.jb51.net/article/51951.htm</li>\n  <li>https://segmentfault.com/a/1190000016265991</li>\n  <li>https://juejin.im/entry/5ad86c16f265da505a77dca4</li>\n</ol>\n","slug":"浏览器/浏览器缓存机制","published":1,"updated":"2021-01-01T05:31:57.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kt004rvbxx4vbaipr1","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://bbs.qcloud.com/thread-3775-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.qcloud.com/thread-3775-1-1.html</a></li>\n  <li><a href=\"https://www.jb51.net/article/51951.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/51951.htm</a></li>\n  <li><a href=\"https://segmentfault.com/a/1190000016265991\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016265991</a></li>\n  <li><a href=\"https://juejin.im/entry/5ad86c16f265da505a77dca4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad86c16f265da505a77dca4</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://bbs.qcloud.com/thread-3775-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.qcloud.com/thread-3775-1-1.html</a></li>\n  <li><a href=\"https://www.jb51.net/article/51951.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/51951.htm</a></li>\n  <li><a href=\"https://segmentfault.com/a/1190000016265991\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016265991</a></li>\n  <li><a href=\"https://juejin.im/entry/5ad86c16f265da505a77dca4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad86c16f265da505a77dca4</a></li>\n</ol>\n"},{"title":"web安全","date":"2019-10-10T10:54:05.000Z","toc":true,"_content":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: https://baike.baidu.com/item/WAF</p>\n\n","source":"_posts/网络安全/web安全.md","raw":"---\ntitle: web安全\ndate: 2019-10-10 18:54:05\ntoc: true\ncategories: 网络安全\n---\n<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: https://baike.baidu.com/item/WAF</p>\n\n","slug":"网络安全/web安全","published":1,"updated":"2021-01-01T05:32:28.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kt004uvbxxiavf0fbi","content":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: <a href=\"https://baike.baidu.com/item/WAF\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/WAF</a></p>\n\n","site":{"data":{}},"excerpt":"","more":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: <a href=\"https://baike.baidu.com/item/WAF\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/WAF</a></p>\n\n"},{"title":"进程与线程","date":"2020-03-20T19:23:55.000Z","_content":"\n巩固补充一波基础知识\n<!-- more -->\n\n进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。\n\n\n","source":"_posts/计算机基础/进程与线程.md","raw":"---\ntitle: 进程与线程\ndate: 2020-03-21 03:23:55\ncategories: 计算机基础\n---\n\n巩固补充一波基础知识\n<!-- more -->\n\n进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。\n\n\n","slug":"计算机基础/进程与线程","published":1,"updated":"2021-01-01T05:31:15.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3ku004xvbxxbv397wo9","content":"<p>巩固补充一波基础知识\n<a id=\"more\"></a></p>\n<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>\n","site":{"data":{}},"excerpt":"<p>巩固补充一波基础知识</p>","more":"</p>\n<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>"},{"title":"前端脚手架","date":"2021-01-01T07:50:17.000Z","_content":"\n<p>工具封装，组件封装，网络请求库封装。</p>\n<!-- more -->\n\n","source":"_posts/脚手架/前端脚手架.md","raw":"---\ntitle: 前端脚手架\ndate: 2021-01-01 15:50:17\ntags: 脚手架\ncategories: 脚手架\n---\n\n<p>工具封装，组件封装，网络请求库封装。</p>\n<!-- more -->\n\n","slug":"脚手架/前端脚手架","published":1,"updated":"2021-01-15T21:25:02.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kv0051vbxx9782jmkq","content":"<p></p><p>工具封装，组件封装，网络请求库封装。</p>\n<a id=\"more\"></a><p></p>\n","site":{"data":{}},"excerpt":"<p></p><p>工具封装，组件封装，网络请求库封装。</p>","more":"<p></p>"},{"title":"网络传输模型","date":"2020-12-21T16:06:09.000Z","_content":"<p>简述网络传输过程。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    ![OSI七层参考模型](/img/network/osi.png)\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    ![TCP/IP五层模型](/img/network/tcp.png)\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</li>\n</ol>\n","source":"_posts/计算机网络/网络传输模型.md","raw":"---\ntitle: 网络传输模型\ndate: 2020-12-22 00:06:09\ntags: 网络知识\ncategories: 计算机网络\n---\n<p>简述网络传输过程。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    ![OSI七层参考模型](/img/network/osi.png)\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    ![TCP/IP五层模型](/img/network/tcp.png)\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</li>\n</ol>\n","slug":"计算机网络/网络传输模型","published":1,"updated":"2021-01-01T05:31:23.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kw0054vbxx4qqxgyo5","content":"<p>简述网络传输过程。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    <img src=\"/img/network/osi.png\" alt=\"OSI七层参考模型\">\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    <img src=\"/img/network/tcp.png\" alt=\"TCP/IP五层模型\">\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2\" target=\"_blank\" rel=\"noopener\">https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>简述网络传输过程。</p>","more":"<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    <img src=\"/img/network/osi.png\" alt=\"OSI七层参考模型\">\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    <img src=\"/img/network/tcp.png\" alt=\"TCP/IP五层模型\">\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2\" target=\"_blank\" rel=\"noopener\">https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</a></li>\n</ol>"},{"title":"传输协议","date":"2020-01-12T16:01:13.000Z","_content":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p>简述网络协议相关。</p>\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</ol>\n","source":"_posts/计算机网络/计算机网络.md","raw":"---\ntitle: 传输协议\ndate: 2020-1-13 00:01:13\ntags: 网络知识\ncategories: 计算机网络\n---\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p>简述网络协议相关。</p>\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</ol>\n","slug":"计算机网络/计算机网络","published":1,"updated":"2021-01-15T21:26:30.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kx0057vbxx97mdkz98","content":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p></p><p>简述网络协议相关。</p>\n<a id=\"more\"></a><p></p>\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</li></ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p></p><p>简述网络协议相关。</p>","more":"<p></p>\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</li></ol>"},{"title":"JavaScript设计模式-观察者模式","date":"2019-05-24T15:31:27.000Z","thumbnail":"img/desert.jpg","_content":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。<p>\n\n\n``` \n// 发布者\nfunction Publisher() {\n    var self = this;\n    self.dispatcher = $({});\n}\n\n// 触发send操作时，发布信息\nPublisher.prototype.send = function (){\n    var self = this\n    self.dispatcher.trigger(\"sendMessage\", [\"Yes\"]);\n}\n\n// 订阅者\nvar subscribe = new Publisher()\n\n// 订阅者获取信息\nsubscribe.dispatcher.on('sendMessage',function(data){\n    console.log(data);  // 输出“Yes”\n});\n\n// 发送信息触发\nsubscribe.send();\n\n\n```\n<h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","source":"_posts/设计模式/JavaScript设计模式-观察者模式.md","raw":"---\ntitle: JavaScript设计模式-观察者模式\ndate: 2019-05-24 23:31:27\ntags: 设计模式\ncategories: 设计模式\nthumbnail: img/desert.jpg\n---\n<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。<p>\n\n\n``` \n// 发布者\nfunction Publisher() {\n    var self = this;\n    self.dispatcher = $({});\n}\n\n// 触发send操作时，发布信息\nPublisher.prototype.send = function (){\n    var self = this\n    self.dispatcher.trigger(\"sendMessage\", [\"Yes\"]);\n}\n\n// 订阅者\nvar subscribe = new Publisher()\n\n// 订阅者获取信息\nsubscribe.dispatcher.on('sendMessage',function(data){\n    console.log(data);  // 输出“Yes”\n});\n\n// 发送信息触发\nsubscribe.send();\n\n\n```\n<h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","slug":"设计模式/JavaScript设计模式-观察者模式","published":1,"updated":"2021-01-01T05:32:17.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3kz0059vbxxvdpq67tq","content":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。</p><p>\n\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 发布者</span><br><span class=\"line\">function Publisher() &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self.dispatcher = $(&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 触发send操作时，发布信息</span><br><span class=\"line\">Publisher.prototype.send = function ()&#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    self.dispatcher.trigger(&quot;sendMessage&quot;, [&quot;Yes&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者</span><br><span class=\"line\">var subscribe = new Publisher()</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者获取信息</span><br><span class=\"line\">subscribe.dispatcher.on(&apos;sendMessage&apos;,function(data)&#123;</span><br><span class=\"line\">    console.log(data);  // 输出“Yes”</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送信息触发</span><br><span class=\"line\">subscribe.send();</span><br></pre></td></tr></table></figure>\n\n</p><h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>","more":"<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。</p><p>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 发布者</span><br><span class=\"line\">function Publisher() &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self.dispatcher = $(&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 触发send操作时，发布信息</span><br><span class=\"line\">Publisher.prototype.send = function ()&#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    self.dispatcher.trigger(&quot;sendMessage&quot;, [&quot;Yes&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者</span><br><span class=\"line\">var subscribe = new Publisher()</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者获取信息</span><br><span class=\"line\">subscribe.dispatcher.on(&apos;sendMessage&apos;,function(data)&#123;</span><br><span class=\"line\">    console.log(data);  // 输出“Yes”</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送信息触发</span><br><span class=\"line\">subscribe.send();</span><br></pre></td></tr></table></figure>\n\n</p><h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"JavaScript柯里化","date":"2021-01-12T12:04:18.000Z","_content":"\n<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<!-- more -->\n\n```\nfunction add (x, y) {\n  return (x + y)\n}\n\nconsole.log(add(1, 2))\n\nfunction curriedAdd (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nconsole.log(curriedAdd(1)(3))\nconsole.log(curriedAdd(1)(3) === 4)\n\nfunction add (x, y) {\n  return (x + y)\n}\n\nfunction currying (fn, ...args1) {\n  return function (...args2) {\n    return fn(...args1, ...args2)\n  }\n}\n\ncurrying(add, 1)\ncurrying(add, 1)(2)\n```\n\n","source":"_posts/编译原理/JavaScript柯里化.md","raw":"---\ntitle: JavaScript柯里化\ndate: 2021-01-12 20:04:18\ntags: 编译原理\ncategories: 编译原理\n---\n\n<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<!-- more -->\n\n```\nfunction add (x, y) {\n  return (x + y)\n}\n\nconsole.log(add(1, 2))\n\nfunction curriedAdd (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nconsole.log(curriedAdd(1)(3))\nconsole.log(curriedAdd(1)(3) === 4)\n\nfunction add (x, y) {\n  return (x + y)\n}\n\nfunction currying (fn, ...args1) {\n  return function (...args2) {\n    return fn(...args1, ...args2)\n  }\n}\n\ncurrying(add, 1)\ncurrying(add, 1)(2)\n```\n\n","slug":"编译原理/JavaScript柯里化","published":1,"updated":"2021-01-15T21:20:23.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3l0005dvbxxvu6rvgeo","content":"<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<a id=\"more\"></a>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\"></span><br><span class=\"line\">function curriedAdd (x) &#123;</span><br><span class=\"line\">  return function (y) &#123;</span><br><span class=\"line\">    return x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(curriedAdd(1)(3))</span><br><span class=\"line\">console.log(curriedAdd(1)(3) === 4)</span><br><span class=\"line\"></span><br><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function currying (fn, ...args1) &#123;</span><br><span class=\"line\">  return function (...args2) &#123;</span><br><span class=\"line\">    return fn(...args1, ...args2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">currying(add, 1)</span><br><span class=\"line\">currying(add, 1)(2)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\"></span><br><span class=\"line\">function curriedAdd (x) &#123;</span><br><span class=\"line\">  return function (y) &#123;</span><br><span class=\"line\">    return x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(curriedAdd(1)(3))</span><br><span class=\"line\">console.log(curriedAdd(1)(3) === 4)</span><br><span class=\"line\"></span><br><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function currying (fn, ...args1) &#123;</span><br><span class=\"line\">  return function (...args2) &#123;</span><br><span class=\"line\">    return fn(...args1, ...args2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">currying(add, 1)</span><br><span class=\"line\">currying(add, 1)(2)</span><br></pre></td></tr></table></figure>"},{"title":"HTTP响应代码","date":"2021-01-09T13:30:27.000Z","_content":"\n<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<!-- more -->\n\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理</il>\n  <li>200-299：成功状态码，用于表示请求正常处理完毕</il>\n  <li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转</il>\n  <li>400-499：客户端错误状态码，表示服务器无法处理请求</il>\n  <li>500-599：服务器错误状态码，表示服务器处理请求出错</il>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">常见code码：</h5>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">Protocol</h5>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>\n</ol>\n","source":"_posts/计算机网络/HTTP响应代码.md","raw":"---\ntitle: HTTP响应代码\ndate: 2021-01-09 21:30:27\ntags: 网络知识\ncategories: 计算机网络\n---\n\n<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<!-- more -->\n\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理</il>\n  <li>200-299：成功状态码，用于表示请求正常处理完毕</il>\n  <li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转</il>\n  <li>400-499：客户端错误状态码，表示服务器无法处理请求</il>\n  <li>500-599：服务器错误状态码，表示服务器处理请求出错</il>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">常见code码：</h5>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">Protocol</h5>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>\n</ol>\n","slug":"计算机网络/HTTP响应代码","published":1,"updated":"2021-01-15T21:10:39.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3l0005fvbxxnejl22h2","content":"<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理\n  </li><li>200-299：成功状态码，用于表示请求正常处理完毕\n  </li><li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转\n  </li><li>400-499：客户端错误状态码，表示服务器无法处理请求\n  </li><li>500-599：服务器错误状态码，表示服务器处理请求出错\n</li></ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">常见code码：</h5><p></p>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">Protocol</h5><p></p>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>简述前端常见HTTP响应代码对应网络状态。</p>","more":"<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理\n  </li><li>200-299：成功状态码，用于表示请求正常处理完毕\n  </li><li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转\n  </li><li>400-499：客户端错误状态码，表示服务器无法处理请求\n  </li><li>500-599：服务器错误状态码，表示服务器处理请求出错\n</li></ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">常见code码：</h5><p></p>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">Protocol</h5><p></p>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li>\n</ol>"},{"title":"设计模式概览","date":"2019-07-29T08:37:49.000Z","_content":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<h4>创建型模式</h4>\n<ol>\n  <li>Abstract Factory(抽象工厂)--对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      <p>\n    </div>\n  </li>\n</ol>\n\n<h4>行为型模式</h4>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：https://github.com/sunhui-blog/designPatterns</p>  \n\n代码后续会逐渐优化~\n\n<h4 style=\"margin-top:50px;\">格式</h4>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","source":"_posts/设计模式/设计模式概览.md","raw":"---\ntitle: 设计模式概览\ndate: 2019-07-29 16:37:49\ntags: 设计模式\ncategories: 设计模式\n---\n<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<h4>创建型模式</h4>\n<ol>\n  <li>Abstract Factory(抽象工厂)--对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      <p>\n    </div>\n  </li>\n</ol>\n\n<h4>行为型模式</h4>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：https://github.com/sunhui-blog/designPatterns</p>  \n\n代码后续会逐渐优化~\n\n<h4 style=\"margin-top:50px;\">格式</h4>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","slug":"设计模式/设计模式概览","published":1,"updated":"2021-01-01T05:32:13.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklevo3l1005ivbxxarhttkiu","content":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<p></p><h4>创建型模式</h4><p></p>\n<ol>\n  <li>Abstract Factory(抽象工厂)–对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      </p><p>\n    </p></div>\n  </li>\n</ol>\n\n<p></p><h4>行为型模式</h4><p></p>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：<a href=\"https://github.com/sunhui-blog/designPatterns\" target=\"_blank\" rel=\"noopener\">https://github.com/sunhui-blog/designPatterns</a></p>  \n\n<p>代码后续会逐渐优化~</p>\n<p></p><h4 style=\"margin-top:50px;\">格式</h4><p></p>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<p></p><h4>创建型模式</h4><p></p>\n<ol>\n  <li>Abstract Factory(抽象工厂)–对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      </p><p>\n    </p></div>\n  </li>\n</ol>\n\n<p></p><h4>行为型模式</h4><p></p>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：<a href=\"https://github.com/sunhui-blog/designPatterns\" target=\"_blank\" rel=\"noopener\">https://github.com/sunhui-blog/designPatterns</a></p>  \n\n<p>代码后续会逐渐优化~</p>\n<p></p><h4 style=\"margin-top:50px;\">格式</h4><p></p>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"Docker常用命令","date":"2021-03-04T05:43:20.000Z","_content":"\n与容器进行交互\ndocker exec -t -i f726f305fb37 /bin/bash\n\nhttps://www.jianshu.com/p/dbc59702f0dd\n","source":"_posts/工具/Docker常用命令.md","raw":"---\ntitle: Docker常用命令\ndate: 2021-03-04 13:43:20\ntags: 工具\ncategories: 工具\n---\n\n与容器进行交互\ndocker exec -t -i f726f305fb37 /bin/bash\n\nhttps://www.jianshu.com/p/dbc59702f0dd\n","slug":"工具/Docker常用命令","published":1,"updated":"2021-03-04T17:44:06.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklv5unly000074xxswjg45ys","content":"<p>与容器进行交互\ndocker exec -t -i f726f305fb37 /bin/bash</p>\n<p><a href=\"https://www.jianshu.com/p/dbc59702f0dd\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/dbc59702f0dd</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>与容器进行交互\ndocker exec -t -i f726f305fb37 /bin/bash</p>\n<p><a href=\"https://www.jianshu.com/p/dbc59702f0dd\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/dbc59702f0dd</a></p>\n"},{"title":"mysql","date":"2021-03-04T05:34:43.000Z","_content":"<p>数据库常用sql整理。</p>\n<!--more-->\n<ol>\n  <li>创建数据库:\n    ```\n    CREATE DATABASE <数据库名>;\n\n    // 创建notebook数据库\n    mysql> CREATE DATABASE notebook;\n    ```\n  </li>\n  <li>选择数据库:\n    ```\n    use <数据库名>;\n\n    // 选择notebook数据库\n    use notebook;\n    ```\n  </li>\n  <li>删除数据库:\n    ```\n    DROP DATABASE <数据库名>;\n\n    // 删除notebook数据库\n    mysql> DROP DATABASE notebook;\n    ```\n  </li>\n  <li>创建数据表:\n    ```\n    CREATE TABLE table_name (column_name column_type);\n    ```\n  </li>\n  <li>删除数据表:\n    ```\n    DROP TABLE table_name ;\n    ```\n  </li>\n</ol>","source":"_posts/数据库/mysql.md","raw":"---\ntitle: mysql\ndate: 2021-03-04 13:34:43\ntags: 数据库\ncategories: 数据库\n---\n<p>数据库常用sql整理。</p>\n<!--more-->\n<ol>\n  <li>创建数据库:\n    ```\n    CREATE DATABASE <数据库名>;\n\n    // 创建notebook数据库\n    mysql> CREATE DATABASE notebook;\n    ```\n  </li>\n  <li>选择数据库:\n    ```\n    use <数据库名>;\n\n    // 选择notebook数据库\n    use notebook;\n    ```\n  </li>\n  <li>删除数据库:\n    ```\n    DROP DATABASE <数据库名>;\n\n    // 删除notebook数据库\n    mysql> DROP DATABASE notebook;\n    ```\n  </li>\n  <li>创建数据表:\n    ```\n    CREATE TABLE table_name (column_name column_type);\n    ```\n  </li>\n  <li>删除数据表:\n    ```\n    DROP TABLE table_name ;\n    ```\n  </li>\n</ol>","slug":"数据库/mysql","published":1,"updated":"2021-03-04T17:45:03.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklv5unm1000174xxk5fki1ag","content":"<p></p><p>数据库常用sql整理。</p>\n<a id=\"more\"></a><p></p>\n<ol>\n  <li>创建数据库:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建notebook数据库</span><br><span class=\"line\">mysql&gt; CREATE DATABASE notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>选择数据库:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 选择notebook数据库</span><br><span class=\"line\">use notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>删除数据库:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP DATABASE &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除notebook数据库</span><br><span class=\"line\">mysql&gt; DROP DATABASE notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>创建数据表:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>删除数据表:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>","site":{"data":{}},"excerpt":"<p></p><p>数据库常用sql整理。</p>","more":"<p></p>\n<ol>\n  <li>创建数据库:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 创建notebook数据库</span><br><span class=\"line\">mysql&gt; CREATE DATABASE notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>选择数据库:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 选择notebook数据库</span><br><span class=\"line\">use notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>删除数据库:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP DATABASE &lt;数据库名&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 删除notebook数据库</span><br><span class=\"line\">mysql&gt; DROP DATABASE notebook;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>创建数据表:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>删除数据表:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>"},{"title":"Jest","date":"2021-03-04T05:45:27.000Z","_content":"","source":"_posts/测试框架/Jest.md","raw":"---\ntitle: Jest\ndate: 2021-03-04 13:45:27\ntags: 测试框架\ncategories: 测试框架\n---\n","slug":"测试框架/Jest","published":1,"updated":"2021-03-04T17:45:54.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cklv5unm2000374xxbugtw8i4","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cklevo3jc0000vbxxrzuswswh","category_id":"cklevo3jg0002vbxx0xbkxq1c","_id":"cklevo3jl000avbxxo1jxvrt2"},{"post_id":"cklevo3jj0008vbxx5cvfdzrd","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jo000gvbxxpzj2i2jl"},{"post_id":"cklevo3je0001vbxxfn2mz568","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jq000kvbxxmw3l72bg"},{"post_id":"cklevo3jk0009vbxxq0iu1wq7","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jr000ovbxxm949i8k1"},{"post_id":"cklevo3jm000cvbxx0zs9fg9r","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3js000rvbxxgc3cg8bp"},{"post_id":"cklevo3jh0003vbxxzern2zz0","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jt000uvbxxs45qbql8"},{"post_id":"cklevo3jo000fvbxx1965161h","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3ju000xvbxx00oixhiq"},{"post_id":"cklevo3jp000jvbxxjqgmwm85","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3ju0010vbxxl9jqooz3"},{"post_id":"cklevo3jh0004vbxxhd27z00l","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jv0013vbxxofutcwca"},{"post_id":"cklevo3jq000nvbxxscvjhbik","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jw0016vbxx1rj43pao"},{"post_id":"cklevo3js000qvbxxg1a7ruxj","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jx0019vbxxytf0ytre"},{"post_id":"cklevo3ji0005vbxx96yv4m0a","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jx001bvbxxrgg1bgbx"},{"post_id":"cklevo3js000tvbxx8kmlidll","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jy001evbxx3319xnfz"},{"post_id":"cklevo3jt000wvbxx83wip9yp","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3jz001ivbxxk19sxeyd"},{"post_id":"cklevo3ju000zvbxxjxdvjjcp","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3k0001lvbxxj7bosqm9"},{"post_id":"cklevo3jv0012vbxx56dvntq9","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3k0001ovbxx1ho5kjee"},{"post_id":"cklevo3jv0015vbxx9y0bb67q","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3k1001rvbxxvlqfb65z"},{"post_id":"cklevo3jw0018vbxxtl2x6c99","category_id":"cklevo3jj0006vbxx8v6o1j6v","_id":"cklevo3k2001uvbxx1mlu9h6w"},{"post_id":"cklevo3jx001avbxxyyzp2y7z","category_id":"cklevo3jy001fvbxx53t3yrwt","_id":"cklevo3k3001yvbxx5kbt9kzl"},{"post_id":"cklevo3jy001dvbxxmgvoy6jx","category_id":"cklevo3k0001nvbxxd1uuqp58","_id":"cklevo3k40022vbxxjrnwog6q"},{"post_id":"cklevo3k2001tvbxxaanxiuib","category_id":"cklevo3k0001nvbxxd1uuqp58","_id":"cklevo3k50026vbxxp5cbl7sm"},{"post_id":"cklevo3jy001hvbxxjrpe0c8p","category_id":"cklevo3k0001nvbxxd1uuqp58","_id":"cklevo3k60029vbxxq4uk4ccn"},{"post_id":"cklevo3jz001kvbxxe59ipade","category_id":"cklevo3k40021vbxxgso5lcpc","_id":"cklevo3k7002fvbxxpcnpise9"},{"post_id":"cklevo3k6002bvbxx5hd77h9k","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3k9002mvbxxzm2gkb7u"},{"post_id":"cklevo3k0001mvbxxpuav5zp1","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3ka002qvbxxa60dix4m"},{"post_id":"cklevo3k7002evbxxu650efky","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3kc002uvbxxzoetuf1z"},{"post_id":"cklevo3k1001pvbxxhidqf8ho","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3kd002yvbxxqd75zr2h"},{"post_id":"cklevo3k9002lvbxxtjcxosar","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3ke0032vbxx63ot3vug"},{"post_id":"cklevo3k3001wvbxxb5m9bu3u","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3ke0036vbxxixp1078e"},{"post_id":"cklevo3kc002xvbxx2fklep8z","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3kf003avbxx0caxom6t"},{"post_id":"cklevo3k40020vbxxamwz2h4a","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3kg003evbxx73nwx3x2"},{"post_id":"cklevo3k40024vbxx99qefdh0","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3ki003jvbxxnsyt494x"},{"post_id":"cklevo3k50027vbxxpr3a6net","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklevo3kj003pvbxxl9vuc9jg"},{"post_id":"cklevo3kh003gvbxxy8cwt7v8","category_id":"cklevo3k40021vbxxgso5lcpc","_id":"cklevo3kk003tvbxxeom5w4f1"},{"post_id":"cklevo3kj003nvbxxj983fcc7","category_id":"cklevo3k40021vbxxgso5lcpc","_id":"cklevo3km003yvbxxfafpq82i"},{"post_id":"cklevo3k8002ivbxxamyva0ir","category_id":"cklevo3ki003ivbxx5nysxjwd","_id":"cklevo3kn0042vbxx25rehbzf"},{"post_id":"cklevo3kj003qvbxxdhakf3r3","category_id":"cklevo3k40021vbxxgso5lcpc","_id":"cklevo3ko0046vbxxxvtjrjfv"},{"post_id":"cklevo3ka002pvbxxxn162jy0","category_id":"cklevo3kk003rvbxxbibmh6dl","_id":"cklevo3kp004avbxxlhz1zee3"},{"post_id":"cklevo3km0041vbxx7ycw0mwt","category_id":"cklevo3k40021vbxxgso5lcpc","_id":"cklevo3kq004evbxxi7seimqk"},{"post_id":"cklevo3kb002tvbxxqu0xt9om","category_id":"cklevo3kk003rvbxxbibmh6dl","_id":"cklevo3kr004ivbxxd20frywk"},{"post_id":"cklevo3kd0031vbxxq65q8vnh","category_id":"cklevo3ko0047vbxx72gayaji","_id":"cklevo3ks004lvbxxgfz79o42"},{"post_id":"cklevo3ke0035vbxxe0ty59c8","category_id":"cklevo3kq004fvbxx21k36jo6","_id":"cklevo3kt004tvbxxo4nsvqtb"},{"post_id":"cklevo3kf0039vbxxyyytjogs","category_id":"cklevo3ko0047vbxx72gayaji","_id":"cklevo3kv0050vbxx4698r90z"},{"post_id":"cklevo3kg003dvbxxj9d8u5rb","category_id":"cklevo3kk003rvbxxbibmh6dl","_id":"cklevo3kx0056vbxxg4mycc7i"},{"post_id":"cklevo3ki003kvbxx5yj6wev6","category_id":"cklevo3kq004fvbxx21k36jo6","_id":"cklevo3kz005cvbxxxgckc0y8"},{"post_id":"cklevo3kk003uvbxxbbi2dxdq","category_id":"cklevo3kq004fvbxx21k36jo6","_id":"cklevo3l1005hvbxxjeuygp94"},{"post_id":"cklevo3kl003xvbxxx555q9wc","category_id":"cklevo3kz005bvbxxbe2shtgy","_id":"cklevo3l3005ovbxxba0i1ujc"},{"post_id":"cklevo3kn0045vbxxge8yid2x","category_id":"cklevo3kz005bvbxxbe2shtgy","_id":"cklevo3l4005svbxxl48mnbx9"},{"post_id":"cklevo3ko0049vbxxdc93maq9","category_id":"cklevo3kz005bvbxxbe2shtgy","_id":"cklevo3l4005wvbxxwyfgc7ly"},{"post_id":"cklevo3kp004cvbxxmpjo4u7i","category_id":"cklevo3kz005bvbxxbe2shtgy","_id":"cklevo3l5005zvbxxcxjuvwf2"},{"post_id":"cklevo3kq004hvbxxyrxfo100","category_id":"cklevo3l4005vvbxxla3cv0db","_id":"cklevo3l60063vbxxbvtg9ra9"},{"post_id":"cklevo3kr004kvbxxz3astksi","category_id":"cklevo3l4005vvbxxla3cv0db","_id":"cklevo3l60064vbxxzma4p2jn"},{"post_id":"cklevo3ks004pvbxxneqqsnsg","category_id":"cklevo3l50062vbxxy7tl4oa2","_id":"cklevo3l60067vbxxp2cyo8ei"},{"post_id":"cklevo3kt004rvbxx4vbaipr1","category_id":"cklevo3l4005vvbxxla3cv0db","_id":"cklevo3l60068vbxx7wu0ovn9"},{"post_id":"cklevo3kt004uvbxxiavf0fbi","category_id":"cklevo3l60066vbxxhd86g4tt","_id":"cklevo3l7006avbxxo5iw2bbp"},{"post_id":"cklevo3ku004xvbxxbv397wo9","category_id":"cklevo3l60069vbxx22qidbb1","_id":"cklevo3l7006cvbxxgvpf2bqr"},{"post_id":"cklevo3kv0051vbxx9782jmkq","category_id":"cklevo3l7006bvbxx3m4lcy9m","_id":"cklevo3l7006evbxx10frbmle"},{"post_id":"cklevo3kw0054vbxx4qqxgyo5","category_id":"cklevo3l7006dvbxxm0tcnuzs","_id":"cklevo3l7006hvbxxz1l9sfnt"},{"post_id":"cklevo3kx0057vbxx97mdkz98","category_id":"cklevo3l7006dvbxxm0tcnuzs","_id":"cklevo3l8006ivbxx4hpo8qm0"},{"post_id":"cklevo3kz0059vbxxvdpq67tq","category_id":"cklevo3l7006gvbxxh23ommqf","_id":"cklevo3l8006kvbxx6zxz5edu"},{"post_id":"cklevo3l0005dvbxxvu6rvgeo","category_id":"cklevo3l8006jvbxxkhgahnar","_id":"cklevo3l8006nvbxx5c99ixor"},{"post_id":"cklevo3l0005fvbxxnejl22h2","category_id":"cklevo3l7006dvbxxm0tcnuzs","_id":"cklevo3l8006ovbxxquq53fsf"},{"post_id":"cklevo3l1005ivbxxarhttkiu","category_id":"cklevo3l7006gvbxxh23ommqf","_id":"cklevo3l9006pvbxxt0le4gfz"},{"post_id":"cklv5unly000074xxswjg45ys","category_id":"cklevo3k6002avbxxy5tqkxsu","_id":"cklv5unmb000674xxyhw7ngpv"},{"post_id":"cklv5unm1000174xxk5fki1ag","category_id":"cklv5unm3000474xx1wgjfw3i","_id":"cklv5unmc000a74xx7ivsbb7l"},{"post_id":"cklv5unm2000374xxbugtw8i4","category_id":"cklv5unmb000774xxkyv1svt2","_id":"cklv5unmc000c74xx3tqfl2bu"}],"PostTag":[{"post_id":"cklevo3jh0004vbxxhd27z00l","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jn000evbxxq20tpes0"},{"post_id":"cklevo3jm000cvbxx0zs9fg9r","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jp000ivbxxl0l6ycr5"},{"post_id":"cklevo3ji0005vbxx96yv4m0a","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jq000mvbxxfkntwufk"},{"post_id":"cklevo3jj0008vbxx5cvfdzrd","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3js000svbxxtf2gihjo"},{"post_id":"cklevo3js000qvbxxg1a7ruxj","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jt000vvbxxeqeahy6s"},{"post_id":"cklevo3js000tvbxx8kmlidll","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3ju000yvbxx6yvp8vmb"},{"post_id":"cklevo3jt000wvbxx83wip9yp","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jv0011vbxxxfz2zedp"},{"post_id":"cklevo3jv0012vbxx56dvntq9","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jw0017vbxxoujpw2sa"},{"post_id":"cklevo3jw0018vbxxtl2x6c99","tag_id":"cklevo3jj0007vbxx3n59ibmu","_id":"cklevo3jy001cvbxxlhqxy4aw"},{"post_id":"cklevo3ju000zvbxxjxdvjjcp","tag_id":"cklevo3jv0014vbxx3021vigk","_id":"cklevo3jy001gvbxxf8jrb6kz"},{"post_id":"cklevo3jy001dvbxxmgvoy6jx","tag_id":"cklevo3jz001jvbxxqsfmhnfi","_id":"cklevo3k2001svbxx92b2521l"},{"post_id":"cklevo3k2001tvbxxaanxiuib","tag_id":"cklevo3jz001jvbxxqsfmhnfi","_id":"cklevo3k3001zvbxxxt5cyujm"},{"post_id":"cklevo3jy001hvbxxjrpe0c8p","tag_id":"cklevo3jz001jvbxxqsfmhnfi","_id":"cklevo3k40023vbxxeucxasg8"},{"post_id":"cklevo3jz001kvbxxe59ipade","tag_id":"cklevo3k3001xvbxxfdkuh6g1","_id":"cklevo3k60028vbxx4bv6xqws"},{"post_id":"cklevo3k50027vbxxpr3a6net","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3k7002dvbxx3wu2qrko"},{"post_id":"cklevo3k0001mvbxxpuav5zp1","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3k8002gvbxxnk0tp311"},{"post_id":"cklevo3k6002bvbxx5hd77h9k","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3k9002kvbxxi6prc6iw"},{"post_id":"cklevo3k7002evbxxu650efky","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3k9002nvbxxrd09y6wn"},{"post_id":"cklevo3k1001pvbxxhidqf8ho","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3kb002svbxxma2e1ldm"},{"post_id":"cklevo3k9002lvbxxtjcxosar","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3kc002vvbxxo4z22v1a"},{"post_id":"cklevo3k3001wvbxxb5m9bu3u","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3kd0030vbxxr6tvws3a"},{"post_id":"cklevo3k40020vbxxamwz2h4a","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3ke0033vbxx3ks12cba"},{"post_id":"cklevo3kc002xvbxx2fklep8z","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3kf0038vbxxl87b4sdb"},{"post_id":"cklevo3k40024vbxx99qefdh0","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklevo3kg003bvbxx0lygpcz2"},{"post_id":"cklevo3ka002pvbxxxn162jy0","tag_id":"cklevo3kf0037vbxxgdoio8d0","_id":"cklevo3kh003hvbxxegqyis56"},{"post_id":"cklevo3kg003dvbxxj9d8u5rb","tag_id":"cklevo3kf0037vbxxgdoio8d0","_id":"cklevo3ki003lvbxxbsuzhysm"},{"post_id":"cklevo3kh003gvbxxy8cwt7v8","tag_id":"cklevo3k3001xvbxxfdkuh6g1","_id":"cklevo3kj003ovbxxwn0xlxzz"},{"post_id":"cklevo3kb002tvbxxqu0xt9om","tag_id":"cklevo3kf0037vbxxgdoio8d0","_id":"cklevo3kk003svbxxyp5ifhhe"},{"post_id":"cklevo3kj003nvbxxj983fcc7","tag_id":"cklevo3k3001xvbxxfdkuh6g1","_id":"cklevo3kl003wvbxxd03vvhcb"},{"post_id":"cklevo3kj003qvbxxdhakf3r3","tag_id":"cklevo3k3001xvbxxfdkuh6g1","_id":"cklevo3km0040vbxxu6nsk41h"},{"post_id":"cklevo3kd0031vbxxq65q8vnh","tag_id":"cklevo3ki003mvbxx0luqravj","_id":"cklevo3kn0043vbxxe8vo3oxy"},{"post_id":"cklevo3kf0039vbxxyyytjogs","tag_id":"cklevo3ki003mvbxx0luqravj","_id":"cklevo3ko0048vbxx6n6uncen"},{"post_id":"cklevo3km0041vbxx7ycw0mwt","tag_id":"cklevo3k3001xvbxxfdkuh6g1","_id":"cklevo3kp004bvbxxyifn4er0"},{"post_id":"cklevo3ko0049vbxxdc93maq9","tag_id":"cklevo3kn0044vbxxtlfttob2","_id":"cklevo3kq004gvbxxb3slmmtc"},{"post_id":"cklevo3kl003xvbxxx555q9wc","tag_id":"cklevo3kn0044vbxxtlfttob2","_id":"cklevo3kr004jvbxxckdraryu"},{"post_id":"cklevo3kp004cvbxxmpjo4u7i","tag_id":"cklevo3kn0044vbxxtlfttob2","_id":"cklevo3ks004nvbxxfn4pjf96"},{"post_id":"cklevo3kn0045vbxxge8yid2x","tag_id":"cklevo3kn0044vbxxtlfttob2","_id":"cklevo3kt004qvbxx96o86md2"},{"post_id":"cklevo3kt004rvbxx4vbaipr1","tag_id":"cklevo3ks004mvbxxviom3km4","_id":"cklevo3ku004wvbxxhd2222vf"},{"post_id":"cklevo3kq004hvbxxyrxfo100","tag_id":"cklevo3ks004mvbxxviom3km4","_id":"cklevo3kv004yvbxxirza1i1y"},{"post_id":"cklevo3kr004kvbxxz3astksi","tag_id":"cklevo3ks004mvbxxviom3km4","_id":"cklevo3kw0053vbxxs0levicr"},{"post_id":"cklevo3ks004pvbxxneqqsnsg","tag_id":"cklevo3kw0052vbxxiy3bcykd","_id":"cklevo3kz005avbxx0qkjnc96"},{"post_id":"cklevo3kv0051vbxx9782jmkq","tag_id":"cklevo3ky0058vbxxd7xtwsqy","_id":"cklevo3l1005gvbxxbe6uzwf5"},{"post_id":"cklevo3l0005fvbxxnejl22h2","tag_id":"cklevo3l0005evbxx5c1hgnja","_id":"cklevo3l2005kvbxxw3k7bwau"},{"post_id":"cklevo3kw0054vbxx4qqxgyo5","tag_id":"cklevo3l0005evbxx5c1hgnja","_id":"cklevo3l3005mvbxxawrrry9u"},{"post_id":"cklevo3kx0057vbxx97mdkz98","tag_id":"cklevo3l0005evbxx5c1hgnja","_id":"cklevo3l4005qvbxxfqdmsdl3"},{"post_id":"cklevo3kz0059vbxxvdpq67tq","tag_id":"cklevo3l3005pvbxxz9o4oy3t","_id":"cklevo3l4005uvbxx7io0rp3d"},{"post_id":"cklevo3l0005dvbxxvu6rvgeo","tag_id":"cklevo3l4005tvbxxgpw2qrw0","_id":"cklevo3l5005yvbxxtz4do0wf"},{"post_id":"cklevo3l1005ivbxxarhttkiu","tag_id":"cklevo3l3005pvbxxz9o4oy3t","_id":"cklevo3l50061vbxxw6q4a673"},{"post_id":"cklv5unly000074xxswjg45ys","tag_id":"cklevo3k50025vbxxu9jy36al","_id":"cklv5unm2000274xxm5ls2csx"},{"post_id":"cklv5unm1000174xxk5fki1ag","tag_id":"cklv5unma000574xxkoihqrdl","_id":"cklv5unmc000974xxyc669hc8"},{"post_id":"cklv5unm2000374xxbugtw8i4","tag_id":"cklv5unmc000874xx48sw7er6","_id":"cklv5unmc000b74xxn7px1er8"}],"Tag":[{"name":"编程语言","_id":"cklevo3jj0007vbxx3n59ibmu"},{"name":"前后端分离","_id":"cklevo3jv0014vbxx3021vigk"},{"name":"书籍","_id":"cklevo3jz001jvbxxqsfmhnfi"},{"name":"架构","_id":"cklevo3k3001xvbxxfdkuh6g1"},{"name":"工具","_id":"cklevo3k50025vbxxu9jy36al"},{"name":"异常&性能","_id":"cklevo3kf0037vbxxgdoio8d0"},{"name":"算法","_id":"cklevo3ki003mvbxx0luqravj"},{"name":"框架","_id":"cklevo3kn0044vbxxtlfttob2"},{"name":"浏览器","_id":"cklevo3ks004mvbxxviom3km4"},{"name":"程序设计","_id":"cklevo3kw0052vbxxiy3bcykd"},{"name":"脚手架","_id":"cklevo3ky0058vbxxd7xtwsqy"},{"name":"网络知识","_id":"cklevo3l0005evbxx5c1hgnja"},{"name":"设计模式","_id":"cklevo3l3005pvbxxz9o4oy3t"},{"name":"编译原理","_id":"cklevo3l4005tvbxxgpw2qrw0"},{"name":"数据库","_id":"cklv5unma000574xxkoihqrdl"},{"name":"测试框架","_id":"cklv5unmc000874xx48sw7er6"}]}}