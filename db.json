{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.jpeg","path":"images/avatar.jpeg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/favicon.svg","path":"images/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/clipboard.js","path":"js/clipboard.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/img/basic.jpg","path":"img/basic.jpg","modified":0,"renderable":0},{"_id":"source/img/cactus.jpg","path":"img/cactus.jpg","modified":0,"renderable":0},{"_id":"source/img/deer.jpg","path":"img/deer.jpg","modified":0,"renderable":0},{"_id":"source/img/desert.jpg","path":"img/desert.jpg","modified":0,"renderable":0},{"_id":"source/img/execute.png","path":"img/execute.png","modified":0,"renderable":0},{"_id":"source/img/flower.jpg","path":"img/flower.jpg","modified":0,"renderable":0},{"_id":"source/img/pen.jpg","path":"img/pen.jpg","modified":0,"renderable":0},{"_id":"source/img/shadow.jpeg","path":"img/shadow.jpeg","modified":0,"renderable":0},{"_id":"source/img/shell.jpg","path":"img/shell.jpg","modified":0,"renderable":0},{"_id":"source/img/plant.jpg","path":"img/plant.jpg","modified":0,"renderable":0},{"_id":"source/img/network/tcp.png","path":"img/network/tcp.png","modified":0,"renderable":0},{"_id":"source/img/tree.jpeg","path":"img/tree.jpeg","modified":0,"renderable":0},{"_id":"source/img/vuerouter/error.png","path":"img/vuerouter/error.png","modified":0,"renderable":0},{"_id":"source/img/koa/enter.png","path":"img/koa/enter.png","modified":0,"renderable":0},{"_id":"source/img/vuerouter/matched.png","path":"img/vuerouter/matched.png","modified":0,"renderable":0},{"_id":"source/img/vuerouter/samerouter.png","path":"img/vuerouter/samerouter.png","modified":0,"renderable":0},{"_id":"source/img/knowledge.png","path":"img/knowledge.png","modified":0,"renderable":0},{"_id":"source/img/HomeBrew/1.png","path":"img/HomeBrew/1.png","modified":0,"renderable":0},{"_id":"source/img/network/osi.png","path":"img/network/osi.png","modified":0,"renderable":0},{"_id":"source/img/chrome/eventmodel.jpg","path":"img/chrome/eventmodel.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/soucecode.jpg","path":"img/chrome/soucecode.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/procedure.jpg","path":"img/chrome/procedure.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/eventflow.jpg","path":"img/chrome/eventflow.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/addEventListener.jpg","path":"img/chrome/addEventListener.jpg","modified":0,"renderable":0},{"_id":"source/img/chrome/observer.jpg","path":"img/chrome/observer.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"8e83b85a1b24fbfc4142fb77e5ac12b4011e49d7","modified":1560073232000},{"_id":"themes/icarus/.DS_Store","hash":"ff6a009391fa48ef38559616dc5134d9e9aa9484","modified":1549959122000},{"_id":"themes/icarus/.gitignore","hash":"542aaea07afe90211c6a45c90b7d6879a4503043","modified":1549071164000},{"_id":"themes/icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1549071164000},{"_id":"themes/icarus/README.md","hash":"4409383fbd7422800049d6597e9b26aa8db66b66","modified":1549071164000},{"_id":"themes/icarus/_config.yml","hash":"de052892be6d9ae8cc2c236ea24988f214660c5d","modified":1610366084584},{"_id":"themes/icarus/package.json","hash":"4167e65682af257bdf8531a05730e6c42339996d","modified":1549071164000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1560072188000},{"_id":"source/img/basic.jpg","hash":"5d7b639f775afa4daf75a312bba03e6746574e42","modified":1563709812000},{"_id":"source/img/cactus.jpg","hash":"5162330a4466000f75ef352f8fc60d8c4400aedd","modified":1570759443000},{"_id":"source/img/deer.jpg","hash":"aeeb445722949281bda6df0b622dfd433e0ec41d","modified":1558888562000},{"_id":"source/img/desert.jpg","hash":"f2cfe1cd15e66db283a72600643df284a41216a2","modified":1558888796000},{"_id":"source/img/flower.jpg","hash":"692f8f93097723856d46f1c403664059e68614ca","modified":1558889354000},{"_id":"source/img/pen.jpg","hash":"7f3782cc4f2de0bd5fd3dba65dd0f00a9d8f6dfb","modified":1580137595000},{"_id":"source/img/plant.jpg","hash":"a1d8e7cb1b4f38feea0cd3bdba4b50194472af1c","modified":1558889193000},{"_id":"source/img/shadow.jpeg","hash":"b58c631c608d006693d8ed94c2a01673cef70ee6","modified":1558889572000},{"_id":"source/img/shell.jpg","hash":"83257359649e0926b8fdaa6cb3c03752fe72abb0","modified":1560073698000},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE.md","hash":"6b17b84116938367757928087a09dcb8489d06f6","modified":1549071164000},{"_id":"themes/icarus/languages/en.yml","hash":"159f5ff384156c8deb6e275ea79400e3739480ee","modified":1551890465000},{"_id":"themes/icarus/languages/es.yml","hash":"8827823e5b2ce967566854c9bfebc7c69098b4ac","modified":1549071164000},{"_id":"themes/icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1549071164000},{"_id":"themes/icarus/languages/id.yml","hash":"ca7d51748e6031b8a36c20183c8114a956b80010","modified":1551936879000},{"_id":"themes/icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1549071164000},{"_id":"themes/icarus/languages/ko.yml","hash":"06d2bb8b66f68f780218e0ba7edffe1e57fac268","modified":1549071164000},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1549071164000},{"_id":"themes/icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1549071164000},{"_id":"themes/icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1549071164000},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1549071164000},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"79fab0bff625634fb6bb6cadf9c547bd36226dcf","modified":1549071164000},{"_id":"themes/icarus/layout/archive.ejs","hash":"64a81f4c6ca9517169413408d076371e8e09c63a","modified":1549071164000},{"_id":"themes/icarus/layout/categories.ejs","hash":"14ae8e638a21fcc776c27f21f58660d5684104a9","modified":1609485546018},{"_id":"themes/icarus/layout/category.ejs","hash":"bda344da0e6c03899f53abc20ae2a2efab5ab243","modified":1549071164000},{"_id":"themes/icarus/layout/index.ejs","hash":"71120f41d019bf2866a5556747e5e671c8147f85","modified":1549071164000},{"_id":"themes/icarus/layout/layout.ejs","hash":"da63c914247eba116ea5263bfc27a69e96f859b6","modified":1549071164000},{"_id":"themes/icarus/layout/page.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1549071164000},{"_id":"themes/icarus/layout/post.ejs","hash":"50170783bac99946ae8af483920568de9b2d9801","modified":1549071164000},{"_id":"themes/icarus/layout/tag.ejs","hash":"1feac7aa842882757a479b8ad427f6a72fce70c4","modified":1549071164000},{"_id":"themes/icarus/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1549071164000},{"_id":"themes/icarus/scripts/index.js","hash":"9203e2ba1f821d945edf20fc277f3c58d22bfd00","modified":1549071164000},{"_id":"source/_posts/FQA/存疑问题整理.md","hash":"6e2bb54fd1aa075aee7fa39bfd6304bbcc2fdc78","modified":1608973302763},{"_id":"source/_posts/css/两栏&三栏布局.md","hash":"f68f29db881247189e9393cb61e7ff296990312b","modified":1610003514003},{"_id":"source/_posts/JavaScript/JavaScript严格模式.md","hash":"04362de10d753f7e4027ee7fa3ee369af1861644","modified":1609479200929},{"_id":"source/_posts/JavaScript/JavaScript判断对象是否一致.md","hash":"5b3718a6feeec3790ab3c4f716fd9d19683a63a2","modified":1609479191597},{"_id":"source/_posts/JavaScript/JavaScript原型.md","hash":"c20f49bde2e742c8bcb1565e55c370206f2be681","modified":1609479204654},{"_id":"source/_posts/JavaScript/JavaScript基础巩固篇.md","hash":"701e4b8ca6e6df520e2b90d92e7e89495aee82e5","modified":1610743564063},{"_id":"source/_posts/JavaScript/JavaScript实现继承的几种方式.md","hash":"2c47d232f5083c911309c9a61fe86fd47f864547","modified":1609479196954},{"_id":"source/_posts/JavaScript/Javascript内存管理.md","hash":"c5255cd1b16d2c23bc8f67e87cb4472da970d210","modified":1609479186764},{"_id":"source/_posts/JavaScript/this机制.md","hash":"44f20c458dbc9ac3d03cec450aae33b35ad31c0e","modified":1609479208269},{"_id":"source/_posts/JavaScript/如何手动实现form表单提交的url.md","hash":"436946a24ace97bd73abc425b4644bf726c2108c","modified":1609479174528},{"_id":"source/_posts/JavaScript/宏任务和微任务.md","hash":"d9073e340f91cc4c6655f2b83aaca69937ce3fb4","modified":1609994473478},{"_id":"source/_posts/JavaScript/深拷贝&浅拷贝.md","hash":"dc1484601d9b9d8338d2d1ce769b616f1c40375e","modified":1609479178185},{"_id":"source/_posts/JavaScript/请求后台数据的几种方式.md","hash":"fc50a9c631a4a7b55bb0828c0c23064c8f2b4069","modified":1609479169585},{"_id":"source/_posts/JavaScript/防抖和节流.md","hash":"7e3f77fc782158e811af39aa2d3e312ee2b9e83c","modified":1610743564068},{"_id":"source/_posts/书虫/偷影子的人.md","hash":"5c803c12c0637a5affeabb4e774b6be0995ffd77","modified":1609779681608},{"_id":"source/_posts/书虫/巨人的陨落.md","hash":"67696a11c8c410e456288d5cfa14e7c9c41bc7aa","modified":1609779674631},{"_id":"source/_posts/书虫/巨人的陨落－观感2.md","hash":"629d3d939cff8eaa97de9dd78733c05700380822","modified":1609779670355},{"_id":"source/_posts/兼容性问题处理/IE及移动端兼容性问题&其他汇总.md","hash":"af1be06b551bf65ab55d112af1248f70a3c57414","modified":1609832326577},{"_id":"source/_posts/兼容性问题处理/多端适配.md","hash":"c81c12e8fc6fd6d9248ddf5407846e42d13d4b5f","modified":1610745795129},{"_id":"source/_posts/工具/Git使用过程中遇到的问题.md","hash":"d0be9eadf413920cfe21364433b9e4ed9f35d4dc","modified":1608557041202},{"_id":"source/_posts/工具/Mac安装和卸载HomeBrew.md","hash":"326531ae942a07e7987a4335017ec9e4fe51d255","modified":1608555883534},{"_id":"source/_posts/工具/Nginx.md","hash":"29badae5b2f4d831845ec7295b076723fa681f13","modified":1609467115258},{"_id":"source/_posts/工具/Redis.md","hash":"1457b2c50a198c0b3ebc018217e05aee3a0a9464","modified":1608555155233},{"_id":"source/_posts/工具/VSCode常用快捷键.md","hash":"d5d3faa4257ce7afc8b08a37674df9486e10157e","modified":1609500461400},{"_id":"source/_posts/工具/unit-tests.md","hash":"f61ce96a6eb2d4a9774230edcaec0f1a1fed1435","modified":1608557065289},{"_id":"source/_posts/工具/webpack-gulp-grunt对比.md","hash":"27e90083d41175fda1ffaf6472a75040566cb836","modified":1610298322230},{"_id":"source/_posts/工程化/前端监控.md","hash":"be612fd26202dff7bc7570c21be12ef7c6933d6d","modified":1609479065564},{"_id":"source/_posts/工程化/工程化概述.md","hash":"3c5ec3f0496bd11315eb7e98b378afc715ccdb77","modified":1609479061934},{"_id":"source/_posts/性能/前端性能优化.md","hash":"a18c3f3f98a1f1923e82408294e42c53b9153241","modified":1608973293581},{"_id":"source/_posts/总结/使用Hexo-Github搭建属于自己的blog.md","hash":"abfc70e4e2e05aa2fbc712f71ab906b2aa9ee506","modified":1608557025147},{"_id":"source/_posts/服务端渲染/服务端渲染.md","hash":"85bc903bf7be883ba4e2ea77408d57f1b2958a86","modified":1609479057625},{"_id":"source/_posts/架构/Chrome架构.md","hash":"4f9e459f2dd3e18d7ae05ef4145b531b63f1eafb","modified":1609479091493},{"_id":"source/_posts/架构/SOA服务架构.md","hash":"d3ea5140b6dd6512747a88ae15e9db3021c560d5","modified":1610340097907},{"_id":"source/_posts/架构/UNIX编程艺术.md","hash":"762094861215a732f8b5a036f7bc930ee059375b","modified":1610202521679},{"_id":"source/_posts/架构/koa-express.md","hash":"2369d5fe8ee9316a729b7882a1d6fe01170de646","modified":1609994257969},{"_id":"source/_posts/架构/vue-react对比.md","hash":"f972c87aebebfa5c4cf6c2712acf09b1e17da874","modified":1609825414078},{"_id":"source/_posts/架构/单体应用.md","hash":"4e3a35f04ec60cf2bff5560e38d99cd280c884e2","modified":1609990678375},{"_id":"source/_posts/架构/微内核架构.md","hash":"65b7cf4066474a80af9599de2d1c5ea304a2634e","modified":1610201704360},{"_id":"source/_posts/架构/微前端.md","hash":"8d64edc78ccf23fb4e393300b0534edc7988c33d","modified":1609512442176},{"_id":"source/_posts/架构/微服务架构.md","hash":"f4fc9a10c6c1b236ac36c2d6ab114f06e72dc8b4","modified":1609512456552},{"_id":"source/_posts/架构/插拔式架构.md","hash":"ffac1944a1385fe4da73a0d730c0c3588a40fc0b","modified":1610202518510},{"_id":"source/_posts/架构/无服务器架构.md","hash":"6dc42f7e3b18648b08020a862a66f1e82a13d819","modified":1610745909115},{"_id":"source/_posts/架构/架构-框架和设计模式.md","hash":"5c4c92e14e0d16ba40e47d28f0988f506298aeaf","modified":1609991573458},{"_id":"source/_posts/框架/Flutter.md","hash":"46dc8e63de36783cbbf1bea0692c103121b014ea","modified":1609520416773},{"_id":"source/_posts/框架/Node相关总结.md","hash":"7a14ac0ef3ff325bef2c4f816bb261f7fbd203a3","modified":1609479105860},{"_id":"source/_posts/框架/ReactNative.md","hash":"7a5f8bf42d08c51ee2da2bf93120b44de5e6fe5a","modified":1609520482083},{"_id":"source/_posts/框架/Vue问题总结.md","hash":"1cd196dcb2cdf06b744b3a4171c6f02be2d530cb","modified":1610743564099},{"_id":"source/_posts/框架/菜单路由连续点击无响应.md","hash":"642784a1b0d2eb00faacdf8ff7ec9cce0472d797","modified":1610747809797},{"_id":"source/_posts/框架/骨架屏.md","hash":"606185bbb8e0625ddc6f07e8d1da7779e43f323d","modified":1609479100897},{"_id":"source/_posts/浏览器/浏览器中的EventLoop.md","hash":"182cf960e448d78ef75a093aa4817c6086ff0ade","modified":1609479126003},{"_id":"source/_posts/浏览器/浏览器事件机制.md","hash":"f92812029642d3ec01881404dc8bd1c7d0e41c04","modified":1609479122131},{"_id":"source/_posts/浏览器/浏览器缓存机制.md","hash":"7ef96dc06a8bbb09412d1264356a2c85c40fae30","modified":1609479117190},{"_id":"source/_posts/程序设计/UML类图与交互图.md","hash":"e678b0da195e0393f75a84ff041b33650d1a0080","modified":1609500314878},{"_id":"source/_posts/程序设计/面向对象的程序设计.md","hash":"8b029396dcf53363b485ae9334a1d94c51b60daa","modified":1609479033310},{"_id":"source/_posts/算法/算法.md","hash":"fac368020068e79bd5caa7cefa2cb108c0fa60ea","modified":1609516451556},{"_id":"source/_posts/编程范式/编程范式.md","hash":"b5d0cde389b598c8fdb5a14c1aa1bc37dc913fe9","modified":1609833285564},{"_id":"source/_posts/编译原理/AST抽象树.md","hash":"3b4174c97fcbc53716518070a58fd89012eb438b","modified":1609830752674},{"_id":"source/_posts/编译原理/Acorn解析.md","hash":"f994007dcc8833dc4973efa47c06a681c322a012","modified":1609830762720},{"_id":"source/_posts/编译原理/JavaScript柯里化.md","hash":"18f1375b03ef4021902151d0972a0fd8983a420a","modified":1610745623404},{"_id":"source/_posts/编译原理/JavaScript编译原理.md","hash":"389c770dcf7b2bab2b3f994178d411f93a435a26","modified":1609832308432},{"_id":"source/_posts/网络安全/web安全.md","hash":"932629337685b514adc01c0ebcbe29ca9fce0997","modified":1609479148754},{"_id":"source/_posts/脚手架/前端脚手架.md","hash":"9e044d12e949c91dbb61f3c251dfb3dc50458ffa","modified":1610745902745},{"_id":"source/_posts/计算机基础/进程与线程.md","hash":"98bdd1c15d4d2f6bce8261c726d32b5d3846bac0","modified":1609479075164},{"_id":"source/_posts/计算机网络/网络传输模型.md","hash":"b46a59ba5bdf46b6fb2f728ec1d885fe7aaadfc9","modified":1609479083309},{"_id":"source/_posts/计算机网络/计算机网络.md","hash":"445357a850bdc5f5bb394024b40176159acaed96","modified":1610745990492},{"_id":"source/_posts/设计模式/JavaScript设计模式-观察者模式.md","hash":"272c796423f5c70e7baa5f6aede441312b25044c","modified":1609479137898},{"_id":"source/_posts/设计模式/设计模式概览.md","hash":"f19f8367ec205bf38f35d49b2096c0ee28591b30","modified":1609479133166},{"_id":"source/_posts/阅读源码/Chrome源码导读.md","hash":"4582f7a8ab084d72e6f1a8009c7529a3ba9feb09","modified":1610743564122},{"_id":"source/_posts/阅读源码/Node-js核心思想与源码分析.md","hash":"73ccddce76cf455e107e5903caac725297fdf318","modified":1610743564122},{"_id":"source/_posts/阅读源码/babel源码.md","hash":"00ada99f9772aef19414149db39aab62da629845","modified":1610743564123},{"_id":"source/_posts/阅读源码/express源码.md","hash":"7af65d6fe6677ac931a029cb027ca7c8def12a2a","modified":1610743564124},{"_id":"source/_posts/阅读源码/koa源码.md","hash":"510399d3d07beef638b23718cb2484cc238dc169","modified":1610743564125},{"_id":"source/img/tree.jpeg","hash":"f1dd6384d72e2d516ac88295b452a2d2459aa64e","modified":1560071997000},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1549071164000},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"cd3cd12bc042b401825fd7bfd9a6434c8b14e092","modified":1549071164000},{"_id":"themes/icarus/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1549071164000},{"_id":"themes/icarus/includes/filters/highlight.js","hash":"19a4dcd2dee7388544b57e473cfb0fc9eea9623e","modified":1549071164000},{"_id":"themes/icarus/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1549071164000},{"_id":"themes/icarus/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1549071164000},{"_id":"themes/icarus/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1549071164000},{"_id":"themes/icarus/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"aa8582a2b470d9efc17c75d90e5fe7b4fe49fc82","modified":1608548989888},{"_id":"themes/icarus/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/override.js","hash":"726cf99612fd060753d9da08db2776aec1802e20","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/page.js","hash":"25aeed6449ca381661cec528fe96bbb993026ca9","modified":1549071164000},{"_id":"themes/icarus/includes/helpers/site.js","hash":"f154ddb0dac79fd28ced2b518f8052b42555d0c9","modified":1549071164000},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"a805c1a6f03ccb07d73512aef40d38541ddbb0eb","modified":1549071164000},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"02af67eb87482028b223299b20a129756b1c122b","modified":1549071164000},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1549071164000},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"a9db61ab22a005e74c9615e8838a3c3a148058bd","modified":1551077415000},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"49fabe9c03f3124f0253fa1ee3e69328373ad117","modified":1549071164000},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1549071164000},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"8a7f8d0e72ebf04e69fdbc0fe2800b39c2e919fe","modified":1550484720000},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"67ebd05fb378439a094a7906f4ea04fbedd8c1b5","modified":1549071164000},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"3db2046311dd0392aed0ba2d81b51a081131f1de","modified":1549071164000},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"e29473155a35f391fbc53349bdc256cb7600855e","modified":1549071164000},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"d981ad203a2002c35d710d33e304f9e99f31cab0","modified":1549071164000},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"6c04cccec13a656189ab2d917d69d059027d0343","modified":1549071164000},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"bd500be763486918894e731ce14bc9c4047fb76d","modified":1549071164000},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"cc56bcd2d8d4c6ce3f15d97555e67e90539dfea9","modified":1610292798047},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1549071164000},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"cfc357f27116d1b9285a3b0bec35c3e89ae73711","modified":1549071164000},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1549071164000},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"9ccc7ec354b968e60bdcfcd1dba451d38de61f12","modified":1549071164000},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"b5fff46e453d58baa20028a47fd85923494bb85c","modified":1549071164000},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"b38ea86a1cae48f671501af74d7f109f63fb3d72","modified":1549071164000},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"ef01396e64ab4f6e62155f0b357bcd903138d611","modified":1549071164000},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"033fb890dc1de71f7d3b97061d0d75f4564bd09a","modified":1549071164000},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1549071164000},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1549071164000},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"9ed89b4b40bdf4ae2212e3d197cd7834b59e2eff","modified":1549071164000},{"_id":"themes/icarus/layout/common/article.ejs","hash":"93fb89212c271f6ea796a7d5045dad021d36c2e8","modified":1556280542000},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"61b2a91907a94ecd76649cb1a073a3794d43a1f0","modified":1610291735034},{"_id":"themes/icarus/layout/common/head.ejs","hash":"bd72ffd5942bb2fd18319d551bbaa59647e33f3c","modified":1549071164000},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"fb7bf815a6fb3b57c68656728509d6461689b595","modified":1550485014000},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1549071164000},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"5414d6bfbf88efa7e72ccf7e44a79d0378ddeb77","modified":1549071164000},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"5417af9f208d2fb5aaeb96031caa261e9683557c","modified":1550494059000},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1549071164000},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"8e52a9c28ffaf4b0b786a20977b848c5f60f2274","modified":1549071164000},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"3975dee39f9378975b9c10f37d118ad7cb6f5bf6","modified":1549071164000},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"198062ef863c96aa4d6a8225d575afcb60dfb1d1","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"79d1118a3d3ebc521ffce452b986b504f0e7d6b7","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"eb66e313ad43ec4424b2d75bae94e5c8a7568428","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"205dedf8f97e328bb3182dc8daebd2e2b2204aca","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/clipboard.ejs","hash":"8662ed9c211f3993b93eedcf5e41c2a1ddbede57","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"ad68fafd923747d6b7c1b5873d00989d1639678c","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"282cecb28ac458b71b56cf429c72ffac0f820199","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"2b97737d802984750a7b4461fcf68818a57a2439","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"667aabb6b9cb4d707b37975af794d4a3c66b5264","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"fe051093893c64c8575bcc67dc1c146d409e8e80","modified":1549071164000},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"e594ed6705bccbef27f49d84b6153f6443efbecd","modified":1549071164000},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1549071164000},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1549071164000},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1549071164000},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1549071164000},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"04cb247d8c83ca7c5b52f3b11bb3ac155b1bc3ab","modified":1549071164000},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1549071164000},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1549071164000},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1549071164000},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1549071164000},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"c2a9f2211a21a168c54b0563cdfd58bd25fa39fe","modified":1549071164000},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"2b707fd65c94b00d8b4c6755fbc6c19709f3d49a","modified":1549071164000},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"d8f86f0db04f8293cf0ec683bf94434af6c24bb7","modified":1550484159000},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"2166f3190e47bf4746775b5d16654564a88c2041","modified":1609486309943},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"8c5b8020ca776cc3ebbc7b723915f3173efc28d4","modified":1549071164000},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"d32e7c56e8e2074da16d9141f9a597841d28d07d","modified":1549071164000},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"bdc6f22602cdabe7c740f1818e0681ff8508fb64","modified":1549071164000},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1549071164000},{"_id":"themes/icarus/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1549071164000},{"_id":"themes/icarus/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1549071164000},{"_id":"themes/icarus/source/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1549071164000},{"_id":"themes/icarus/source/css/style.styl","hash":"b8d1bd4405c23849b674e916118a4a006c2eb324","modified":1558880995000},{"_id":"themes/icarus/source/images/avatar.jpeg","hash":"95260542d17426da2558fc1fc7c05886927ccb88","modified":1550484528000},{"_id":"themes/icarus/source/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1549071164000},{"_id":"themes/icarus/source/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1549071164000},{"_id":"themes/icarus/source/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1549071164000},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1549071164000},{"_id":"themes/icarus/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1549071164000},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1549071164000},{"_id":"themes/icarus/source/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1549071164000},{"_id":"themes/icarus/source/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1549071164000},{"_id":"themes/icarus/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1549071164000},{"_id":"themes/icarus/source/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1549071164000},{"_id":"source/img/koa/enter.png","hash":"6ec54d9d3cc9fd7158beeacc078d8f514f4f5021","modified":1610188725246},{"_id":"source/img/network/tcp.png","hash":"628d89ced3afdbf5a35be6d16e0f167882390830","modified":1608570073131},{"_id":"source/img/vuerouter/error.png","hash":"d90c7a7cc560bbc41b16d6907274888df985b0d8","modified":1610076943891},{"_id":"source/img/vuerouter/matched.png","hash":"92194e9f38f781c2dde37ab265bcc46d7854b754","modified":1610075787124},{"_id":"source/img/vuerouter/samerouter.png","hash":"59830b4e5bcd9b68c7b0b79143a4fb3045dc8b21","modified":1610075797545},{"_id":"source/img/knowledge.png","hash":"cf79f1e832023e920cc1a3c35a6cfde309d7c351","modified":1609828172032},{"_id":"source/img/network/osi.png","hash":"25c798d682aee839c70da9bcebdd2ad4a5f3cd99","modified":1608568808584},{"_id":"source/img/HomeBrew/1.png","hash":"4bfc88cedf80d4186f53db3d150c06babc005823","modified":1563706354000},{"_id":"public/content.json","hash":"29d38846661f8dd7cba83c8d6db8be81a9305248","modified":1610789338156},{"_id":"public/2021/01/09/架构/微内核架构/index.html","hash":"3ce3009c0daa0cd5bf997acfc44deaa20771b077","modified":1610293558390},{"_id":"public/2021/01/09/阅读源码/koa源码/index.html","hash":"1b8481626a0a2fe08961c4f9af2894f1452d3592","modified":1610293558390},{"_id":"public/2021/01/08/框架/菜单路由连续点击无响应/index.html","hash":"27c1fd7121ab539c0afa7ba7dd1e1dc06221310e","modified":1610293558390},{"_id":"public/2021/01/07/css/两栏&三栏布局/index.html","hash":"1afced8af961a9d2cfdb50a4b8dbccd910fe6876","modified":1610293558390},{"_id":"public/2021/01/07/JavaScript/防抖和节流/index.html","hash":"ed5c00a63e15c4480212d23c273baa2f163bf23e","modified":1610293558390},{"_id":"public/2021/01/07/JavaScript/宏任务和微任务/index.html","hash":"8724a606e41c1cde712fe314a833547230a61592","modified":1610293558390},{"_id":"public/2021/01/06/架构/架构-框架和设计模式/index.html","hash":"875e66caf0925046cdf0993c9c5176338f7526bb","modified":1610293558390},{"_id":"public/2021/01/06/架构/SOA服务架构/index.html","hash":"d11cd4d3f8a89430cb969af6b7f2473ca0020712","modified":1610293558390},{"_id":"public/2021/01/06/架构/UNIX编程艺术/index.html","hash":"1ace1a07ae10a683904be6fe019ccf5d711d6403","modified":1610789342869},{"_id":"public/2021/01/06/架构/插拔式架构/index.html","hash":"7ba8274b3c4a07cfcf8f5a474fd069b554b0a07a","modified":1610293558391},{"_id":"public/2021/01/05/架构/koa-express/index.html","hash":"461382efdc831be1016a5d6ede01d14e2e6df9ea","modified":1610293558391},{"_id":"public/2021/01/05/阅读源码/express源码/index.html","hash":"a975cf10509da4ac9bbf5a173c2b2e0a3ea6cf62","modified":1610293558391},{"_id":"public/2021/01/02/框架/ReactNative/index.html","hash":"4b2c7299fc39637857c4d95262da4ce0092d2ed5","modified":1610293558391},{"_id":"public/2021/01/02/框架/Flutter/index.html","hash":"8baef3fc79498fa5c751357288f98a51291f8197","modified":1610293558391},{"_id":"public/2021/01/01/算法/算法/index.html","hash":"aea85a6d4e8ec030a9ea75e90a976035430da5d5","modified":1610293558391},{"_id":"public/2021/01/01/架构/单体应用/index.html","hash":"8654e19bffc578e5d1f9ab687f7abe37afd96ff5","modified":1610293558391},{"_id":"public/2021/01/01/架构/微服务架构/index.html","hash":"0c505aff7d1c75d6987f68a3d7dc7d5b80466e23","modified":1610293558391},{"_id":"public/2021/01/01/编译原理/JavaScript柯里化/index.html","hash":"496919f8aa91dd4b2c340e085bb16d0736a312ad","modified":1610293558391},{"_id":"public/2021/01/01/架构/vue-react对比/index.html","hash":"147e8263925685fffe19154a92410eb8c6b89e49","modified":1610293558391},{"_id":"public/2021/01/01/工具/webpack-gulp-grunt对比/index.html","hash":"57f2888c82e792bebb4d1c1d1a65544c61af29e6","modified":1610293558391},{"_id":"public/2021/01/01/兼容性问题处理/多端适配/index.html","hash":"b88b67e79eab05a68c63309f61ca7b830981c9a2","modified":1610293558391},{"_id":"public/2021/01/01/阅读源码/Node-js核心思想与源码分析/index.html","hash":"cf55f531c2fa9567024be4192f2c827266017b6a","modified":1610293558392},{"_id":"public/2021/01/01/阅读源码/babel源码/index.html","hash":"f420f8f822e2dc12b295f51593a380b8532cf78a","modified":1610293558392},{"_id":"public/2021/01/01/编译原理/Acorn解析/index.html","hash":"4b7a54759c1b58ab4400afe7272df7d4c38be4c3","modified":1610293558392},{"_id":"public/2021/01/01/编程范式/编程范式/index.html","hash":"3a4b73bbaf4877fac5b5864abf5b92eee96ad72e","modified":1610293558393},{"_id":"public/2021/01/01/编译原理/JavaScript编译原理/index.html","hash":"d78f0522d695df0f6d8b6c3569b4bedbe0bb7a6d","modified":1610293558393},{"_id":"public/2021/01/01/架构/微前端/index.html","hash":"1627670dd76dc4a950f9d29319ad29e27a82a92f","modified":1610293558393},{"_id":"public/2021/01/01/脚手架/前端脚手架/index.html","hash":"295b409c45388678ef8484bebfaa8fd6c95b535e","modified":1610789342869},{"_id":"public/2021/01/01/编译原理/AST抽象树/index.html","hash":"11fb9351ab24070495066c7c46246232bca4f07b","modified":1610293558393},{"_id":"public/2020/12/31/工具/Nginx/index.html","hash":"de1193114e516cbee3db4c7bd53b38aecd25fd03","modified":1610293558393},{"_id":"public/2020/12/31/工程化/前端监控/index.html","hash":"20adfbc91905180e4b3e1714978d1834bad5a8b1","modified":1610293558393},{"_id":"public/2020/12/22/计算机网络/网络传输模型/index.html","hash":"639870a4c94b1aa02ff49ea3d2153453ad068ac4","modified":1610789342869},{"_id":"public/2020/12/22/计算机网络/计算机网络/index.html","hash":"55447c61fd528ad13d7196cb1bbf1daf8151a35e","modified":1610293558393},{"_id":"public/2020/12/21/JavaScript/深拷贝&浅拷贝/index.html","hash":"e832d06b0f003199dbd63709591d4a60fe18e126","modified":1610789342869},{"_id":"public/2020/12/21/工程化/工程化概述/index.html","hash":"e034aad70e3a2a1fcbfbc24ea8ac325afe1ab5ef","modified":1610789342869},{"_id":"public/2020/09/02/阅读源码/Chrome源码导读/index.html","hash":"3689dc38df586e805b249f856bf02ccaefb4393d","modified":1610293558393},{"_id":"public/2020/09/02/JavaScript/this机制/index.html","hash":"e9a1f81b511c9a2e2684ac3442f86c4a5ae32fd0","modified":1610789342869},{"_id":"public/2020/04/02/架构/Chrome架构/index.html","hash":"a48bd5ea839835c83f4423da26e69f6937aa9732","modified":1610789342869},{"_id":"public/2020/03/21/计算机基础/进程与线程/index.html","hash":"effda839971ab2971a48238bb1f68a31e9ca0850","modified":1610789342869},{"_id":"public/2020/03/02/程序设计/面向对象的程序设计/index.html","hash":"5d54b5338781d1d0039539812bf0b9f97f2d07a9","modified":1610293558394},{"_id":"public/2020/02/18/服务端渲染/服务端渲染/index.html","hash":"e750c8b2e850bfdf0976829c7aa7a156502c57b1","modified":1610293558394},{"_id":"public/2020/02/18/架构/无服务器架构/index.html","hash":"079e73781cf9211121ccc93628e3738ff5333909","modified":1610789342870},{"_id":"public/2020/01/27/书虫/巨人的陨落－观感2/index.html","hash":"4df70b344dc44bceca23085de68a0197de3667fc","modified":1610293558394},{"_id":"public/2020/01/03/JavaScript/JavaScript严格模式/index.html","hash":"9988ecd45c1b57513ec4b254054c95059873c97c","modified":1610789342870},{"_id":"public/2019/11/14/框架/Node相关总结/index.html","hash":"270b4f035f58657db68df11c6e69cc24e460284d","modified":1610293558394},{"_id":"public/2019/10/28/框架/Vue问题总结/index.html","hash":"f9249890573aa5a4c8ac7bb8979dd3da0d7e4124","modified":1610789342870},{"_id":"public/2019/10/28/浏览器/浏览器事件机制/index.html","hash":"f53ed5a98bd38763d5a69d52fd542905fad54824","modified":1610747843285},{"_id":"public/2019/10/28/JavaScript/JavaScript原型/index.html","hash":"78b45f72db706f759d377bf1f082f63feffc4c86","modified":1610789342870},{"_id":"public/2019/10/27/工具/Redis/index.html","hash":"1049537f3b8271c405a12dfff6a6c26a308b70f3","modified":1610293558394},{"_id":"public/2019/10/27/工具/unit-tests/index.html","hash":"87336397c8466b5a406edf280ec4a9dcc805f006","modified":1610789342870},{"_id":"public/2019/10/17/工具/VSCode常用快捷键/index.html","hash":"405e63b6a4462d5fe88d77acb8ccf729a0dc42a1","modified":1610789342870},{"_id":"public/2019/10/10/书虫/巨人的陨落/index.html","hash":"183d598eb5b53298b1f76b37a7a876b7f5b06279","modified":1610293558395},{"_id":"public/2019/10/10/网络安全/web安全/index.html","hash":"c0bde15ba430379f17698d0c2f3edb37eb3e3161","modified":1610789342870},{"_id":"public/2019/09/30/浏览器/浏览器缓存机制/index.html","hash":"c46292d69731f10c62874a15b31647a924548a1a","modified":1610789342870},{"_id":"public/2019/09/30/浏览器/浏览器中的EventLoop/index.html","hash":"b470cf5e73b816f22f910aafdeb1e4d3ea828203","modified":1610789342870},{"_id":"public/2019/09/04/JavaScript/JavaScript判断对象是否一致/index.html","hash":"ab000e05b5126f7158b3d5f36b1de63b13fdac8c","modified":1610789342870},{"_id":"public/2019/09/04/JavaScript/如何手动实现form表单提交的url/index.html","hash":"a594cf84b8cc916afd62525d13ea5a1cbaec0e00","modified":1610789342870},{"_id":"public/2019/09/04/工具/Git使用过程中遇到的问题/index.html","hash":"f34e95d8b53d21d7b1dc7ff992d190c747c948e3","modified":1610789342870},{"_id":"public/2019/08/29/JavaScript/Javascript内存管理/index.html","hash":"3bde25e4b0054f4be41949acf75a1fffeed0d7b6","modified":1610789342870},{"_id":"public/2019/08/09/程序设计/UML类图与交互图/index.html","hash":"0697f4784a7b45f689a1ace293eeec76ebd19341","modified":1610789342871},{"_id":"public/2019/07/29/设计模式/设计模式概览/index.html","hash":"09d1629f2948ed9397be208ff7b7aad7c8d61f27","modified":1610789342871},{"_id":"public/2019/07/21/工具/Mac安装和卸载HomeBrew/index.html","hash":"13b4d5863b4f52b5c4084c787e41e844b22409a2","modified":1610789342871},{"_id":"public/2019/07/03/JavaScript/请求后台数据的几种方式/index.html","hash":"9725539e580df49fda7e813bab76b126c7b40d08","modified":1610789342871},{"_id":"public/2019/06/25/JavaScript/JavaScript基础巩固篇/index.html","hash":"122ec65896928c4aa01b0789b8ccf30263dc2133","modified":1610789342871},{"_id":"public/2019/06/09/JavaScript/JavaScript实现继承的几种方式/index.html","hash":"651882d40f25d5d8b0d8cf32818b49706aaa8b00","modified":1610789342871},{"_id":"public/2019/05/24/设计模式/JavaScript设计模式-观察者模式/index.html","hash":"b8839530f27e58395cfc7f4eb72b443c8a5c8e98","modified":1610789342871},{"_id":"public/2019/05/11/书虫/偷影子的人/index.html","hash":"f5133d3135bc33ea90b026581c9c70e489ed6840","modified":1610293558396},{"_id":"public/2019/05/10/性能/前端性能优化/index.html","hash":"d97fe48cac40b372b8005f42c9afc950a31b7c21","modified":1610293558396},{"_id":"public/2019/04/26/框架/骨架屏/index.html","hash":"62555a5679792c6f9c77997b06f5e543bc820db2","modified":1610789342871},{"_id":"public/2019/04/23/FQA/存疑问题整理/index.html","hash":"1bc2d8ad5140b245a5e7beb40beb5eccd43ae4c0","modified":1610789342871},{"_id":"public/2019/03/06/兼容性问题处理/IE及移动端兼容性问题&其他汇总/index.html","hash":"561534ac89bb0a4d9a33c9174d2e9da3108af6c3","modified":1610293558396},{"_id":"public/2019/02/18/总结/使用Hexo-Github搭建属于自己的blog/index.html","hash":"c35a62ab63375507e4c069c7c0b0ad70370621bb","modified":1610789342871},{"_id":"public/archives/index.html","hash":"35eaef9fe21bff0f8f58c78426af13553d610f8b","modified":1610789342872},{"_id":"public/archives/page/2/index.html","hash":"28fc0d30cc977a1f9603894666024d61ce88ef1b","modified":1610789342872},{"_id":"public/archives/page/3/index.html","hash":"50d0bf139ade5d16339bd3ce0f17b554b4ac914d","modified":1610789342872},{"_id":"public/archives/page/4/index.html","hash":"87e094d646dd97f24764d6216e70b41ae0689ff9","modified":1610789342872},{"_id":"public/archives/page/5/index.html","hash":"8095d71fa1c4b5386895b9949ae33f3caa33ed67","modified":1610789342873},{"_id":"public/archives/page/6/index.html","hash":"e7fb00502f2452cee99a8244aa6eb12c1e6877cc","modified":1610293558396},{"_id":"public/archives/page/7/index.html","hash":"fa5071648d5c4474602b7cf8576188bcbeda1b46","modified":1610293558397},{"_id":"public/archives/page/8/index.html","hash":"1d6b94eeb64b0fad1d5290fb2a478bc526371623","modified":1610293558397},{"_id":"public/archives/2019/index.html","hash":"9b0e928d267138ccf24782cf188e0a4658dd2e10","modified":1610789342873},{"_id":"public/archives/2019/page/2/index.html","hash":"ed45e95fe74f4802061e6d3cb50d35dacd2f428a","modified":1610789342873},{"_id":"public/archives/2019/page/3/index.html","hash":"0fdbb952041e8eb914ee59327a3b222d8e8de408","modified":1610789342873},{"_id":"public/archives/2019/02/index.html","hash":"4d66e55090b5a763461b404d718c5f8889807f70","modified":1610789342873},{"_id":"public/archives/2019/03/index.html","hash":"b6006b83ee7856c2301a1d4f40b3d24e3178e5d2","modified":1610789342873},{"_id":"public/archives/2019/04/index.html","hash":"3bae1d7908b03582004669b0c7ac669c5cfd4c77","modified":1610789342873},{"_id":"public/archives/2019/05/index.html","hash":"51bfaf56488d1e0d99145c29e6b43c98bb046f3c","modified":1610789342873},{"_id":"public/archives/2019/06/index.html","hash":"7c58554e2c2dc427c746c204c9bd6a0597383961","modified":1610789342873},{"_id":"public/archives/2019/07/index.html","hash":"6ce4471bd6ca586176c4efb57f4f31e487811bcb","modified":1610789342873},{"_id":"public/archives/2019/08/index.html","hash":"a2ab786e7eda030d4ad768da9051d4ec8965a778","modified":1610789342873},{"_id":"public/archives/2019/09/index.html","hash":"99a0e09b5778da702b17e717f4c74c5eb79d1b7a","modified":1610789342874},{"_id":"public/archives/2019/10/index.html","hash":"b00d8a0fe08913542972e81a5538bdfea142948d","modified":1610789342874},{"_id":"public/archives/2019/11/index.html","hash":"337b414f18ff292d817a8e8e35e8c827603c860f","modified":1610293558398},{"_id":"public/archives/2020/index.html","hash":"012aa573828d45fe967713813a248506205e35be","modified":1610789342874},{"_id":"public/archives/2020/page/2/index.html","hash":"a4d906eae4274da56aaf0b4e7f78f1dd7fed4033","modified":1610293558398},{"_id":"public/archives/2020/01/index.html","hash":"fc1efa37265cc453a901b8dd8d23300743dddd75","modified":1610789342874},{"_id":"public/archives/2020/02/index.html","hash":"594cce8e12426d1bc5dbb536edbcf5864466bdd4","modified":1610789342874},{"_id":"public/archives/2020/03/index.html","hash":"941f1224bde29537cc6bb46c34d6141ebd122c0a","modified":1610789342874},{"_id":"public/archives/2020/04/index.html","hash":"bfd9daab950f7cb5df2ba005b70d21268b292782","modified":1610789342874},{"_id":"public/archives/2020/09/index.html","hash":"d2cfb582a569d4fd3bcb43e681ebc3262ecd7207","modified":1610789342874},{"_id":"public/archives/2020/12/index.html","hash":"5cf4a7099ce0ed1d058b84e0636140d9cdb8e280","modified":1610789342874},{"_id":"public/archives/2021/index.html","hash":"707986e65067e4533fbd112dfe9a005b9be7959f","modified":1610789342874},{"_id":"public/archives/2021/page/2/index.html","hash":"ce5556625d49678e7a21f4bb8ac8601ea31d9cc6","modified":1610789342874},{"_id":"public/archives/2021/page/3/index.html","hash":"c910b5d9ea381760fcd1cd6312102df0818b46d0","modified":1610293558398},{"_id":"public/archives/2021/01/index.html","hash":"15b8e3edcf6eb6ed6b0b918c0663339771d9251e","modified":1610789342874},{"_id":"public/archives/2021/01/page/2/index.html","hash":"e98c399f7377996471c2955fa311e735d2915246","modified":1610789342874},{"_id":"public/archives/2021/01/page/3/index.html","hash":"57eeded87724766740942bf8bcc944b802c85fc3","modified":1610293558399},{"_id":"public/categories/FQA/index.html","hash":"110918d68cf77d22d76e8b819521eafc765a3856","modified":1610789342874},{"_id":"public/categories/css/index.html","hash":"c396176a5179fb133139e2e790742240600d6e46","modified":1610789342874},{"_id":"public/categories/JavaScript/index.html","hash":"137b152e435206c226ee8aad7077c2f80f18a238","modified":1610789342875},{"_id":"public/categories/JavaScript/page/2/index.html","hash":"1f9bdb735f5f6031119f4c1a826ef9f97cdb108c","modified":1610789342875},{"_id":"public/categories/书虫/index.html","hash":"16b0c3137ce01556b501822956c45f440c06e972","modified":1610293558399},{"_id":"public/categories/兼容性问题处理/index.html","hash":"02ba00146fa30878b5253ecd3d82f6a7bac7be46","modified":1610293558399},{"_id":"public/categories/工具/index.html","hash":"421800433645bc7ae80e2f0fada3431244905c00","modified":1610789342875},{"_id":"public/categories/工程化/index.html","hash":"c778abf72fd8365f7ecf92fa9c94ed95bb3d730a","modified":1610789342875},{"_id":"public/categories/总结/index.html","hash":"60727d74c7667b24e7274073c9f052ed467b2f02","modified":1610789342875},{"_id":"public/categories/架构/index.html","hash":"2abfc63f8874bd8f81c826c6daec27da8020c4d9","modified":1610789342875},{"_id":"public/categories/架构/page/2/index.html","hash":"ae718eafb5bd4b93921ee28f8e2c185d227178a5","modified":1610293558399},{"_id":"public/categories/服务端渲染/index.html","hash":"75482031a11308e349c427ee7bb3a395e69251ab","modified":1610293558399},{"_id":"public/categories/框架/index.html","hash":"cf678f0d0d9c3f075560f6daef1667c0a51898f1","modified":1610789342875},{"_id":"public/categories/浏览器/index.html","hash":"32a689e13501cdffbac8dd0f99665b2597b2982d","modified":1610789342875},{"_id":"public/categories/程序设计/index.html","hash":"019b865772f1468c1a1e420fe6ed6ec93d432cce","modified":1610789342875},{"_id":"public/categories/算法/index.html","hash":"bd435e57cfa7a1571da6307b33b4b75439aeb3bb","modified":1610293558400},{"_id":"public/categories/编译原理/index.html","hash":"8dc93cd3235bb80da6f463c6c5ed27f8d56df63a","modified":1610789342875},{"_id":"public/categories/网络安全/index.html","hash":"f1e6b95c05180a1bdfb9f1b92826d368386ff263","modified":1610789342875},{"_id":"public/categories/编程范式/index.html","hash":"ef886433128cbc23d8b116072e216e5ff0f20937","modified":1610293558400},{"_id":"public/categories/计算机基础/index.html","hash":"26c3df646cff23b1bdfaf62e59a77b19cd9bea0a","modified":1610789342875},{"_id":"public/categories/脚手架/index.html","hash":"8f5a21b1ca5043f5c922e6c5d4f3261afcc2cbc4","modified":1610789342875},{"_id":"public/categories/计算机网络/index.html","hash":"223322441e95f7e28007bb5190eae4045e325757","modified":1610789342875},{"_id":"public/categories/设计模式/index.html","hash":"5f52d8c3021bc223c6cc5bfe2943c48454f099ea","modified":1610789342875},{"_id":"public/categories/阅读源码/index.html","hash":"ab5ad9317e4758b210d490d3eb3ed477c7d3e96a","modified":1610293558400},{"_id":"public/index.html","hash":"70d014cf15c8ca61d3b1180308a95709720a9eb8","modified":1610789342876},{"_id":"public/page/2/index.html","hash":"16944c116363e312c59135fdffa834c608b5af61","modified":1610789342876},{"_id":"public/page/3/index.html","hash":"7c66f25fca70b2377638299aa57314cdbc4dd3f7","modified":1610789342876},{"_id":"public/page/4/index.html","hash":"947124de2fe75557e9ec2e1cd74a7ed4893a16df","modified":1610789342876},{"_id":"public/page/5/index.html","hash":"aaf09507a3aadde13650ca14e5833934c83f7ac1","modified":1610293558401},{"_id":"public/tags/编程语言/index.html","hash":"852041c58bc959c5b0c630a5ae52610f4d1391d2","modified":1610789342872},{"_id":"public/tags/书籍/index.html","hash":"08b0440ed217e0d90c124d79efef95259fbbf644","modified":1610293558401},{"_id":"public/tags/前后端分离/index.html","hash":"3e4f39de7c99845de34fe6fd9bd3fe2720dcfbb5","modified":1610789342872},{"_id":"public/tags/工具/index.html","hash":"5ea46b2deeb2d29c34514ae89226643105aa8564","modified":1610789342872},{"_id":"public/tags/性能/index.html","hash":"a4c85c5c1f8a0a292874274fb852b6244f823841","modified":1610293558401},{"_id":"public/tags/架构/index.html","hash":"92b634f6e39b10d04a048459baaf7ff4d78a8b19","modified":1610789342872},{"_id":"public/tags/架构/page/2/index.html","hash":"cc6c4a7e67ccb1913889023495498c4f8537672d","modified":1610293558401},{"_id":"public/tags/服务端渲染/index.html","hash":"f89cf5403ac35145b6f3b4d676d9ec28c53d31b0","modified":1610293558401},{"_id":"public/tags/框架/index.html","hash":"ca9d22dc0c308a57467da726522b36f06e54a014","modified":1610789342872},{"_id":"public/tags/浏览器/index.html","hash":"f64680731e9159f3dce1ddfce777cd94629b93cd","modified":1610789342872},{"_id":"public/tags/程序设计/index.html","hash":"3719560e6420c237507a89ddb6ac998f1db215cf","modified":1610789342872},{"_id":"public/tags/算法/index.html","hash":"ff9655e23bff4550c9cb3cf7431b165914e7f640","modified":1610789342872},{"_id":"public/tags/编译原理/index.html","hash":"bff4882e2349e926d286ae12493cd85a66f19a9a","modified":1610789342872},{"_id":"public/tags/编程范式/index.html","hash":"7bdd3b9724536e33e7dc437ccc5060f28e0a9a8e","modified":1610293558402},{"_id":"public/tags/脚手架/index.html","hash":"8f4f456f30598325d529d1612def6eb2b771dbd2","modified":1610789342872},{"_id":"public/tags/网络知识/index.html","hash":"c391d025efb95d5efad3aa621a46b07eaebfae97","modified":1610789342872},{"_id":"public/tags/设计模式/index.html","hash":"c4f9d3df43f002c7e67902576d174a095c1fc82f","modified":1610789342872},{"_id":"public/tags/源码/index.html","hash":"d23f29bd8a898cb0c450e5b6cced203ac6cde480","modified":1610293558402},{"_id":"public/categories/index.html","hash":"918ca4c2d5b781b47a34ab6f6c3da1f02038193e","modified":1610789342876},{"_id":"public/tags/index.html","hash":"c16bd4e031def05e451049180e211f5038b2a3a4","modified":1610789342876},{"_id":"public/img/deer.jpg","hash":"aeeb445722949281bda6df0b622dfd433e0ec41d","modified":1610293558407},{"_id":"public/img/pen.jpg","hash":"7f3782cc4f2de0bd5fd3dba65dd0f00a9d8f6dfb","modified":1610293558407},{"_id":"public/img/desert.jpg","hash":"f2cfe1cd15e66db283a72600643df284a41216a2","modified":1610293558407},{"_id":"public/img/plant.jpg","hash":"a1d8e7cb1b4f38feea0cd3bdba4b50194472af1c","modified":1610293558407},{"_id":"public/img/flower.jpg","hash":"692f8f93097723856d46f1c403664059e68614ca","modified":1610293558407},{"_id":"public/img/shell.jpg","hash":"83257359649e0926b8fdaa6cb3c03752fe72abb0","modified":1610293558407},{"_id":"public/images/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1610293558407},{"_id":"public/images/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1610293558407},{"_id":"public/img/shadow.jpeg","hash":"b58c631c608d006693d8ed94c2a01673cef70ee6","modified":1610293558407},{"_id":"public/images/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1610293558407},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1610293558407},{"_id":"public/images/avatar.jpeg","hash":"95260542d17426da2558fc1fc7c05886927ccb88","modified":1610293558407},{"_id":"public/img/network/tcp.png","hash":"628d89ced3afdbf5a35be6d16e0f167882390830","modified":1610293558407},{"_id":"public/img/koa/enter.png","hash":"6ec54d9d3cc9fd7158beeacc078d8f514f4f5021","modified":1610293558407},{"_id":"public/img/vuerouter/error.png","hash":"d90c7a7cc560bbc41b16d6907274888df985b0d8","modified":1610293558407},{"_id":"public/img/vuerouter/matched.png","hash":"92194e9f38f781c2dde37ab265bcc46d7854b754","modified":1610293558407},{"_id":"public/img/basic.jpg","hash":"5d7b639f775afa4daf75a312bba03e6746574e42","modified":1610293558506},{"_id":"public/img/cactus.jpg","hash":"5162330a4466000f75ef352f8fc60d8c4400aedd","modified":1610293558506},{"_id":"public/img/vuerouter/samerouter.png","hash":"59830b4e5bcd9b68c7b0b79143a4fb3045dc8b21","modified":1610293558506},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1610293558512},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1610293558512},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1610293558512},{"_id":"public/css/style.css","hash":"621f9b669b7a98053ed614eb5151a3a3fa770ba4","modified":1610293558512},{"_id":"public/css/search.css","hash":"c1cb306e075386517ac15bf4ef37c647d37ec6b5","modified":1610293558512},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1610293558512},{"_id":"public/js/clipboard.js","hash":"6fdd602268727744b6b2c8ad79d684aab3cffda5","modified":1610293558512},{"_id":"public/js/gallery.js","hash":"88b23abfc3b519413be54533ed0f39e0c68fcdd1","modified":1610293558512},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1610293558512},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1610293558512},{"_id":"public/js/main.js","hash":"3357a1798a994afad0a849a679ca2ed6e0ce2424","modified":1610293558512},{"_id":"public/img/tree.jpeg","hash":"f1dd6384d72e2d516ac88295b452a2d2459aa64e","modified":1610293558512},{"_id":"public/img/knowledge.png","hash":"cf79f1e832023e920cc1a3c35a6cfde309d7c351","modified":1610293558522},{"_id":"public/img/network/osi.png","hash":"25c798d682aee839c70da9bcebdd2ad4a5f3cd99","modified":1610293558539},{"_id":"public/img/HomeBrew/1.png","hash":"4bfc88cedf80d4186f53db3d150c06babc005823","modified":1610293558546},{"_id":"source/_posts/JavaScript/ES6新数据类型Symbol.md","hash":"2438ebe9e59a1db3fede1a0b26045518876d12da","modified":1610341093457},{"_id":"source/_posts/JavaScript/JavaScript的set和get.md","hash":"4df47990ca760fc8273d1c49b74f358a197eb0cb","modified":1610340974659},{"_id":"source/_posts/阅读源码/gulp源码.md","hash":"3060d508f9093ac9465e249903f2863c4d1d7126","modified":1610743564125},{"_id":"source/_posts/阅读源码/postcss源码.md","hash":"dcf6de2b3efd8fd05fb25a0e56c95ef1d481655f","modified":1610743564126},{"_id":"source/_posts/数据结构&算法/算法.md","hash":"fac368020068e79bd5caa7cefa2cb108c0fa60ea","modified":1609516451556},{"_id":"source/_posts/异常&性能/Performance-Monitor性能指标.md","hash":"37b5ac4efe9be8414582753689158c166f998aa4","modified":1610745738807},{"_id":"source/_posts/异常&性能/前端异常处理.md","hash":"8cc56c1ae9f12a34bf93bda07b9459de8aed9b60","modified":1610744987678},{"_id":"source/_posts/异常&性能/前端性能优化.md","hash":"7a8b27c0afd0efc77726a696780fd8b36fcf1ae8","modified":1610592407768},{"_id":"source/img/架构/UNIX编程艺术.md","hash":"762094861215a732f8b5a036f7bc930ee059375b","modified":1610202521679},{"_id":"source/img/架构/SOA服务架构.md","hash":"d3ea5140b6dd6512747a88ae15e9db3021c560d5","modified":1610340097907},{"_id":"source/img/架构/koa-express.md","hash":"2369d5fe8ee9316a729b7882a1d6fe01170de646","modified":1609994257969},{"_id":"source/img/架构/Chrome架构.md","hash":"4f9e459f2dd3e18d7ae05ef4145b531b63f1eafb","modified":1609479091493},{"_id":"source/img/架构/微前端.md","hash":"8d64edc78ccf23fb4e393300b0534edc7988c33d","modified":1609512442176},{"_id":"source/img/架构/微内核架构.md","hash":"65b7cf4066474a80af9599de2d1c5ea304a2634e","modified":1610201704360},{"_id":"source/img/架构/单体应用.md","hash":"4e3a35f04ec60cf2bff5560e38d99cd280c884e2","modified":1609990678375},{"_id":"source/img/架构/vue-react对比.md","hash":"f972c87aebebfa5c4cf6c2712acf09b1e17da874","modified":1609825414078},{"_id":"source/img/架构/插拔式架构.md","hash":"ffac1944a1385fe4da73a0d730c0c3588a40fc0b","modified":1610202518510},{"_id":"source/img/架构/无服务器架构.md","hash":"f00d76f3e0d99ad1c1c78f428ea67cd950bcb55e","modified":1610521195144},{"_id":"source/img/架构/微服务架构.md","hash":"f4fc9a10c6c1b236ac36c2d6ab114f06e72dc8b4","modified":1609512456552},{"_id":"source/img/架构/架构-框架和设计模式.md","hash":"5c4c92e14e0d16ba40e47d28f0988f506298aeaf","modified":1609991573458},{"_id":"source/img/编译原理/JavaScript柯里化.md","hash":"e11f18aa8d22013e9859467177bad325c6eef265","modified":1610593662696},{"_id":"source/img/编译原理/JavaScript编译原理.md","hash":"389c770dcf7b2bab2b3f994178d411f93a435a26","modified":1610593656158},{"_id":"source/img/编译原理/AST抽象树.md","hash":"3b4174c97fcbc53716518070a58fd89012eb438b","modified":1609830752674},{"_id":"source/img/编译原理/Acorn解析.md","hash":"f994007dcc8833dc4973efa47c06a681c322a012","modified":1609830762720},{"_id":"source/img/阅读源码/Node-js核心思想与源码分析.md","hash":"d76b1d039e7d956d1716c233743a2e9fdd7932d6","modified":1609498280356},{"_id":"source/img/阅读源码/express源码.md","hash":"d1ff4bfd2481b9d14356a693aab14d1c36ed816a","modified":1609994277463},{"_id":"source/img/阅读源码/babel源码.md","hash":"422065e80730a8bba9f857b375164a44d81e1056","modified":1609493833521},{"_id":"source/img/阅读源码/Chrome源码导读.md","hash":"776e8b26498f103b40a2d9933035dae709ef2c6a","modified":1609493848295},{"_id":"source/img/阅读源码/gulp源码.md","hash":"78f1d07070a293cb08a1f01bc3f2644c617b5d42","modified":1610346459781},{"_id":"source/img/阅读源码/koa源码.md","hash":"3816eefb9dcba9728657b5d87c838cdb610ad5ec","modified":1610421061516},{"_id":"source/img/阅读源码/postcss源码.md","hash":"6833358602ea56907cc47fd7ee3ceda656a03f61","modified":1610346447222},{"_id":"source/img/操作系统/Unix操作系统.md","hash":"608a3483b7275264928deccbf96312462a96fc72","modified":1610512880976},{"_id":"source/img/操作系统/Linux操作系统.md","hash":"a93b5419abe5085506b1e5ef4dbe1f4a96d13c5b","modified":1610513919830},{"_id":"source/img/数据库/mongodb.md","hash":"05b584c16d1128ad80aa35e3cb3b19b3c7c895ad","modified":1610543463276},{"_id":"source/img/数据库/mysql.md","hash":"2cc87149ea926274486818e69bcfa47652bab914","modified":1610542503484},{"_id":"source/img/异常&性能/前端性能优化.md","hash":"7a8b27c0afd0efc77726a696780fd8b36fcf1ae8","modified":1610592407768},{"_id":"source/img/异常&性能/前端异常处理.md","hash":"683851240d3af39524cc8d940258f7d0a3a8406e","modified":1610592369102},{"_id":"source/img/异常&性能/Performance-Monitor性能指标.md","hash":"d9207343b341796ac5d54a0a68344e4975c5927e","modified":1610592358034},{"_id":"source/img/数据结构&算法/Javascript数组去重和排序.md","hash":"46359559e21844c27f425a16377757565da6147c","modified":1610617523508},{"_id":"source/img/数据结构&算法/数据结构.md","hash":"b587984cf9a0ce2f625244b1641ee19a14bf1e80","modified":1610617523510},{"_id":"source/img/数据结构&算法/算法题.md","hash":"1ccb850d3479e1e008a96bee1ff8f7bae1482b23","modified":1610617523511},{"_id":"source/img/vuerouter/兼容性问题处理/多端适配.md","hash":"11c17b027f26ff48faebbc2e6b46494c4102c29f","modified":1610365345230},{"_id":"source/img/兼容性问题处理/多端适配.md","hash":"11c17b027f26ff48faebbc2e6b46494c4102c29f","modified":1610365345230},{"_id":"source/img/脚手架/前端脚手架.md","hash":"96b66039ae7e045856db5f1206e401aec71cdbf9","modified":1610187930217},{"_id":"source/_posts/操作系统/Linux操作系统.md","hash":"a93b5419abe5085506b1e5ef4dbe1f4a96d13c5b","modified":1610513919830},{"_id":"source/_posts/操作系统/Unix操作系统.md","hash":"608a3483b7275264928deccbf96312462a96fc72","modified":1610512880976},{"_id":"source/_posts/数据库/mongodb.md","hash":"05b584c16d1128ad80aa35e3cb3b19b3c7c895ad","modified":1610543463276},{"_id":"source/_posts/数据库/mysql.md","hash":"2cc87149ea926274486818e69bcfa47652bab914","modified":1610542503484},{"_id":"source/img/execute.png","hash":"f3e9ff6d95473eaa6c1600fa7c29e4298389ae0f","modified":1610743564134},{"_id":"source/_posts/JavaScript/手写一个reduce.md","hash":"2f157bc0dda83c44c1a43efe277ed68396c4c7a5","modified":1610747731017},{"_id":"source/_posts/JavaScript/手写一个简易版promise.md","hash":"28b94ba15d36c620441d20b7dfb415dac72e801c","modified":1610747728626},{"_id":"source/_posts/css/IE及移动端兼容性问题&其他汇总.md","hash":"3a767bf303b51d2303286363fc47c7b4bf7819bf","modified":1610743564070},{"_id":"source/_posts/工具/webpack打包过程.md","hash":"5527f75df944b4ab8bb23af863a2d656eafb51e8","modified":1610743564074},{"_id":"source/_posts/数据结构&算法/Javascript数组去重和排序.md","hash":"46359559e21844c27f425a16377757565da6147c","modified":1610743564083},{"_id":"source/_posts/数据结构&算法/LRU缓存机制.md","hash":"9e1e4596cbdd7f8e3fc727dde8ed485342920a24","modified":1610743564084},{"_id":"source/_posts/数据结构&算法/数据结构.md","hash":"b587984cf9a0ce2f625244b1641ee19a14bf1e80","modified":1610743564084},{"_id":"source/_posts/数据结构&算法/算法题.md","hash":"1ccb850d3479e1e008a96bee1ff8f7bae1482b23","modified":1610743564085},{"_id":"source/_posts/框架/egg-js.md","hash":"b87b1a7bc973f43b3e8c202c3b92f22cc7b9a5e1","modified":1610743564099},{"_id":"source/_posts/框架/vue-ssr实现原理.md","hash":"35f8572a45251d40ad35cb3e203b3f8063aca33a","modified":1610743564100},{"_id":"source/_posts/框架/vue3-0新特性.md","hash":"9e0667da71cec8d9da0f6076b02fdfe32fa9d379","modified":1610743564101},{"_id":"source/_posts/框架/vue的diff算法.md","hash":"859d81c0f7e24feca755a290b404cb6363528b26","modified":1610743564101},{"_id":"source/_posts/框架/从零搭建vue项目.md","hash":"0e10e1d553e4475dafe0f54db896ee88835f1639","modified":1610789322536},{"_id":"source/_posts/计算机网络/HTTP响应代码.md","hash":"2df00bbf92fc70ec28d258c59402c63609fcfa3a","modified":1610745039131},{"_id":"public/2021/01/15/框架/菜单路由连续点击无响应/index.html","hash":"674e8fa541140d595778946fb80aab6f49e11947","modified":1610789342868},{"_id":"public/2021/01/13/JavaScript/手写一个简易版promise/index.html","hash":"a5083c5bb70e8c4e726ae1a791cdb8674dee0eaf","modified":1610789342868},{"_id":"public/2021/01/13/JavaScript/手写一个reduce/index.html","hash":"c657e132c40aa2b7879b491e5effa404d91469bc","modified":1610789342868},{"_id":"public/2021/01/13/框架/从零搭建vue项目/index.html","hash":"f2151c25d8b52b9ab43edd899dee8dca0cad3ebd","modified":1610789342868},{"_id":"public/2021/01/12/编译原理/JavaScript柯里化/index.html","hash":"4221976ce71238a11ed255595bfac310b94c8311","modified":1610789342868},{"_id":"public/2021/01/11/JavaScript/防抖和节流/index.html","hash":"52b2fd2dce0bb0b344541cef98cd252153077cc4","modified":1610789342868},{"_id":"public/2021/01/11/JavaScript/JavaScript的set和get/index.html","hash":"86bc52b3186e044e3d8849744a36e033e57b6042","modified":1610789342869},{"_id":"public/2021/01/10/异常&性能/Performance-Monitor性能指标/index.html","hash":"63d5509859f1c37ee38cf8fa53357690ae0e8197","modified":1610789342869},{"_id":"public/2021/01/10/异常&性能/前端异常处理/index.html","hash":"e5843c8ba742cb0834ab92cdc207a58abdc16848","modified":1610789342869},{"_id":"public/2021/01/09/计算机网络/HTTP响应代码/index.html","hash":"ee8389d06037e0ed3c7efe88da906c72d34617bf","modified":1610789342869},{"_id":"public/2021/01/07/兼容性问题处理/多端适配/index.html","hash":"5df4541b5f7facfbccc3aa0cfc6ab26cbfdd6e6b","modified":1610789342869},{"_id":"public/2020/12/13/数据结构&算法/Javascript数组去重和排序/index.html","hash":"9edc6c78627efa083c6aa854370832fa7bed1bc5","modified":1610789342869},{"_id":"public/2020/01/13/计算机网络/计算机网络/index.html","hash":"1b0d633b87f797030d2c79f562963ce68883cfac","modified":1610789342870},{"_id":"public/2019/05/10/异常&性能/前端性能优化/index.html","hash":"26ae6d974c26da3bf82e325af6006e2f78dff334","modified":1610789342871},{"_id":"public/2019/03/06/css/IE及移动端兼容性问题&其他汇总/index.html","hash":"728fec92b9de1d8188c4990326767c5cf16d1ef1","modified":1610789342871},{"_id":"public/categories/数据结构-算法/index.html","hash":"e47ebff0fe0ede287c3717781158de3dec5b3347","modified":1610789342876},{"_id":"public/categories/异常-性能/index.html","hash":"3dcc330acf695c01471ea1c642457e5658e6167d","modified":1610789342876},{"_id":"public/tags/异常-性能/index.html","hash":"6d8594315d41f008a13ce3bca64cb2d2de82a3d6","modified":1610789342872},{"_id":"source/img/chrome/浏览器事件机制.md","hash":"f3b4263f36389adcba672fce20f582a0046f1653","modified":1610781832071},{"_id":"source/img/chrome/procedure.jpg","hash":"beb30506cc956c1e155ec67c130149639257e895","modified":1610749564587},{"_id":"source/img/chrome/eventflow.jpg","hash":"952842244a3c54d2c3f2e4dc40902d01d5f19ff0","modified":1610749751779},{"_id":"source/img/chrome/eventmodel.jpg","hash":"c1bd6edbb32c525465fe95cce74e63a391ee57c3","modified":1610749105811},{"_id":"source/img/chrome/observer.jpg","hash":"21b048e2f1db8dd814e4ffd01821fb4a223eb7ac","modified":1610750502582},{"_id":"source/img/chrome/soucecode.jpg","hash":"0375fecc50b1ea8cb28056bff484b156fa16dc21","modified":1610749260682},{"_id":"source/img/chrome/addEventListener.jpg","hash":"6c284ed679416d83411f46c6def93e4fe45c60f6","modified":1610750144769},{"_id":"public/img/chrome/浏览器事件机制.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1610789342868}],"Category":[{"name":"FQA","_id":"ckjrazwrj0002faxx2rza5uqb"},{"name":"css","_id":"ckjrazwrm0006faxxdjh089hp"},{"name":"JavaScript","_id":"ckjrazwro000bfaxxtaj0xzih"},{"name":"书虫","_id":"ckjrazwry0014faxxtpi9ow79"},{"name":"兼容性问题处理","_id":"ckjrazws4001ofaxxq4ohrbi4"},{"name":"工具","_id":"ckjrazws80022faxx6gomuqv1"},{"name":"工程化","_id":"ckjrazwsh002wfaxxxjwjiej4"},{"name":"总结","_id":"ckjrazwsp003ffaxxopkb5mt6"},{"name":"架构","_id":"ckjrazwsr003ofaxxvsk65zxw"},{"name":"服务端渲染","_id":"ckjrazwsv0042faxx64n0ngqa"},{"name":"框架","_id":"ckjrazwth005yfaxxzdmwwegy"},{"name":"浏览器","_id":"ckjrazwtl006lfaxxu1xgfsvj"},{"name":"程序设计","_id":"ckjrazwtn006tfaxxxkpzudtg"},{"name":"算法","_id":"ckjrazwto0071faxx08qfkkvj"},{"name":"编译原理","_id":"ckjrazwto0075faxxkav8xrje"},{"name":"网络安全","_id":"ckjrazwtp007cfaxxbjely5gp"},{"name":"编程范式","_id":"ckjrazwtq007gfaxxv7zm8vp6"},{"name":"计算机基础","_id":"ckjrazwtq007jfaxxgvr11aaf"},{"name":"脚手架","_id":"ckjrazwtq007lfaxxdl8768vk"},{"name":"计算机网络","_id":"ckjrazwtr007nfaxxeduyr9r9"},{"name":"设计模式","_id":"ckjrazwtr007qfaxxy9r2x8a5"},{"name":"阅读源码","_id":"ckjrazwts007ufaxxphb9legf"},{"name":"操作系统","_id":"ckjuxpf49000m9oxxo39ibsca"},{"name":"数据结构&算法","_id":"ckjv2uqqx00169oxxin4sdo1n"},{"name":"数据库","_id":"ckjvff16j001s9oxxs977d765"},{"name":"性能","_id":"ckjviupys00289oxxf9i46yk5"},{"name":"异常&性能","_id":"ckjw93t1a002i9oxxhhzi3hgk"}],"Data":[],"Page":[{"title":"「chromium源码解读」浏览器事件机制","date":"2021-01-14T18:33:56.000Z","tags":"浏览器","categories":"浏览器","_content":"\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    ![事件模型](/img/chrome/eventmodel.jpg)\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    ![订阅-发布源码](/img/chrome/soucecode.jpg)\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    ![事件处理过程](/img/chrome/procedure.jpg)\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    ![DOM事件流](/img/chrome/eventflow.jpg)\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    ![addEventListener](/img/chrome/addEventListener.jpg)\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    ![事件模型](/img/chrome/observer.jpg)\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>源码解析：https://zhuanlan.zhihu.com/p/25095179</li>\n</ol>\n","source":"img/chrome/浏览器事件机制.md","raw":"---\ntitle: 「chromium源码解读」浏览器事件机制\ndate: 2021-01-15 02:33:56\ntags: 浏览器\ncategories: 浏览器\n---\n\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<!-- more -->\n\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    ![事件模型](/img/chrome/eventmodel.jpg)\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    ![订阅-发布源码](/img/chrome/soucecode.jpg)\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    ![事件处理过程](/img/chrome/procedure.jpg)\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    ![DOM事件流](/img/chrome/eventflow.jpg)\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    ![addEventListener](/img/chrome/addEventListener.jpg)\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    ![事件模型](/img/chrome/observer.jpg)\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n参考：\n<ol>\n  <li>源码解析：https://zhuanlan.zhihu.com/p/25095179</li>\n</ol>\n","updated":"2021-01-16T07:23:52.071Z","path":"img/chrome/浏览器事件机制.html","_id":"ckjzdww4z0000fcxx134ho55v","comments":1,"layout":"page","content":"<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    <img src=\"/img/chrome/eventmodel.jpg\" alt=\"事件模型\">\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    <img src=\"/img/chrome/soucecode.jpg\" alt=\"订阅-发布源码\">\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    <img src=\"/img/chrome/procedure.jpg\" alt=\"事件处理过程\">\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    <img src=\"/img/chrome/eventflow.jpg\" alt=\"DOM事件流\">\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    <img src=\"/img/chrome/addEventListener.jpg\" alt=\"addEventListener\">\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    <img src=\"/img/chrome/observer.jpg\" alt=\"事件模型\">\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li>源码解析：<a href=\"https://zhuanlan.zhihu.com/p/25095179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25095179</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<p>从chrome源码侧webkit内核解读浏览器事件机制。<span class=\"red\">原创解析转载请注明出处。</span></p>","more":"<ol>\n  <li>\n    <p>事件模型(Event Moudle)</p>\n    <img src=\"/img/chrome/eventmodel.jpg\" alt=\"事件模型\">\n  </li>\n  <li>\n    <p>事件订阅-发布相关源码（c++）</p>\n    <img src=\"/img/chrome/soucecode.jpg\" alt=\"订阅-发布源码\">\n  </li>\n  <li>\n    <p>事件处理过程</p>\n    <img src=\"/img/chrome/procedure.jpg\" alt=\"事件处理过程\">\n  </li>\n  <li>\n    <p>DOM事件流</p>\n    <img src=\"/img/chrome/eventflow.jpg\" alt=\"DOM事件流\">\n  </li>\n  <li>\n    <p>设置事件处理程序在事件流中的位置</p>\n    <img src=\"/img/chrome/addEventListener.jpg\" alt=\"addEventListener\">\n  </li>\n  <li>\n    <p>观察者模式时序图</p>\n    <img src=\"/img/chrome/observer.jpg\" alt=\"事件模型\">\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\n参考：<p></p>\n<ol>\n  <li>源码解析：<a href=\"https://zhuanlan.zhihu.com/p/25095179\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/25095179</a></li>\n</ol>"}],"Post":[{"title":"存疑问题整理","date":"2019-04-23T11:46:28.000Z","thumbnail":"img/deer.jpg","_content":"<p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<!-- more -->\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：https://www.jianshu.com/p/07f2e1364f35</p>\n    </li>\n    <li>WebGL\n        <p>参考：http://www.hewebgl.com/article/getarticle/26</p>\n    </li>\n    <li>Node\n        <p>http://nodejs.cn/latest-api/events.html</p>\n    </li>\n    <li>koa\n        <p>参考：https://koajs.com/</p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：https://www.cnblogs.com/fozero/p/9134543.html</p>\n    </li>\n    <li>Es5严格模式：\n        <p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</p>\n    </li>\n</ol>","source":"_posts/FQA/存疑问题整理.md","raw":"---\ntitle: 存疑问题整理\ndate: 2019-04-23 19:46:28\ncategories: FQA\ntags:\nthumbnail: img/deer.jpg\n---\n<p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<!-- more -->\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：https://www.jianshu.com/p/07f2e1364f35</p>\n    </li>\n    <li>WebGL\n        <p>参考：http://www.hewebgl.com/article/getarticle/26</p>\n    </li>\n    <li>Node\n        <p>http://nodejs.cn/latest-api/events.html</p>\n    </li>\n    <li>koa\n        <p>参考：https://koajs.com/</p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：https://www.cnblogs.com/fozero/p/9134543.html</p>\n    </li>\n    <li>Es5严格模式：\n        <p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</p>\n    </li>\n</ol>","slug":"FQA/存疑问题整理","published":1,"updated":"2020-12-26T09:01:42.763Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9k0000uhxx1h4sgyh9","content":"<p></p><p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>\n<a id=\"more\"></a><p></p>\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：<a href=\"https://www.jianshu.com/p/07f2e1364f35\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/07f2e1364f35</a></p>\n    </li>\n    <li>WebGL\n        <p>参考：<a href=\"http://www.hewebgl.com/article/getarticle/26\" target=\"_blank\" rel=\"noopener\">http://www.hewebgl.com/article/getarticle/26</a></p>\n    </li>\n    <li>Node\n        <p><a href=\"http://nodejs.cn/latest-api/events.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/latest-api/events.html</a></p>\n    </li>\n    <li>koa\n        <p>参考：<a href=\"https://koajs.com/\" target=\"_blank\" rel=\"noopener\">https://koajs.com/</a></p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：<a href=\"https://www.cnblogs.com/fozero/p/9134543.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fozero/p/9134543.html</a></p>\n    </li>\n    <li>Es5严格模式：\n        <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>\n    </li>\n</ol>","site":{"data":{}},"excerpt":"<p></p><p>旨在将实际遇到的问题归纳起来，便于后期学习维护</p>","more":"<p></p>\n<ol>\n    <li>现有组件如何扩展？扩展方式有哪些？</li>\n    <li>前端缓存方式有哪些？哪些情形适合做缓存？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"margin:0;\">前端缓存分为两部分：<b>http缓存</b>和<b>浏览器缓存</b></p>\n            <p style=\"margin:0;\">\n                <b>http缓存：</b>强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。</p>\n            <p style=\"margin:0;\">\n                <b>浏览器缓存：</b>Cookie、LocalStorage、SessionStorage、Service Worker</p>\n                <div style=\"margin-top:10px;\">Cookie设置:\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">不设置过期时间</span>，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。</p>\n                    <p style=\"text-indent:30px;margin:0;\"><span style=\"color: red;\">设置了过期时间</span>，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。</p>\n                </div>\n        </div>\n    </li>\n    <li>页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？\n    </li>\n    <li>前端数据存储方式有哪些？\n        <div style=\"margin-top:10px;margin-bottom:10px;\">\n            <p style=\"text-indent:30px;\">在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。</p>\n            <ul>\n                <li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li>\n                <li>由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。</li>\n                <li>避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。</li>\n                <li>嵌套的对象成员会明显影响性能，尽量少用。</li>\n                <li>属性或方法在原型链中的位置越深，访问它的速度也越慢。</li>\n            </ul>\n            <p style=\"text-indent:30px;\">通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。</p>\n        </div>\n    </li>\n    <li>web服务器有哪些？\n        <div>Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等</div>\n    </li>\n    <li>sells方法(sellsian approach)是什么？</li>\n    <li>H5页面与原生交互的方法\n        <p>参考：<a href=\"https://www.jianshu.com/p/07f2e1364f35\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/07f2e1364f35</a></p>\n    </li>\n    <li>WebGL\n        <p>参考：<a href=\"http://www.hewebgl.com/article/getarticle/26\" target=\"_blank\" rel=\"noopener\">http://www.hewebgl.com/article/getarticle/26</a></p>\n    </li>\n    <li>Node\n        <p><a href=\"http://nodejs.cn/latest-api/events.html\" target=\"_blank\" rel=\"noopener\">http://nodejs.cn/latest-api/events.html</a></p>\n    </li>\n    <li>koa\n        <p>参考：<a href=\"https://koajs.com/\" target=\"_blank\" rel=\"noopener\">https://koajs.com/</a></p>\n    </li>\n    <li>自动化脚本\n        <p>shell脚本：<a href=\"https://www.cnblogs.com/fozero/p/9134543.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/fozero/p/9134543.html</a></p>\n    </li>\n    <li>Es5严格模式：\n        <p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>\n    </li>\n</ol>"},{"title":"JavaScript严格模式","date":"2020-01-03T06:10:10.000Z","_content":"\n<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<!-- more -->\n\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  ```\n  // 非严格模式\n  eval(\"function sayHi () { alert('hi'); }\")\n  sayHi() // \"hi\"\n\n  eval(\"var msg= 'hello world'; \")\n  alert(msg) // \"hello world\"\n\n  // 严格模式\n  \"use strict\"\n  eval = 'hi' // 抛出error 创建变量和函数类似\n  ```\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  ```\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // 'Nicholas'\n  person.name = 'lilei'\n  console.log(person.name) // 'Nicholas'\n\n  \"use strict\"\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // Nicholas\n  person.name = 'lilei' // 抛出error\n  console.log(person.name)\n  ```\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n  \n  ```\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    get: function () {\n      return this._year\n    }\n  })\n\n  book.year = 2021 // 抛出错误\n\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    set: function (newValue) {\n      this._year = newValue\n      this.edition++\n    }\n  })\n\n  book.year // 非严格模式下 undefined\n  ```\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, ...)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  ```\n  \"use strict\"\n  window.color = \"red\"\n  let o = { color: \"blue\" }\n\n  function sayColor() {\n    console.log(this.color)\n  }\n  sayColor.call(null); // error 非严格：red\n  sayColor.call(undefined); // error 非严格：red\n  ```\n  </li>\n</ol>","source":"_posts/JavaScript/JavaScript严格模式.md","raw":"---\ntitle: JavaScript严格模式\ndate: 2020-01-03 14:10:10\ntags:\ncategories: JavaScript\n---\n\n<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<!-- more -->\n\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  ```\n  // 非严格模式\n  eval(\"function sayHi () { alert('hi'); }\")\n  sayHi() // \"hi\"\n\n  eval(\"var msg= 'hello world'; \")\n  alert(msg) // \"hello world\"\n\n  // 严格模式\n  \"use strict\"\n  eval = 'hi' // 抛出error 创建变量和函数类似\n  ```\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  ```\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // 'Nicholas'\n  person.name = 'lilei'\n  console.log(person.name) // 'Nicholas'\n\n  \"use strict\"\n  Object.defineProperty(person, \"name\", {\n    writable: false,\n    value: 'Nicholas'\n  })\n  console.log(person.name) // Nicholas\n  person.name = 'lilei' // 抛出error\n  console.log(person.name)\n  ```\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n  \n  ```\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    get: function () {\n      return this._year\n    }\n  })\n\n  book.year = 2021 // 抛出错误\n\n  \"use strict\";\n  let book = {\n    _year: 2020,\n    edition: 1\n  }\n  Object.defineProperty(book, \"year\", {\n    set: function (newValue) {\n      this._year = newValue\n      this.edition++\n    }\n  })\n\n  book.year // 非严格模式下 undefined\n  ```\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, ...)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  ```\n  \"use strict\"\n  window.color = \"red\"\n  let o = { color: \"blue\" }\n\n  function sayColor() {\n    console.log(this.color)\n  }\n  sayColor.call(null); // error 非严格：red\n  sayColor.call(undefined); // error 非严格：red\n  ```\n  </li>\n</ol>","slug":"JavaScript/JavaScript严格模式","published":1,"updated":"2021-01-01T05:33:20.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9m0001uhxxylmkmddp","content":"<p>严格模式为了修复Javascript语法的不严谨性。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 非严格模式</span><br><span class=\"line\">eval(&quot;function sayHi () &#123; alert(&apos;hi&apos;); &#125;&quot;)</span><br><span class=\"line\">sayHi() // &quot;hi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">eval(&quot;var msg= &apos;hello world&apos;; &quot;)</span><br><span class=\"line\">alert(msg) // &quot;hello world&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 严格模式</span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">eval = &apos;hi&apos; // 抛出error 创建变量和函数类似</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\">person.name = &apos;lilei&apos;</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // Nicholas</span><br><span class=\"line\">person.name = &apos;lilei&apos; // 抛出error</span><br><span class=\"line\">console.log(person.name)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = 2021 // 抛出错误</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year // 非严格模式下 undefined</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, …)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">window.color = &quot;red&quot;</span><br><span class=\"line\">let o = &#123; color: &quot;blue&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sayColor() &#123;</span><br><span class=\"line\">  console.log(this.color)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(null); // error 非严格：red</span><br><span class=\"line\">sayColor.call(undefined); // error 非严格：red</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>","site":{"data":{}},"excerpt":"<p>严格模式为了修复Javascript语法的不严谨性。</p>","more":"<ol>\n  <li>初始化未经声明的变量会导致错误。</li>\n  <li>arguments.callee/arguments.caller会导致错误。</li>\n  <li>不能为函数的caller属性赋值，否则会导致错误。</li>\n  <li>严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误；\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 非严格模式</span><br><span class=\"line\">eval(&quot;function sayHi () &#123; alert(&apos;hi&apos;); &#125;&quot;)</span><br><span class=\"line\">sayHi() // &quot;hi&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">eval(&quot;var msg= &apos;hello world&apos;; &quot;)</span><br><span class=\"line\">alert(msg) // &quot;hello world&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 严格模式</span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">eval = &apos;hi&apos; // 抛出error 创建变量和函数类似</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会；\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\">person.name = &apos;lilei&apos;</span><br><span class=\"line\">console.log(person.name) // &apos;Nicholas&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class=\"line\">  writable: false,</span><br><span class=\"line\">  value: &apos;Nicholas&apos;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(person.name) // Nicholas</span><br><span class=\"line\">person.name = &apos;lilei&apos; // 抛出error</span><br><span class=\"line\">console.log(person.name)</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year = 2021 // 抛出错误</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &quot;year&quot;, &#123;</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">book.year // 非严格模式下 undefined</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。\n\n  <p>\n  <em style=\"display:block;background: #eee;line-height: 32px;margin: 10px 0;\">function.call(thisArg, arg1, arg2, …)</em>\n  <em style=\"display:block;\">thisArg:</em>可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。</p>\n\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;</span><br><span class=\"line\">window.color = &quot;red&quot;</span><br><span class=\"line\">let o = &#123; color: &quot;blue&quot; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sayColor() &#123;</span><br><span class=\"line\">  console.log(this.color)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayColor.call(null); // error 非严格：red</span><br><span class=\"line\">sayColor.call(undefined); // error 非严格：red</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>"},{"title":"JavaScript基础巩固篇","date":"2019-06-25T08:50:28.000Z","thumbnail":"img/basic.jpg","_content":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<!-- more -->\n\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            ```\n            Object.prototype.toString.call([])  // \"[object Array]\"\n            Object.prototype.toString.call({})  // \"[object Object]\"\n            ```\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            ```\n            Array.isArray([])  // true\n            Array.isArray({})  // false\n            ```\n            <p>通过instanceof运算符来识别</p>\n            ```\n            console.log({} instanceof Array) // false \n            console.log([] instanceof Array) // true\n            ```\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            ```\n            Array.prototype.isPrototypeOf({}) // false\n            Array.prototype.isPrototypeOf([]) // true\n            Object.prototype.isPrototypeOf({}) // true\n            Object.prototype.isPrototypeOf([]) // false\n            ```\n            <p>通过constructor属性来区别</p>\n            ```\n            [].constructor // ƒ Array() { [native code] }\n            ({}).constructor // ƒ Object() { [native code] }\n            ```\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          ```\n          const a = {}\n          Object.keys(a).length // 是否为0\n          ```\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：http://www.imooc.com/article/277859\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：https://www.cnblogs.com/wangdashi/p/9606182.html\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>'abcd'变为{d:{c:{b:\"a\"}}}</p>\n          ```\n          const str = 'abcd'\n          const newObj = str.split('').reduce(function(prev, next){\n              const obj = {}\n              obj[next]=prev\n              return obj\n          })\n          console.log(newObj) //{d:{c:{b:\"a\"}}}\n          ```\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        ```\n        ```\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        ```\n        var obj = {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n        var arr = []\n        for (let i in obj) {\n          let o = {};\n          o[i] = obj[i];\n          arr.push(o)\n        }\n        console.log(arr) // [{a: 1}, {b: 2}, {c: 3}]\n        ```\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        ```\n        // 1.Object.assign 2.扩展运算符（...）\n        const arr = [1, 2, 3]\n        Object.assign({},[1,2,3]) // {0: 1, 1: 2, 2: 3}\n        {...['a','b','c']} // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // forEach\n        let obj = {}\n        const arr = ['a','b','c']\n        arr.forEach((item,index)=>{obj[index] = item}) // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // for...in\n        let obj = {}\n        const arr = ['a','b','c']\n        for(var key in arr){\n          obj[key]=arr[key]\n        }\n        obj // {0: \"a\", 1: \"b\", 2: \"c\"}\n        ```\n        </div>\n    </li>\n    <li>\n        \n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","source":"_posts/JavaScript/JavaScript基础巩固篇.md","raw":"---\ntitle: JavaScript基础巩固篇\ndate: 2019-06-25 16:50:28\ntags: 编程语言\ncategories: JavaScript\nthumbnail: img/basic.jpg\n---\n<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<!-- more -->\n\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            ```\n            Object.prototype.toString.call([])  // \"[object Array]\"\n            Object.prototype.toString.call({})  // \"[object Object]\"\n            ```\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            ```\n            Array.isArray([])  // true\n            Array.isArray({})  // false\n            ```\n            <p>通过instanceof运算符来识别</p>\n            ```\n            console.log({} instanceof Array) // false \n            console.log([] instanceof Array) // true\n            ```\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            ```\n            Array.prototype.isPrototypeOf({}) // false\n            Array.prototype.isPrototypeOf([]) // true\n            Object.prototype.isPrototypeOf({}) // true\n            Object.prototype.isPrototypeOf([]) // false\n            ```\n            <p>通过constructor属性来区别</p>\n            ```\n            [].constructor // ƒ Array() { [native code] }\n            ({}).constructor // ƒ Object() { [native code] }\n            ```\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          ```\n          const a = {}\n          Object.keys(a).length // 是否为0\n          ```\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：http://www.imooc.com/article/277859\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：https://www.cnblogs.com/wangdashi/p/9606182.html\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>'abcd'变为{d:{c:{b:\"a\"}}}</p>\n          ```\n          const str = 'abcd'\n          const newObj = str.split('').reduce(function(prev, next){\n              const obj = {}\n              obj[next]=prev\n              return obj\n          })\n          console.log(newObj) //{d:{c:{b:\"a\"}}}\n          ```\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        ```\n        ```\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        ```\n        var obj = {\n          a: 1,\n          b: 2,\n          c: 3\n        }\n        var arr = []\n        for (let i in obj) {\n          let o = {};\n          o[i] = obj[i];\n          arr.push(o)\n        }\n        console.log(arr) // [{a: 1}, {b: 2}, {c: 3}]\n        ```\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        ```\n        // 1.Object.assign 2.扩展运算符（...）\n        const arr = [1, 2, 3]\n        Object.assign({},[1,2,3]) // {0: 1, 1: 2, 2: 3}\n        {...['a','b','c']} // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // forEach\n        let obj = {}\n        const arr = ['a','b','c']\n        arr.forEach((item,index)=>{obj[index] = item}) // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n        // for...in\n        let obj = {}\n        const arr = ['a','b','c']\n        for(var key in arr){\n          obj[key]=arr[key]\n        }\n        obj // {0: \"a\", 1: \"b\", 2: \"c\"}\n        ```\n        </div>\n    </li>\n    <li>\n        \n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","slug":"JavaScript/JavaScript基础巩固篇","published":1,"updated":"2021-01-13T02:07:03.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9o0002uhxx4r9xdmv2","content":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>\n\n<a id=\"more\"></a>\n<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call([])  // &quot;[object Array]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(&#123;&#125;)  // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([])  // true</span><br><span class=\"line\">Array.isArray(&#123;&#125;)  // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过instanceof运算符来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#123;&#125; instanceof Array) // false </span><br><span class=\"line\">console.log([] instanceof Array) // true</span><br></pre></td></tr></table></figure>\n\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.isPrototypeOf(&#123;&#125;) // false</span><br><span class=\"line\">Array.prototype.isPrototypeOf([]) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf(&#123;&#125;) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf([]) // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过constructor属性来区别</p>\n            <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor // ƒ Array() &#123; [native code] &#125;</span><br><span class=\"line\">(&#123;&#125;).constructor // ƒ Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;</span><br><span class=\"line\">Object.keys(a).length // 是否为0</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：<a href=\"http://www.imooc.com/article/277859\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/article/277859</a>\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：<a href=\"https://www.cnblogs.com/wangdashi/p/9606182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangdashi/p/9606182.html</a>\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>‘abcd’变为{d:{c:{b:”a”}}}</p>\n          <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;abcd&apos;</span><br><span class=\"line\">const newObj = str.split(&apos;&apos;).reduce(function(prev, next)&#123;</span><br><span class=\"line\">    const obj = &#123;&#125;</span><br><span class=\"line\">    obj[next]=prev</span><br><span class=\"line\">    return obj</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newObj) //&#123;d:&#123;c:&#123;b:&quot;a&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr = []</span><br><span class=\"line\">for (let i in obj) &#123;</span><br><span class=\"line\">  let o = &#123;&#125;;</span><br><span class=\"line\">  o[i] = obj[i];</span><br><span class=\"line\">  arr.push(o)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr) // [&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;]</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.Object.assign 2.扩展运算符（...）</span><br><span class=\"line\">const arr = [1, 2, 3]</span><br><span class=\"line\">Object.assign(&#123;&#125;,[1,2,3]) // &#123;0: 1, 1: 2, 2: 3&#125;</span><br><span class=\"line\">&#123;...[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&#125; // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// forEach</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">arr.forEach((item,index)=&gt;&#123;obj[index] = item&#125;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// for...in</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">for(var key in arr)&#123;</span><br><span class=\"line\">  obj[key]=arr[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>\n\n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p>“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。</p>","more":"<ol>\n    <li>如何区分数组和对象？\n        <div style=\"margin-top:10px;\">\n            <p>通过Object.prototype.toString.call()方法来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call([])  // &quot;[object Array]&quot;</span><br><span class=\"line\">Object.prototype.toString.call(&#123;&#125;)  // &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>\n\n            <p>通过ES6中的Array.isArray()方法来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([])  // true</span><br><span class=\"line\">Array.isArray(&#123;&#125;)  // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过instanceof运算符来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#123;&#125; instanceof Array) // false </span><br><span class=\"line\">console.log([] instanceof Array) // true</span><br></pre></td></tr></table></figure>\n\n            <p>通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.isPrototypeOf(&#123;&#125;) // false</span><br><span class=\"line\">Array.prototype.isPrototypeOf([]) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf(&#123;&#125;) // true</span><br><span class=\"line\">Object.prototype.isPrototypeOf([]) // false</span><br></pre></td></tr></table></figure>\n\n            <p>通过constructor属性来区别</p>\n            <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor // ƒ Array() &#123; [native code] &#125;</span><br><span class=\"line\">(&#123;&#125;).constructor // ƒ Object() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>判断是否为空空对象？\n        <div style=\"margin-top:10px;\">\n          <p>通过Object.keys()来区别</p>\n          <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;&#125;</span><br><span class=\"line\">Object.keys(a).length // 是否为0</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组的迭代方法有哪些？\n        <div>\n            参考：<a href=\"http://www.imooc.com/article/277859\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/article/277859</a>\n        </div>\n    </li>\n    <li>遍历对象的方式有哪些？\n        <div>\n            参考：<a href=\"https://www.cnblogs.com/wangdashi/p/9606182.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangdashi/p/9606182.html</a>\n        </div>\n    </li>\n    <li>字符串转化\n        <div style=\"margin-top:10px;\">\n          <p>‘abcd’变为{d:{c:{b:”a”}}}</p>\n          <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const str = &apos;abcd&apos;</span><br><span class=\"line\">const newObj = str.split(&apos;&apos;).reduce(function(prev, next)&#123;</span><br><span class=\"line\">    const obj = &#123;&#125;</span><br><span class=\"line\">    obj[next]=prev</span><br><span class=\"line\">    return obj</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(newObj) //&#123;d:&#123;c:&#123;b:&quot;a&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>实现继承的几种方式：\n        <div style=\"word-wrap:break-word;\">\n        参考：<a href=\"https://sunhui-blog.github.io/2019/06/09/JavaScript/JavaScript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/\" target=\"_blank\">实现继承的几种方式</a>\n        </div>\n    </li>\n    <li>闭包:\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>严格模式：\n        <ul style=\"margin: 10px 10px;\">\n          <li>严格模式下对保留字增加限制；</li>\n          <li>给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误；</li>\n          <li>在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误；</li>\n        </ul>\n    </li>\n    <li>数据类型：\n        <div style=\"margin-top:10px;\">\n          Undefined、Null、Object、Number、String、Boolean\n        </div>\n    </li>\n    <li>对象转数组:\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arr = []</span><br><span class=\"line\">for (let i in obj) &#123;</span><br><span class=\"line\">  let o = &#123;&#125;;</span><br><span class=\"line\">  o[i] = obj[i];</span><br><span class=\"line\">  arr.push(o)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(arr) // [&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;]</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>数组转对象：\n        <div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.Object.assign 2.扩展运算符（...）</span><br><span class=\"line\">const arr = [1, 2, 3]</span><br><span class=\"line\">Object.assign(&#123;&#125;,[1,2,3]) // &#123;0: 1, 1: 2, 2: 3&#125;</span><br><span class=\"line\">&#123;...[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&#125; // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// forEach</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">arr.forEach((item,index)=&gt;&#123;obj[index] = item&#125;) // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// for...in</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</span><br><span class=\"line\">for(var key in arr)&#123;</span><br><span class=\"line\">  obj[key]=arr[key]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj // &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n        </div>\n    </li>\n    <li>\n\n    </li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"JavaScript判断对象是否一致","date":"2019-09-03T20:33:31.000Z","_content":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为\"真\"，则返回真</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).some(key => { return objA[key] !== objB[key] })\n    }\n    isObjEqual(a, b) // true:不一致 false:一致 \n    ```\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为\"假\"，则返回假</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).every(key => { return objA[key] === objB[key] })\n    }\n    isObjEqual(a, b) // true:一致 false:不一致 \n    ```\n    </div>\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>此处也可用for...in来实现</li>\n  <li>循环中断参考：https://juejin.im/entry/5884717a1b69e6005919f0d3</li>\n</ol>","source":"_posts/JavaScript/JavaScript判断对象是否一致.md","raw":"---\ntitle: JavaScript判断对象是否一致\ndate: 2019-09-04 04:33:31\ntags:\ncategories: JavaScript\n---\n<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为\"真\"，则返回真</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).some(key => { return objA[key] !== objB[key] })\n    }\n    isObjEqual(a, b) // true:不一致 false:一致 \n    ```\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为\"假\"，则返回假</span>\n    ```\n    const a = {age: 1, name: 'a'}\n    const b = {age: 1, name: 'b'}\n    function isObjEqual (objA, objB) {\n      return Object.keys(objA).every(key => { return objA[key] === objB[key] })\n    }\n    isObjEqual(a, b) // true:一致 false:不一致 \n    ```\n    </div>\n  </li>\n</ol>\n\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>此处也可用for...in来实现</li>\n  <li>循环中断参考：https://juejin.im/entry/5884717a1b69e6005919f0d3</li>\n</ol>","slug":"JavaScript/JavaScript判断对象是否一致","published":1,"updated":"2021-01-01T05:33:11.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9o0003uhxx9xcxf6te","content":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n\n<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为”真”，则返回真</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).some(key =&gt; &#123; return objA[key] !== objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:不一致 false:一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为”假”，则返回假</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).every(key =&gt; &#123; return objA[key] === objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:一致 false:不一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>此处也可用for…in来实现</li>\n  <li>循环中断参考：<a href=\"https://juejin.im/entry/5884717a1b69e6005919f0d3\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5884717a1b69e6005919f0d3</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p>方法：Object.keys ＋ some()(或者every())</p>\n\n<ol>\n  <li>Array.prototype.some()\n    <div>some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。<span class=\"red\">有一个为”真”，则返回真</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).some(key =&gt; &#123; return objA[key] !== objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:不一致 false:一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>Array.prototype.every()\n    <div>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。<span class=\"red\">有一个为”假”，则返回假</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const a = &#123;age: 1, name: &apos;a&apos;&#125;</span><br><span class=\"line\">const b = &#123;age: 1, name: &apos;b&apos;&#125;</span><br><span class=\"line\">function isObjEqual (objA, objB) &#123;</span><br><span class=\"line\">  return Object.keys(objA).every(key =&gt; &#123; return objA[key] === objB[key] &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">isObjEqual(a, b) // true:一致 false:不一致</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>此处也可用for…in来实现</li>\n  <li>循环中断参考：<a href=\"https://juejin.im/entry/5884717a1b69e6005919f0d3\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5884717a1b69e6005919f0d3</a></li>\n</ol>"},{"title":"JavaScript原型","date":"2019-10-27T16:33:25.000Z","_content":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<!-- more -->\n\n以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。\n\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n```\nfunction A() {}\n\nconst a = new A(); // new 并没有直接关联，间接关联(意外的副作用)\n\nObject.getPrototypeOf(a) === A.prototype // true\n```\n\n<p class=\"l30\">Object.create(...): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n```\n// ES6之前需要抛弃默认的A.prototype\nA.prototype = Object.create(B.prototype)\n\n// ES6开始可以直接修改现有的B.prototype\nObject.setPrototypeOf(A.prototype, B.prototype)\n\n```\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作\"字典\"，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n#未完待续#\n","source":"_posts/JavaScript/JavaScript原型.md","raw":"---\ntitle: JavaScript原型\ndate: 2019-10-28 00:33:25\ntags:\ncategories: JavaScript\n---\n<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<!-- more -->\n\n以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。\n\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n```\nfunction A() {}\n\nconst a = new A(); // new 并没有直接关联，间接关联(意外的副作用)\n\nObject.getPrototypeOf(a) === A.prototype // true\n```\n\n<p class=\"l30\">Object.create(...): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n```\n// ES6之前需要抛弃默认的A.prototype\nA.prototype = Object.create(B.prototype)\n\n// ES6开始可以直接修改现有的B.prototype\nObject.setPrototypeOf(A.prototype, B.prototype)\n\n```\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作\"字典\"，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n#未完待续#\n","slug":"JavaScript/JavaScript原型","published":1,"updated":"2021-01-01T05:33:24.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9q0006uhxxxhtqsh30","content":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>\n\n<a id=\"more\"></a>\n<p>以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。</p>\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = new A(); // new 并没有直接关联，间接关联(意外的副作用)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getPrototypeOf(a) === A.prototype // true</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(…): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6之前需要抛弃默认的A.prototype</span><br><span class=\"line\">A.prototype = Object.create(B.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6开始可以直接修改现有的B.prototype</span><br><span class=\"line\">Object.setPrototypeOf(A.prototype, B.prototype)</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作”字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n<p>#未完待续#</p>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.l30{text-indent:30px;}\n</style>\n\n<p>加深此处理解。</p>","more":"<p>以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。</p>\n<p class=\"l30\">“类是基于复制的，原型是基于关联的”</p>\n\n<p class=\"l30\">在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。</p>\n\n<p class=\"l30\">JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。</p>\n\n<p class=\"l30\">利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function A() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const a = new A(); // new 并没有直接关联，间接关联(意外的副作用)</span><br><span class=\"line\"></span><br><span class=\"line\">Object.getPrototypeOf(a) === A.prototype // true</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(…): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。</p>\n\n<p class=\"l30\">e.g.把A.prototype关联到B.prototype的方法：</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// ES6之前需要抛弃默认的A.prototype</span><br><span class=\"line\">A.prototype = Object.create(B.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// ES6开始可以直接修改现有的B.prototype</span><br><span class=\"line\">Object.setPrototypeOf(A.prototype, B.prototype)</span><br></pre></td></tr></table></figure>\n<p class=\"l30\">Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作”字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>函数的特殊特性？\n    </li>\n</ol>\n\n<p>#未完待续#</p>"},{"title":"JavaScript实现继承的几种方式","date":"2019-06-09T05:39:07.000Z","toc":true,"_content":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<!-- more -->\n\n以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。\n\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n```\n    function Animal() {\n        this.home = \"earth\"\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(color) {\n        this.color = color\n    }\n\n    // 原型对象等于另一个类型的实例\n    Cat.prototype = new Animal()\n\n    // 添加新方法\n    Cat.prototype.eat = function () {\n        return \"fish\"\n    }\n\n    var whiteCat = new Cat()\n    \n    alert(whiteCat.home) // \"earth\"\n    alert(whiteCat.say()) // \"hello\"\n    alert(whiteCat.eat()) // \"fish\"\n```\n\n<注>\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n```\n    function Animal() {\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    function Cat() {\n        Animal.call(this)\n    }\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors = \"black\"\n\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // \"black\"\n```\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n```\n    function Animal(age) {\n        this.age = age\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(age) {\n        // 继承属性\n        Animal.call(this, age)\n    }\n\n    // 继承方法\n    Cat.prototype = new Animal();\n\n    Cat.prototype.constructor = Cat;\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors.push(\"black\")\n\n    calico.say() // \"hello\"\n    blackCat.say() // \"hello\"\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // [\"red\", \"blue\", \"yellow\", \"black\"]\n\n```\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<注>\n    <p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p>\n\n<h4>寄生组合式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n```\n    function inheritPrototype(subType, superType){\n        var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)\n        prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性\n        subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型\n    }\n    function Animal(name) {\n        this.name = name;\n    }\n    Animal.prototype.sayName = function () {\n        alert(this.name);\n    };\n    function Cat(name, age) {\n        Animal.call(this,name);  //继承SuperType\n        this.age = age;       //扩展出age属性\n    }\n    inheritPrototype(Cat, Animal);\n    Cat.prototype.sayAge = function () {\n        alert(this.age);\n    };//扩展出sayAge方法\n\n    var calico=new Cat(\"linda\",2);\n    calico.sayName();\n    calico.sayAge();\n```\n\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<h4 style=\"color:blue;\">ES6实现继承</h4>\n<p style=\"text-indent:30px\"></p>\n```\nclass Animal {\n    //构造函数\n    constructor(props) {\n      this.name = props.name || '未知';\n    }\n\n    eat() {\n      alert(this.name + \"在吃东西...\");\n    }\n  }\n\n  //class继承\n  class Bird extends Animal {\n    //构造函数\n    constructor(props) {\n      //调用实现父类的构造函数\n      super(props);\n      this.type = props.type || \"未知\";\n    }\n\n    fly() {\n      alert(this.name + \"在飞...\");\n    }\n  }\n  var myBird = new Bird({\n    name: '鹦鹉'\n  })\n  myBird.eat()\n  myBird.fly()\n```\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","source":"_posts/JavaScript/JavaScript实现继承的几种方式.md","raw":"---\ntitle: JavaScript实现继承的几种方式\ndate: 2019-06-09 13:39:07\ntoc: true\ncategories: JavaScript\n# thumbnail: img/shell.jpg\n---\n<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<!-- more -->\n\n以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。\n\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n```\n    function Animal() {\n        this.home = \"earth\"\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(color) {\n        this.color = color\n    }\n\n    // 原型对象等于另一个类型的实例\n    Cat.prototype = new Animal()\n\n    // 添加新方法\n    Cat.prototype.eat = function () {\n        return \"fish\"\n    }\n\n    var whiteCat = new Cat()\n    \n    alert(whiteCat.home) // \"earth\"\n    alert(whiteCat.say()) // \"hello\"\n    alert(whiteCat.eat()) // \"fish\"\n```\n\n<注>\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n```\n    function Animal() {\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    function Cat() {\n        Animal.call(this)\n    }\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors = \"black\"\n\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // \"black\"\n```\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n```\n    function Animal(age) {\n        this.age = age\n        this.colors = [\"red\",\"blue\",\"yellow\"]\n    }\n\n    Animal.prototype.say = function () {\n        return \"hello\"\n    }\n\n    function Cat(age) {\n        // 继承属性\n        Animal.call(this, age)\n    }\n\n    // 继承方法\n    Cat.prototype = new Animal();\n\n    Cat.prototype.constructor = Cat;\n\n    var calico = new Cat()\n\n    calico.colors.push(\"white\")\n\n    var blackCat = new Cat()\n\n    blackCat.colors.push(\"black\")\n\n    calico.say() // \"hello\"\n    blackCat.say() // \"hello\"\n    console.log(calico.colors) // [\"red\", \"blue\", \"yellow\", \"white\"]\n    console.log(blackCat.colors) // [\"red\", \"blue\", \"yellow\", \"black\"]\n\n```\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n<注>\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<注>\n    <p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p>\n\n<h4>寄生组合式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n```\n    function inheritPrototype(subType, superType){\n        var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)\n        prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性\n        subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型\n    }\n    function Animal(name) {\n        this.name = name;\n    }\n    Animal.prototype.sayName = function () {\n        alert(this.name);\n    };\n    function Cat(name, age) {\n        Animal.call(this,name);  //继承SuperType\n        this.age = age;       //扩展出age属性\n    }\n    inheritPrototype(Cat, Animal);\n    Cat.prototype.sayAge = function () {\n        alert(this.age);\n    };//扩展出sayAge方法\n\n    var calico=new Cat(\"linda\",2);\n    calico.sayName();\n    calico.sayAge();\n```\n\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<h4 style=\"color:blue;\">ES6实现继承</h4>\n<p style=\"text-indent:30px\"></p>\n```\nclass Animal {\n    //构造函数\n    constructor(props) {\n      this.name = props.name || '未知';\n    }\n\n    eat() {\n      alert(this.name + \"在吃东西...\");\n    }\n  }\n\n  //class继承\n  class Bird extends Animal {\n    //构造函数\n    constructor(props) {\n      //调用实现父类的构造函数\n      super(props);\n      this.type = props.type || \"未知\";\n    }\n\n    fly() {\n      alert(this.name + \"在飞...\");\n    }\n  }\n  var myBird = new Bird({\n    name: '鹦鹉'\n  })\n  myBird.eat()\n  myBird.fly()\n```\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","slug":"JavaScript/JavaScript实现继承的几种方式","published":1,"updated":"2021-01-01T05:33:16.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9r0008uhxx9ld58p37","content":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n\n<a id=\"more\"></a>\n<p>以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。</p>\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.home = &quot;earth&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(color) &#123;</span><br><span class=\"line\">    this.color = color</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 原型对象等于另一个类型的实例</span><br><span class=\"line\">Cat.prototype = new Animal()</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加新方法</span><br><span class=\"line\">Cat.prototype.eat = function () &#123;</span><br><span class=\"line\">    return &quot;fish&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var whiteCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(whiteCat.home) // &quot;earth&quot;</span><br><span class=\"line\">alert(whiteCat.say()) // &quot;hello&quot;</span><br><span class=\"line\">alert(whiteCat.eat()) // &quot;fish&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat() &#123;</span><br><span class=\"line\">    Animal.call(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors = &quot;black&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // &quot;black&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(age) &#123;</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(age) &#123;</span><br><span class=\"line\">    // 继承属性</span><br><span class=\"line\">    Animal.call(this, age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承方法</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors.push(&quot;black&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">calico.say() // &quot;hello&quot;</span><br><span class=\"line\">blackCat.say() // &quot;hello&quot;</span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<p>&lt;注&gt;\n    </p><p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p><p></p>\n<p></p><h4>寄生组合式继承</h4><p></p>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)</span><br><span class=\"line\">    prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性</span><br><span class=\"line\">    subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Animal(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sayName = function () &#123;</span><br><span class=\"line\">    alert(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Cat(name, age) &#123;</span><br><span class=\"line\">    Animal.call(this,name);  //继承SuperType</span><br><span class=\"line\">    this.age = age;       //扩展出age属性</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Cat, Animal);</span><br><span class=\"line\">Cat.prototype.sayAge = function () &#123;</span><br><span class=\"line\">    alert(this.age);</span><br><span class=\"line\">&#125;;//扩展出sayAge方法</span><br><span class=\"line\"></span><br><span class=\"line\">var calico=new Cat(&quot;linda&quot;,2);</span><br><span class=\"line\">calico.sayName();</span><br><span class=\"line\">calico.sayAge();</span><br></pre></td></tr></table></figure>\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<p></p><h4 style=\"color:blue;\">ES6实现继承</h4><p></p>\n<p></p><p style=\"text-indent:30px\"></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &apos;未知&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在吃东西...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.type = props.type || &quot;未知&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在飞...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &apos;鹦鹉&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>\n\n","site":{"data":{}},"excerpt":"<p>继承：是<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" target=\"_blank\" rel=\"noopener\">面向对象（to:wiki）</a>Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>","more":"<p>以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。</p>\n<h4>原型链</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<p style=\"text-indent:30px\">类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。<span style=\"color:red;\">让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。</span>层层递进，就构成了实例和原型的链条。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.home = &quot;earth&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(color) &#123;</span><br><span class=\"line\">    this.color = color</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 原型对象等于另一个类型的实例</span><br><span class=\"line\">Cat.prototype = new Animal()</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加新方法</span><br><span class=\"line\">Cat.prototype.eat = function () &#123;</span><br><span class=\"line\">    return &quot;fish&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var whiteCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">alert(whiteCat.home) // &quot;earth&quot;</span><br><span class=\"line\">alert(whiteCat.say()) // &quot;hello&quot;</span><br><span class=\"line\">alert(whiteCat.eat()) // &quot;fish&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <ol>\n        <li>给原型添加方法的代码一定要放在替换原型的语句之后；</li>\n        <li>不能使用对象字面量创建原型方法；</li>\n        <li>原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰；</li>\n        <li>没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数；</li>\n    </ol>\n    <p>则<span style=\"color:red;\">很少单独使用</span></p>\n\n\n<h4>借用构造函数</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal() &#123;</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat() &#123;</span><br><span class=\"line\">    Animal.call(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors = &quot;black&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // &quot;black&quot;</span><br></pre></td></tr></table></figure>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则<span style=\"color:red;\">很少单独使用</span></p>\n\n<h4>组合继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Animal(age) &#123;</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">    this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Animal.prototype.say = function () &#123;</span><br><span class=\"line\">    return &quot;hello&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Cat(age) &#123;</span><br><span class=\"line\">    // 继承属性</span><br><span class=\"line\">    Animal.call(this, age)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 继承方法</span><br><span class=\"line\">Cat.prototype = new Animal();</span><br><span class=\"line\"></span><br><span class=\"line\">Cat.prototype.constructor = Cat;</span><br><span class=\"line\"></span><br><span class=\"line\">var calico = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">calico.colors.push(&quot;white&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var blackCat = new Cat()</span><br><span class=\"line\"></span><br><span class=\"line\">blackCat.colors.push(&quot;black&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">calico.say() // &quot;hello&quot;</span><br><span class=\"line\">blackCat.say() // &quot;hello&quot;</span><br><span class=\"line\">console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]</span><br><span class=\"line\">console.log(blackCat.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>则为<span style=\"color:red;\">最常用的继承模式</span></p>\n\n\n<h4>原型式继承</h4>\n<p style=\"text-indent:30px\">实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。</p>\n<p style=\"text-indent:30px\">Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。</p>\n<p style=\"text-indent:30px\">原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</p>\n\n&lt;注&gt;\n    <p style=\"text-indent:30px\">采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome</p>\n\n<h4>寄生式继承</h4>\n\n<p style=\"text-indent:30px\">实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>\n\n<p style=\"text-indent:30px\">为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用</p>\n\n<p>&lt;注&gt;\n    </p><p style=\"text-indent:30px\">基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。</p><p></p>\n<p></p><h4>寄生组合式继承</h4><p></p>\n<p style=\"text-indent:30px\">实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数</p>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function inheritPrototype(subType, superType)&#123;</span><br><span class=\"line\">    var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype)</span><br><span class=\"line\">    prototype.constructor = subType;   //为副本添加constructor属性,弥补重写原型而失去的constructor属性</span><br><span class=\"line\">    subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Animal(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Animal.prototype.sayName = function () &#123;</span><br><span class=\"line\">    alert(this.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">function Cat(name, age) &#123;</span><br><span class=\"line\">    Animal.call(this,name);  //继承SuperType</span><br><span class=\"line\">    this.age = age;       //扩展出age属性</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">inheritPrototype(Cat, Animal);</span><br><span class=\"line\">Cat.prototype.sayAge = function () &#123;</span><br><span class=\"line\">    alert(this.age);</span><br><span class=\"line\">&#125;;//扩展出sayAge方法</span><br><span class=\"line\"></span><br><span class=\"line\">var calico=new Cat(&quot;linda&quot;,2);</span><br><span class=\"line\">calico.sayName();</span><br><span class=\"line\">calico.sayAge();</span><br></pre></td></tr></table></figure>\n<p>普遍认寄生组合式继承为<span style=\"color:red;\">引用类型最理想的继承范式。</span></p>\n\n<p></p><h4 style=\"color:blue;\">ES6实现继承</h4><p></p>\n<p></p><p style=\"text-indent:30px\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      this.name = props.name || &apos;未知&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    eat() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在吃东西...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //class继承</span><br><span class=\"line\">  class Bird extends Animal &#123;</span><br><span class=\"line\">    //构造函数</span><br><span class=\"line\">    constructor(props) &#123;</span><br><span class=\"line\">      //调用实现父类的构造函数</span><br><span class=\"line\">      super(props);</span><br><span class=\"line\">      this.type = props.type || &quot;未知&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fly() &#123;</span><br><span class=\"line\">      alert(this.name + &quot;在飞...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  var myBird = new Bird(&#123;</span><br><span class=\"line\">    name: &apos;鹦鹉&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  myBird.eat()</span><br><span class=\"line\">  myBird.fly()</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n    <li>什么是引用类型？\n        <p>基本类型(number,string,boolean,null,undefined)之外就是引用类型</p>\n    </li>\n    <li>存储上的区别？\n        <p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存）</p>\n        <p>引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址</p>\n    </li>\n</ol>"},{"title":"JavaScript的set和get","date":"2021-01-11T02:48:32.000Z","_content":"\n<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<!-- more -->\n\n<ol>\n  <li>ES6的set和get：\n    <div>\n      ```\n      class MyClass {\n        constructor () {\n          this.data = {}\n        }\n\n        set prop (value) {\n          this.data = value\n        }\n\n        get prop () {\n          return this.data\n        }\n      }\n\n      const test = new MyClass()\n      test.prop = 123\n      test.prop // output:'123'\n      ```\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    ```\n    let book = {\n      _year: 2020,\n      edition: 1\n    }\n    Object.defineProperty(book, 'year', {\n      get: function () {\n        return this._year\n      },\n      set: function (newValue) {\n        this._year = newValue\n        this.edition++\n      }\n    })\n    ```\n    </div>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","source":"_posts/JavaScript/JavaScript的set和get.md","raw":"---\ntitle: JavaScript的set和get\ndate: 2021-01-11 10:48:32\ntags: 编程语言\ncategories: JavaScript\n---\n\n<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<!-- more -->\n\n<ol>\n  <li>ES6的set和get：\n    <div>\n      ```\n      class MyClass {\n        constructor () {\n          this.data = {}\n        }\n\n        set prop (value) {\n          this.data = value\n        }\n\n        get prop () {\n          return this.data\n        }\n      }\n\n      const test = new MyClass()\n      test.prop = 123\n      test.prop // output:'123'\n      ```\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    ```\n    let book = {\n      _year: 2020,\n      edition: 1\n    }\n    Object.defineProperty(book, 'year', {\n      get: function () {\n        return this._year\n      },\n      set: function (newValue) {\n        this._year = newValue\n        this.edition++\n      }\n    })\n    ```\n    </div>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","slug":"JavaScript/JavaScript的set和get","published":1,"updated":"2021-01-11T04:56:14.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9v000auhxxw59ea19x","content":"<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>ES6的set和get：\n    <div>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.data = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop (value) &#123;</span><br><span class=\"line\">    this.data = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop () &#123;</span><br><span class=\"line\">    return this.data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const test = new MyClass()</span><br><span class=\"line\">test.prop = 123</span><br><span class=\"line\">test.prop // output:&apos;123&apos;</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &apos;year&apos;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>","site":{"data":{}},"excerpt":"<p>JavaScript如何定义赋值？赋值的方式有哪些？</p>","more":"<ol>\n  <li>ES6的set和get：\n    <div>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">  constructor () &#123;</span><br><span class=\"line\">    this.data = &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop (value) &#123;</span><br><span class=\"line\">    this.data = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop () &#123;</span><br><span class=\"line\">    return this.data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const test = new MyClass()</span><br><span class=\"line\">test.prop = 123</span><br><span class=\"line\">test.prop // output:&apos;123&apos;</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n  <li>ES6的set和get：\n    <div>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let book = &#123;</span><br><span class=\"line\">  _year: 2020,</span><br><span class=\"line\">  edition: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.defineProperty(book, &apos;year&apos;, &#123;</span><br><span class=\"line\">  get: function () &#123;</span><br><span class=\"line\">    return this._year</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  set: function (newValue) &#123;</span><br><span class=\"line\">    this._year = newValue</span><br><span class=\"line\">    this.edition++</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n    </div>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    ES6的Symbol的key的实现\n  </li>\n</ol>"},{"title":"Javascript内存管理","date":"2019-08-28T16:00:05.000Z","_content":"<p>总结Javascript内存相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<h5>回顾基础知识:</h5>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<h5>重点:</h5>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<h5>优化内存:</h5>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  ```\n  let obj = new dialog()\n  obj = null\n  ```\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<h5>补充</h5>\n<h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<h5>思考&扩展</h5>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n#未完待续#","source":"_posts/JavaScript/Javascript内存管理.md","raw":"---\ntitle: Javascript内存管理\ndate: 2019-08-29 00:00:05\ntags: 编程语言\ncategories: JavaScript\n---\n<p>总结Javascript内存相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\n<h5>回顾基础知识:</h5>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<h5>重点:</h5>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<h5>优化内存:</h5>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  ```\n  let obj = new dialog()\n  obj = null\n  ```\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<h5>补充</h5>\n<h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<h5>思考&扩展</h5>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n#未完待续#","slug":"JavaScript/Javascript内存管理","published":1,"updated":"2021-01-01T05:33:06.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9w000cuhxxgr6baymb","content":"<p></p><p>总结Javascript内存相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p></p><h5>回顾基础知识:</h5><p></p>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<p></p><h5>重点:</h5><p></p>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<p></p><h5>优化内存:</h5><p></p>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = new dialog()</span><br><span class=\"line\">obj = null</span><br></pre></td></tr></table></figure>\n\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<p></p><h5>补充</h5><p></p>\n<p></p><h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5><p></p>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<p></p><h5>思考&amp;扩展</h5><p></p>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n<p>#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p></p><p>总结Javascript内存相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p></p><h5>回顾基础知识:</h5><p></p>\n<ol>\n  <li>基本数据类型：Undefined、Null、Boolean、Number、String、<span class=\"red\">Symbol</span></li>\n  <li>引用数据类型：Function、Array、Object</li>\n</ol>\n\n<p></p><h5>重点:</h5><p></p>\n<ol>\n  <li>基本类型值在内存中占据固定大小的空间，因此被保存在<a href=\"#index\">栈内存</a>中。</li>\n  <li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个<span class=\"red\">副本</span>。</li>\n  <li>引用类型的值是对象，保存在<a href=\"#index\">堆内存</a>中。</li>\n  <li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的<span class=\"red\">指针</span>。</li>\n  <li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。</li>\n  <li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符</li>\n</ol>\n\n<p></p><h5>优化内存:</h5><p></p>\n<ol>\n  <li>为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－<span class=\"red\">解除引用</span>。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = new dialog()</span><br><span class=\"line\">obj = null</span><br></pre></td></tr></table></figure>\n\n  注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。\n  </li>\n  <li>浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。</li>\n</ol>\n\n\n<p></p><h5>补充</h5><p></p>\n<p></p><h5 name=\"index\">堆内存(heap)和栈内存(stack)区别:</h5><p></p>\n<ol>\n  <li>在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活</li>\n  <li>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享</li>\n</ol>\n\n<p></p><h5>思考&amp;扩展</h5><p></p>\n<ol>\n  <li>副本？</li>\n  <li>指针？</li>\n  <li>堆栈？</li>\n  <li>变量生命周期？</li>\n  <li>传值还是引用？</li>\n  <li>深浅拷贝</li>\n</ol>\n\n<p>#未完待续#</p>"},{"title":"this机制","date":"2020-09-02T03:52:38.000Z","toc":true,"_content":"\n<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<!-- more -->\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","source":"_posts/JavaScript/this机制.md","raw":"---\ntitle: this机制\ndate: 2020-09-02 11:52:38\ntoc: true\ncategories: JavaScript\n---\n\n<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<!-- more -->\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","slug":"JavaScript/this机制","published":1,"updated":"2021-01-01T05:33:28.269Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9x000fuhxxivh7bvc2","content":"<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">\n  提出问题：\n</p>\n","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">\n  从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。\n</p>","more":"<p style=\"text-indent:30px\">\n  提出问题：\n</p>"},{"title":"如何手动实现form表单提交的url","date":"2019-09-03T19:41:50.000Z","_content":"<p>这个问题比较有趣，记录一下！</p>\n\n<!-- more -->\n\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p>方法: Object.entries(for...in) + map</p>\n```\nconst params = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4\n}\n\nconst paramsString = Object.entries(params).map(item => {\n  return item[0] + '=' + item[1]\n}).join('&')\n\nconst url = 'https://www.google.com?' + paramsString\n\n// output: https://www.google.com?a=1&b=2&c=3&d=4\n\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  ```\n  const obj = { foo: 'bar', baz: 42 };\n  console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n  ```\n  </li>\n  <li>Object.entries()和for...in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for...in好，故用的也比较少。for...in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for...in</div>\n  </li>\n</ol>\n","source":"_posts/JavaScript/如何手动实现form表单提交的url.md","raw":"---\ntitle: 如何手动实现form表单提交的url\ndate: 2019-09-04 03:41:50\ntags:\ncategories: JavaScript\n---\n<p>这个问题比较有趣，记录一下！</p>\n\n<!-- more -->\n\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p>方法: Object.entries(for...in) + map</p>\n```\nconst params = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4\n}\n\nconst paramsString = Object.entries(params).map(item => {\n  return item[0] + '=' + item[1]\n}).join('&')\n\nconst url = 'https://www.google.com?' + paramsString\n\n// output: https://www.google.com?a=1&b=2&c=3&d=4\n\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  ```\n  const obj = { foo: 'bar', baz: 42 };\n  console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]\n\n  ```\n  </li>\n  <li>Object.entries()和for...in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for...in好，故用的也比较少。for...in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for...in</div>\n  </li>\n</ol>\n","slug":"JavaScript/如何手动实现form表单提交的url","published":1,"updated":"2021-01-01T05:32:54.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoa9y000iuhxxp4btkrto","content":"<p>这个问题比较有趣，记录一下！</p>\n\n<a id=\"more\"></a>\n<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&amp;”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p></p><p>方法: Object.entries(for…in) + map</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const params = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3,</span><br><span class=\"line\">  d: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const paramsString = Object.entries(params).map(item =&gt; &#123;</span><br><span class=\"line\">  return item[0] + &apos;=&apos; + item[1]</span><br><span class=\"line\">&#125;).join(&apos;&amp;&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const url = &apos;https://www.google.com?&apos; + paramsString</span><br><span class=\"line\"></span><br><span class=\"line\">// output: https://www.google.com?a=1&amp;b=2&amp;c=3&amp;d=4</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class=\"line\">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.entries()和for…in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for…in好，故用的也比较少。for…in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for…in</div>\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这个问题比较有趣，记录一下！</p>","more":"<p>遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！</p>\n<p>但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&amp;”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。</p>\n<p>那该如何去写呢？</p>\n\n<p></p><p>方法: Object.entries(for…in) + map</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const params = &#123;</span><br><span class=\"line\">  a: 1,</span><br><span class=\"line\">  b: 2,</span><br><span class=\"line\">  c: 3,</span><br><span class=\"line\">  d: 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const paramsString = Object.entries(params).map(item =&gt; &#123;</span><br><span class=\"line\">  return item[0] + &apos;=&apos; + item[1]</span><br><span class=\"line\">&#125;).join(&apos;&amp;&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">const url = &apos;https://www.google.com?&apos; + paramsString</span><br><span class=\"line\"></span><br><span class=\"line\">// output: https://www.google.com?a=1&amp;b=2&amp;c=3&amp;d=4</span><br></pre></td></tr></table></figure><p></p>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）</li>\n  <li>Object.entries()示例\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const obj = &#123; foo: &apos;bar&apos;, baz: 42 &#125;;</span><br><span class=\"line\">console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>Object.entries()和for…in对比\n    <div>Object.entries()不支持IE，其他浏览器支持性也没for…in好，故用的也比较少。for…in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for…in</div>\n  </li>\n</ol>"},{"title":"深拷贝&浅拷贝","date":"2020-12-21T15:52:27.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6908606240356581389</li>\n</ol>\n","source":"_posts/JavaScript/深拷贝&浅拷贝.md","raw":"---\ntitle: 深拷贝&浅拷贝\ndate: 2020-12-21 23:52:27\ntags: 编程语言\ncategories: JavaScript\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6908606240356581389</li>\n</ol>\n","slug":"JavaScript/深拷贝&浅拷贝","published":1,"updated":"2021-01-01T05:32:58.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa0000kuhxxtc9mueua","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6908606240356581389\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6908606240356581389</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6908606240356581389\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6908606240356581389</a></li>\n</ol>\n"},{"title":"请求后台数据的几种方式","date":"2019-07-03T07:35:58.000Z","_content":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<!-- more -->\n\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        ```\n        var xmlhttp;\n        function loadXMLDoc(url)\n        {\n            xmlhttp=null;\n            if (window.XMLHttpRequest)\n            {   \n                xmlhttp=new XMLHttpRequest();\n            } else if (window.ActiveXObject) {\n                // for IE5 and IE6\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            if (xmlhttp != null)\n            {\n                xmlhttp.onreadystatechange=state_Change;\n                // Get请求\n                xmlhttp.open(\"GET\",url,true);\n                xmlhttp.send(null);\n                // POST请求\n                <!-- xhr.open('POST', '/user/login');\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                var param = {\n                    name = 'peter'\n                }\n                xmlHttp.send(param) -->\n            } else {\n                alert(\"Your browser does not support XMLHTTP.\");\n            }\n        }\n\n        function state_Change()\n        {\n            if (xmlhttp.readyState==4)\n            {\n                // 4 = \"loaded\"\n                if (xmlhttp.status==200)\n                {\n                    // 200 = OK\n                    console.log(JSON.parse(xhr.responseText))\n                } else {\n                    alert(\"Problem retrieving XML data\");\n                }\n            }\n        }\n        ```\n        <div>\n           <p> more：</p>\n            http://www.w3school.com.cn/xml/xml_http.asp\n            https://www.cnblogs.com/aimeeblogs/articles/9501946.html\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        ```\n        $.ajax({\n            type: 'POST',\n            url: url,\n            data: data,\n            dataType: dataType,\n            success: function () {},\n            error: function () {}\n        );\n        ```\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        ```\n        axios.get('/user', {\n            params: {\n                ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n        ```\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： https://www.kancloud.cn/yunye/axios/234845</p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：https://segmentfault.com/a/1190000012836882</p>\n    </li>\n</ol>","source":"_posts/JavaScript/请求后台数据的几种方式.md","raw":"---\ntitle: 请求后台数据的几种方式\ndate: 2019-07-03 15:35:58\ntags: 前后端分离\ncategories: JavaScript\n---\n<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<!-- more -->\n\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        ```\n        var xmlhttp;\n        function loadXMLDoc(url)\n        {\n            xmlhttp=null;\n            if (window.XMLHttpRequest)\n            {   \n                xmlhttp=new XMLHttpRequest();\n            } else if (window.ActiveXObject) {\n                // for IE5 and IE6\n                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n            }\n\n            if (xmlhttp != null)\n            {\n                xmlhttp.onreadystatechange=state_Change;\n                // Get请求\n                xmlhttp.open(\"GET\",url,true);\n                xmlhttp.send(null);\n                // POST请求\n                <!-- xhr.open('POST', '/user/login');\n                xhr.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\");\n                var param = {\n                    name = 'peter'\n                }\n                xmlHttp.send(param) -->\n            } else {\n                alert(\"Your browser does not support XMLHTTP.\");\n            }\n        }\n\n        function state_Change()\n        {\n            if (xmlhttp.readyState==4)\n            {\n                // 4 = \"loaded\"\n                if (xmlhttp.status==200)\n                {\n                    // 200 = OK\n                    console.log(JSON.parse(xhr.responseText))\n                } else {\n                    alert(\"Problem retrieving XML data\");\n                }\n            }\n        }\n        ```\n        <div>\n           <p> more：</p>\n            http://www.w3school.com.cn/xml/xml_http.asp\n            https://www.cnblogs.com/aimeeblogs/articles/9501946.html\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        ```\n        $.ajax({\n            type: 'POST',\n            url: url,\n            data: data,\n            dataType: dataType,\n            success: function () {},\n            error: function () {}\n        );\n        ```\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        ```\n        axios.get('/user', {\n            params: {\n                ID: 12345\n            }\n        })\n        .then(function (response) {\n            console.log(response);\n        })\n        .catch(function (error) {\n            console.log(error);\n        });\n        ```\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： https://www.kancloud.cn/yunye/axios/234845</p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：https://segmentfault.com/a/1190000012836882</p>\n    </li>\n</ol>","slug":"JavaScript/请求后台数据的几种方式","published":1,"updated":"2021-01-01T05:32:49.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa1000muhxxlylrdg1p","content":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>\n\n<a id=\"more\"></a>\n<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp=null;</span><br><span class=\"line\">    if (window.XMLHttpRequest)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">    &#125; else if (window.ActiveXObject) &#123;</span><br><span class=\"line\">        // for IE5 and IE6</span><br><span class=\"line\">        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (xmlhttp != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">        // Get请求</span><br><span class=\"line\">        xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">        xmlhttp.send(null);</span><br><span class=\"line\">        // POST请求</span><br><span class=\"line\">        &lt;!-- xhr.open(&apos;POST&apos;, &apos;/user/login&apos;);</span><br><span class=\"line\">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">        var param = &#123;</span><br><span class=\"line\">            name = &apos;peter&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xmlHttp.send(param) --&gt;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState==4)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 4 = &quot;loaded&quot;</span><br><span class=\"line\">        if (xmlhttp.status==200)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 200 = OK</span><br><span class=\"line\">            console.log(JSON.parse(xhr.responseText))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            alert(&quot;Problem retrieving XML data&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n        <div>\n           <p> more：</p>\n            <a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a>\n            <a href=\"https://www.cnblogs.com/aimeeblogs/articles/9501946.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aimeeblogs/articles/9501946.html</a>\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;POST&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    dataType: dataType,</span><br><span class=\"line\">    success: function () &#123;&#125;,</span><br><span class=\"line\">    error: function () &#123;&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： <a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/yunye/axios/234845</a></p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：<a href=\"https://segmentfault.com/a/1190000012836882\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012836882</a></p>\n    </li>\n</ol>","site":{"data":{}},"excerpt":"<p>XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。</p>","more":"<ol>\n    <li>XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现)\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    xmlhttp=null;</span><br><span class=\"line\">    if (window.XMLHttpRequest)</span><br><span class=\"line\">    &#123;   </span><br><span class=\"line\">        xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">    &#125; else if (window.ActiveXObject) &#123;</span><br><span class=\"line\">        // for IE5 and IE6</span><br><span class=\"line\">        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (xmlhttp != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">        // Get请求</span><br><span class=\"line\">        xmlhttp.open(&quot;GET&quot;,url,true);</span><br><span class=\"line\">        xmlhttp.send(null);</span><br><span class=\"line\">        // POST请求</span><br><span class=\"line\">        &lt;!-- xhr.open(&apos;POST&apos;, &apos;/user/login&apos;);</span><br><span class=\"line\">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class=\"line\">        var param = &#123;</span><br><span class=\"line\">            name = &apos;peter&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        xmlHttp.send(param) --&gt;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xmlhttp.readyState==4)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        // 4 = &quot;loaded&quot;</span><br><span class=\"line\">        if (xmlhttp.status==200)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            // 200 = OK</span><br><span class=\"line\">            console.log(JSON.parse(xhr.responseText))</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            alert(&quot;Problem retrieving XML data&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n        <div>\n           <p> more：</p>\n            <a href=\"http://www.w3school.com.cn/xml/xml_http.asp\" target=\"_blank\" rel=\"noopener\">http://www.w3school.com.cn/xml/xml_http.asp</a>\n            <a href=\"https://www.cnblogs.com/aimeeblogs/articles/9501946.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/aimeeblogs/articles/9501946.html</a>\n        </div>\n    </li>\n    <li>JQuery Ajax\n        <p style=\"margin-top:4px;font-weight:bold;\">基于对原生XHR的封装，除此以外还增添了对JSONP的支持</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;</span><br><span class=\"line\">    type: &apos;POST&apos;,</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    data: data,</span><br><span class=\"line\">    dataType: dataType,</span><br><span class=\"line\">    success: function () &#123;&#125;,</span><br><span class=\"line\">    error: function () &#123;&#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n        <div>\n            缺点：\n            <ul>\n                <li>本身是针对MVC的编程,不符合现在前端MVVM的浪潮</li>\n                <li>基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</li>\n                <li>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n            </ul>\n        </div>\n    </li>\n    <li>\n        <p style=\"color:red;\">Axios</p>\n        <p style=\"margin-top:4px;font-weight:bold;\">Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios.get(&apos;/user&apos;, &#123;</span><br><span class=\"line\">    params: &#123;</span><br><span class=\"line\">        ID: 12345</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.then(function (response) &#123;</span><br><span class=\"line\">    console.log(response);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n        <div>Features:\n            <ul>\n                <li>从浏览器中创建XMLHttpRequests</li>\n                <li>从node.js创建http请求</li>\n                <li>支持Promise API</li>\n                <li>拦截请求和响应</li>\n                <li>转换请求数据和响应数据</li>\n                <li>取消请求</li>\n                <li>自动转换JSON数据</li>\n                <li>客户端支持防御XSRF</li>\n            </ul>\n        </div>\n        <div>\n           <p> more： <a href=\"https://www.kancloud.cn/yunye/axios/234845\" target=\"_blank\" rel=\"noopener\">https://www.kancloud.cn/yunye/axios/234845</a></p>\n        </div>\n    </li>\n    <li>Fetch\n        <p style=\"margin-top:10px;\">(需更多了解完善)</p>\n        <p> more：<a href=\"https://segmentfault.com/a/1190000012836882\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000012836882</a></p>\n    </li>\n</ol>"},{"title":"函数防抖和节流","date":"2021-01-11T15:13:25.000Z","_content":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<!-- more -->\n\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        ```\n        var timer;\n        function debounce (fn, delay, ...args) {\n          clearTimeout(timer)\n          timer = setTimeout(() => {\n            console.log(args)\n            fn(args)\n          }, delay)\n        }\n\n        document.onclick = function () {\n          debounce(testDebounce, 5000, 1111, 2222)\n        }\n\n        function testDebounce (...args) {\n          console.log(args)\n        }\n        ```\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        ```\n        function throttle (fn, delay) {\n          var previous = 0\n          // 使用闭包返回一个函数并且用到闭包函数外面的变量previous\n          return function () {\n            var _this = this\n            var args = arguments\n            var now = new Date()\n            if (now - previous > delay) {\n              fn.apply(_this, args)\n\n              previous = now\n            }\n          }\n        }\n\n        var testThrottleFn = throttle(testThrottle, 5000) // 节流函数\n\n        document.onclick = function (e) {\n          testThrottleFn(e, 'throttle') // 给节流函数传参\n        }\n\n        function testThrottle (e, content) {\n          console.log(e, content)\n        }\n        ```\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","source":"_posts/JavaScript/防抖和节流.md","raw":"---\ntitle: 函数防抖和节流\ndate: 2021-01-11 23:13:25\ntags:\ncategories: JavaScript\n---\n<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<!-- more -->\n\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        ```\n        var timer;\n        function debounce (fn, delay, ...args) {\n          clearTimeout(timer)\n          timer = setTimeout(() => {\n            console.log(args)\n            fn(args)\n          }, delay)\n        }\n\n        document.onclick = function () {\n          debounce(testDebounce, 5000, 1111, 2222)\n        }\n\n        function testDebounce (...args) {\n          console.log(args)\n        }\n        ```\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        ```\n        function throttle (fn, delay) {\n          var previous = 0\n          // 使用闭包返回一个函数并且用到闭包函数外面的变量previous\n          return function () {\n            var _this = this\n            var args = arguments\n            var now = new Date()\n            if (now - previous > delay) {\n              fn.apply(_this, args)\n\n              previous = now\n            }\n          }\n        }\n\n        var testThrottleFn = throttle(testThrottle, 5000) // 节流函数\n\n        document.onclick = function (e) {\n          testThrottleFn(e, 'throttle') // 给节流函数传参\n        }\n\n        function testThrottle (e, content) {\n          console.log(e, content)\n        }\n        ```\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","slug":"JavaScript/防抖和节流","published":1,"updated":"2021-01-12T03:09:32.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa2000puhxxdr0ry871","content":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>\n\n<a id=\"more\"></a>\n<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timer;</span><br><span class=\"line\">function debounce (fn, delay, ...args) &#123;</span><br><span class=\"line\">  clearTimeout(timer)</span><br><span class=\"line\">  timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(args)</span><br><span class=\"line\">    fn(args)</span><br><span class=\"line\">  &#125;, delay)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function () &#123;</span><br><span class=\"line\">  debounce(testDebounce, 5000, 1111, 2222)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testDebounce (...args) &#123;</span><br><span class=\"line\">  console.log(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle (fn, delay) &#123;</span><br><span class=\"line\">  var previous = 0</span><br><span class=\"line\">  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    var _this = this</span><br><span class=\"line\">    var args = arguments</span><br><span class=\"line\">    var now = new Date()</span><br><span class=\"line\">    if (now - previous &gt; delay) &#123;</span><br><span class=\"line\">      fn.apply(_this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var testThrottleFn = throttle(testThrottle, 5000) // 节流函数</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">  testThrottleFn(e, &apos;throttle&apos;) // 给节流函数传参</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testThrottle (e, content) &#123;</span><br><span class=\"line\">  console.log(e, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.mt5 {\n  margin-top: 5px;\n}\n.mt10 {\n  margin-top: 10px;\n}\n.pt10 {\n  padding-top: 10px;\n}\n.red {\n  color: red;\n}\n</style>\n\n<div>函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></div>\n<div>函数节流：每隔一段时间，只执行一次函数。</div>","more":"<ol class=\"pt10\">\n    <li>函数防抖：\n      <div class=\"mt5\">\n        <p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。<span class=\"red\">最后一次为准。</span></p>\n      </div>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var timer;</span><br><span class=\"line\">function debounce (fn, delay, ...args) &#123;</span><br><span class=\"line\">  clearTimeout(timer)</span><br><span class=\"line\">  timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    console.log(args)</span><br><span class=\"line\">    fn(args)</span><br><span class=\"line\">  &#125;, delay)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function () &#123;</span><br><span class=\"line\">  debounce(testDebounce, 5000, 1111, 2222)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testDebounce (...args) &#123;</span><br><span class=\"line\">  console.log(args)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    </li>\n    <li>函数节流：\n      <div class=\"mt10\">\n        <p>每隔一段时间，只执行一次函数。</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle (fn, delay) &#123;</span><br><span class=\"line\">  var previous = 0</span><br><span class=\"line\">  // 使用闭包返回一个函数并且用到闭包函数外面的变量previous</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    var _this = this</span><br><span class=\"line\">    var args = arguments</span><br><span class=\"line\">    var now = new Date()</span><br><span class=\"line\">    if (now - previous &gt; delay) &#123;</span><br><span class=\"line\">      fn.apply(_this, args)</span><br><span class=\"line\"></span><br><span class=\"line\">      previous = now</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var testThrottleFn = throttle(testThrottle, 5000) // 节流函数</span><br><span class=\"line\"></span><br><span class=\"line\">document.onclick = function (e) &#123;</span><br><span class=\"line\">  testThrottleFn(e, &apos;throttle&apos;) // 给节流函数传参</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function testThrottle (e, content) &#123;</span><br><span class=\"line\">  console.log(e, content)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n      </div>\n    </li>\n</ol>\n\n<div>\n  <ol>\n    <li class=\"pt10\">\n      函数防抖的应用场景\n      <div class=\"mt10\">\n        <p>连续的事件，只需触发一次回调的场景有：</p>\n        <ul>\n          <li>搜索框搜索输入。只需用户最后一次输入完，再发送请求;</li>\n          <li>手机号、邮箱验证输入检测;</li>\n          <li>窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染;</li>\n        </ul>\n      </div>\n    </li>\n    <li class=\"pt10\">\n      函数节流的应用场景\n      <div class=\"mt10\">\n        <p>间隔一段时间执行一次回调的场景有：</p>\n        <ul>\n          <li>滚动加载，加载更多或滚到底部监听;</li>\n          <li>谷歌搜索框，搜索联想功能;</li>\n          <li>高频点击提交，表单重复提交;</li>\n        </ul>\n      </div>\n    </li>\n  </ol>\n</div>"},{"title":"IE及移动端兼容性&其他问题汇总","date":"2019-03-06T15:30:28.000Z","toc":true,"_content":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<!-- more -->\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用\"canvas\"，ie8及低版本用\"shape形状\"</li>\n  <li>a标签兼容性问题：\n    ```\n    <a href=\"javascript:void(0);\" target=\"_blank\"></a>\n    ```\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：https://www.cnblogs.com/august-8/p/4537685.html</div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    ```\n    position: static;\n    ```\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ''+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    ```\n    str = str.replace(/\\s+/g,\"\");\n    ```\n    </p>\n    <p>去除两头空格:\n    ```\n    str = str.replace(/^\\s+|\\s+$/g,\"\");\n    ```\n    </p>\n    <p>去除左空格：\n    ```\n    str = str.replace( /^\\s/, '');\n    ```\n    </p>\n    <p>去除右空格：\n    ```\n    str = str.replace(/(\\s$)/g, \"\");\n    ```\n    </p>\n  </li>\n  <li>页面种cookie：\n    ```\n     document.cookie = 'userId=123;test=456'\n    ```\n  </li>\n  <li>for循环性能比对：\n    <p>for>forEach>for...in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      ```\n      $(\"#input1\").bind(\"input propertychange\",function(event){\n        console.log($(\"#input1\").val())\n      });\n      ```\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for...in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=\"_blank\"打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li>http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","source":"_posts/css/IE及移动端兼容性问题&其他汇总.md","raw":"---\ntitle: IE及移动端兼容性&其他问题汇总\ndate: 2019-03-06 23:30:28\ntoc: true\ncategories: css\ntags:\n---\n<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<!-- more -->\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用\"canvas\"，ie8及低版本用\"shape形状\"</li>\n  <li>a标签兼容性问题：\n    ```\n    <a href=\"javascript:void(0);\" target=\"_blank\"></a>\n    ```\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：https://www.cnblogs.com/august-8/p/4537685.html</div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    ```\n    position: static;\n    ```\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ''+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    ```\n    str = str.replace(/\\s+/g,\"\");\n    ```\n    </p>\n    <p>去除两头空格:\n    ```\n    str = str.replace(/^\\s+|\\s+$/g,\"\");\n    ```\n    </p>\n    <p>去除左空格：\n    ```\n    str = str.replace( /^\\s/, '');\n    ```\n    </p>\n    <p>去除右空格：\n    ```\n    str = str.replace(/(\\s$)/g, \"\");\n    ```\n    </p>\n  </li>\n  <li>页面种cookie：\n    ```\n     document.cookie = 'userId=123;test=456'\n    ```\n  </li>\n  <li>for循环性能比对：\n    <p>for>forEach>for...in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      ```\n      $(\"#input1\").bind(\"input propertychange\",function(event){\n        console.log($(\"#input1\").val())\n      });\n      ```\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for...in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=\"_blank\"打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li>http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","slug":"css/IE及移动端兼容性问题&其他汇总","published":1,"updated":"2021-01-13T14:29:58.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa2000suhxxoo67lwys","content":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>\n<a id=\"more\"></a>\n<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用”canvas”，ie8及低版本用”shape形状”</li>\n  <li>a标签兼容性问题：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:void(0);&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：<a href=\"https://www.cnblogs.com/august-8/p/4537685.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/august-8/p/4537685.html</a></div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: static;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ‘’+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/\\s+/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除两头空格:\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/^\\s+|\\s+$/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除左空格：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace( /^\\s/, &apos;&apos;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除右空格：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/(\\s$)/g, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n  </li>\n  <li>页面种cookie：\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie = &apos;userId=123;test=456&apos;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>for循环性能比对：\n    <p>for&gt;forEach&gt;for…in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event)&#123;</span><br><span class=\"line\">  console.log($(&quot;#input1&quot;).val())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for…in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=”_blank”打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","site":{"data":{}},"excerpt":"<p>此篇用于总结遇到的兼容性问题，便于积累和提升</p>","more":"<h2>css</h2>\n<ol>\n  <li>透明度opacity:filter:alpha(opacity=50);可支持ie8</li>\n  <li>尾类::before和::after在ie8下失效</li>\n  <li>图表绘制：highcharts在绘制图表时，高版本用”canvas”，ie8及低版本用”shape形状”</li>\n  <li>a标签兼容性问题：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:void(0);&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n\n    firfox会新开空白页面，避免使用这种写法\n  </li>\n  <li>overflow:hidden会清除浮动</li>\n  <li>@media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。\n    <div>详细了解：<a href=\"https://www.cnblogs.com/august-8/p/4537685.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/august-8/p/4537685.html</a></div>\n  </li>\n  <li>由于历史原因及某些特殊原因，需通过CSS清除定位position:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">position: static;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>javascript</h2>\n<ol>\n  <li>字符串比较大小会产生失真;</li>\n  <li>js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。</li>\n  <li>number变字符串: ‘’+123 左侧加空字符串</li>\n  <li>向上取整：Math.ceil() 向下取整：Math.floor()</li>\n  <li>JS去掉字符串中的空格：\n    <p>去除所有空格: \n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/\\s+/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除两头空格:\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/^\\s+|\\s+$/g,&quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除左空格：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace( /^\\s/, &apos;&apos;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n    <p>去除右空格：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">str = str.replace(/(\\s$)/g, &quot;&quot;);</span><br></pre></td></tr></table></figure>\n\n    </p>\n  </li>\n  <li>页面种cookie：\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.cookie = &apos;userId=123;test=456&apos;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>for循环性能比对：\n    <p>for&gt;forEach&gt;for…in</p>\n    <p>性能优化：</p>\n    <ol>\n        <li>break/continue语句，适时运用</li>\n        <li>缓存变量（如数组长度）</li>\n    </ol>\n  </li>\n</ol>\n<h2>jquery</h2>\n<ol>\n  <li>实时监听input输入框值变化:\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event)&#123;</span><br><span class=\"line\">  console.log($(&quot;#input1&quot;).val())</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n<h2>hybrid內嵌h5</h2>\n<ol>\n  <li>Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解）</li>\n  <li>多页面跳转时，注意路径问题。（返回路径到指定页面）</li>\n  <li>多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。</li>\n  <li>for…in慎用：在ios低版本下会循环两次。</li>\n  <li>textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。</li>\n  <li>a标签中慎用target=”_blank”打开新窗口，会导致链接看起来跳转了两次。</li>\n</ol>\n<h2>微信公众号</h2>\n<ol>\n  <li>页面开发需经appid身份认证之后，在微信开发者工具中进行开发。</li>\n</ol>\n<h2>Commit message 和 Change log 编写指南</h2>\n<ol>\n  <li><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"Git使用过程中遇到的问题","date":"2019-09-03T19:08:44.000Z","_content":"<p>此篇用于记录Git使用过程中遇到的问题。</p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n<!-- more -->\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      ```\n      ssh-add -K ~/.ssh/keyname\n      ```\n      <span class=\"fb\">参考：</span>https://segmentfault.com/q/1010000000835302\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset --hard</p>\n      ```\n      git reflog \n      git reset --hard HEAD@{index} // 如 index=rebase前的索引\n      ```\n      <span class=\"fb\">参考：</span>https://www.cnblogs.com/suanec/p/7511137.html\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    ```\n    git add -u\n    git reset -- XXX.txt\n    ```\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    ```\n    git branch       // 本地分支\n    git branch -r    // 远程分支\n    ```\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    ```\n    // 本地分支\n    git branch -D BranchName\n\n    // 远程分支\n    git branch -r -D origin/BranchName\n    git push origin -d BranchName    \n    ```\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    ```\n    git log A ^B\n    ```\n    </div>\n    <div>查看B有A没有\n    ```\n    git log B ^A\n    ```\n    </div>\n    <div>查看A比Bd多了哪些？\n    ```\n    git log A..B\n    ```\n    </div>\n    <div>查看B比A多了哪些？\n    ```\n    git log B..A\n    ```\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    ```\n    git diff topic master\n    git diff topic..master\n    ```\n    </div>\n    <span class=\"fb\">参考：</span>https://blog.csdn.net/u011240877/article/details/52586664\n  </li>\n</ol>\n","source":"_posts/工具/Git使用过程中遇到的问题.md","raw":"---\ntitle: Git使用过程中遇到的问题\ndate: 2019-09-04 03:08:44\ntags:\ncategories: 工具\n---\n<p>此篇用于记录Git使用过程中遇到的问题。</p>\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n<!-- more -->\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      ```\n      ssh-add -K ~/.ssh/keyname\n      ```\n      <span class=\"fb\">参考：</span>https://segmentfault.com/q/1010000000835302\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset --hard</p>\n      ```\n      git reflog \n      git reset --hard HEAD@{index} // 如 index=rebase前的索引\n      ```\n      <span class=\"fb\">参考：</span>https://www.cnblogs.com/suanec/p/7511137.html\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    ```\n    git add -u\n    git reset -- XXX.txt\n    ```\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    ```\n    git branch       // 本地分支\n    git branch -r    // 远程分支\n    ```\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    ```\n    // 本地分支\n    git branch -D BranchName\n\n    // 远程分支\n    git branch -r -D origin/BranchName\n    git push origin -d BranchName    \n    ```\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    ```\n    git log A ^B\n    ```\n    </div>\n    <div>查看B有A没有\n    ```\n    git log B ^A\n    ```\n    </div>\n    <div>查看A比Bd多了哪些？\n    ```\n    git log A..B\n    ```\n    </div>\n    <div>查看B比A多了哪些？\n    ```\n    git log B..A\n    ```\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    ```\n    git diff topic master\n    git diff topic..master\n    ```\n    </div>\n    <span class=\"fb\">参考：</span>https://blog.csdn.net/u011240877/article/details/52586664\n  </li>\n</ol>\n","slug":"工具/Git使用过程中遇到的问题","published":1,"updated":"2020-12-21T13:24:01.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa3000uuhxxlhtetb2e","content":"<p></p><p>此篇用于记录Git使用过程中遇到的问题。</p><p></p>\n<p><style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style>\n<a id=\"more\"></a></p>\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -K ~/.ssh/keyname</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://segmentfault.com/q/1010000000835302\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000000835302</a>\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset –hard</p>\n      <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog </span><br><span class=\"line\">git reset --hard HEAD@&#123;index&#125; // 如 index=rebase前的索引</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://www.cnblogs.com/suanec/p/7511137.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/suanec/p/7511137.html</a>\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -u</span><br><span class=\"line\">git reset -- XXX.txt</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch       // 本地分支</span><br><span class=\"line\">git branch -r    // 远程分支</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地分支</span><br><span class=\"line\">git branch -D BranchName</span><br><span class=\"line\"></span><br><span class=\"line\">// 远程分支</span><br><span class=\"line\">git branch -r -D origin/BranchName</span><br><span class=\"line\">git push origin -d BranchName</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A ^B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B有A没有\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B ^A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看A比Bd多了哪些？\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A..B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B比A多了哪些？\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B..A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff topic master</span><br><span class=\"line\">git diff topic..master</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <span class=\"fb\">参考：</span><a href=\"https://blog.csdn.net/u011240877/article/details/52586664\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011240877/article/details/52586664</a>\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p></p><p>此篇用于记录Git使用过程中遇到的问题。</p><p></p>\n<p><style type=\"text/css\">\n.pt{padding-top:10px;}\n.pt5{padding-top:5px;}\n.fb{font-weight:bolder;}\n</style></p>","more":"</p>\n<ol>\n  <li class=\"pt\">多个公私密钥情况下，如何添加ssh-add？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>通过如下方式，将key加入keychain中解决</p>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-add -K ~/.ssh/keyname</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://segmentfault.com/q/1010000000835302\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/q/1010000000835302</a>\n    </div>\n  </li>\n  <li class=\"pt\">如何撤销rebase？\n    <div class=\"pt\">\n      <span class=\"fb\">起因：</span>\n      在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。\n      <p class=\"pt5\"><span class=\"fb\">解决方式：</span>git reflog + git reset –hard</p>\n      <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reflog </span><br><span class=\"line\">git reset --hard HEAD@&#123;index&#125; // 如 index=rebase前的索引</span><br></pre></td></tr></table></figure>\n\n      <span class=\"fb\">参考：</span><a href=\"https://www.cnblogs.com/suanec/p/7511137.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/suanec/p/7511137.html</a>\n    </div>\n  </li>\n  <li class=\"pt\">Add all files to a commit except a single file?\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add -u</span><br><span class=\"line\">git reset -- XXX.txt</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">撤销push到远程的某个文件的commit同时清除历史？\n\n  </li>\n  <li class=\"pt\">查看本地分支和远程分支\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch       // 本地分支</span><br><span class=\"line\">git branch -r    // 远程分支</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li class=\"pt\">删除本地分支和远程分支\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 本地分支</span><br><span class=\"line\">git branch -D BranchName</span><br><span class=\"line\"></span><br><span class=\"line\">// 远程分支</span><br><span class=\"line\">git branch -r -D origin/BranchName</span><br><span class=\"line\">git push origin -d BranchName</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>查看两个branch差异？\n    <div>查看A有B没有\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A ^B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B有A没有\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B ^A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看A比Bd多了哪些？\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log A..B</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <div>查看B比A多了哪些？\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git log B..A</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <p>在上线发布前对比master分支时，需要确认一下分支情况。</p>\n    <div>直接将两个分支上最新的提交做diff\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git diff topic master</span><br><span class=\"line\">git diff topic..master</span><br></pre></td></tr></table></figure>\n\n    </div>\n    <span class=\"fb\">参考：</span><a href=\"https://blog.csdn.net/u011240877/article/details/52586664\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/u011240877/article/details/52586664</a>\n  </li>\n</ol>"},{"title":"Mac安装和卸载HomeBrew","date":"2019-07-21T10:09:50.000Z","_content":"\n<a href=\"https://brew.sh/\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。\n\n<!-- more -->\n\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \n```\n\n<h4>卸载</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n![报错信息](/img/HomeBrew/1.png)\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n然后重新安装即可。\n","source":"_posts/工具/Mac安装和卸载HomeBrew.md","raw":"---\ntitle: Mac安装和卸载HomeBrew\ndate: 2019-07-21 18:09:50\ntags: 工具\ncategories: 工具\n---\n\n<a href=\"https://brew.sh/\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。\n\n<!-- more -->\n\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" \n```\n\n<h4>卸载</h4>\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n![报错信息](/img/HomeBrew/1.png)\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n然后重新安装即可。\n","slug":"工具/Mac安装和卸载HomeBrew","published":1,"updated":"2020-12-21T13:04:43.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa4000wuhxxmih530ph","content":"<p><a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p>\n<a id=\"more\"></a>\n<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4>卸载</h4>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n<img src=\"/img/HomeBrew/1.png\" alt=\"报错信息\">\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n<p>然后重新安装即可。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew(to:official website)</a>:是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。</p>","more":"<p>最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。</p>\n\n<h4>安装</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4>卸载</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4>\n<h4>二次安装中遇到的问题</h4>\n\n<p style=\"text-indent:30px\">当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时:</p>\n<img src=\"/img/HomeBrew/1.png\" alt=\"报错信息\">\n<p>如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。</p>\n\n<p>如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz</p>\n\n<p>然后重新安装即可。</p>"},{"title":"unit-tests","date":"2019-10-27T13:41:39.000Z","_content":"\nI don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS\n\n<!-- more -->\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://sinonjs.org/</li>\n  <li>https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</li>\n</ol>","source":"_posts/工具/unit-tests.md","raw":"---\ntitle: unit-tests\ndate: 2019-10-27 21:41:39\ntags: 工具\ncategories: 工具\n---\n\nI don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS\n\n<!-- more -->\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://sinonjs.org/</li>\n  <li>https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</li>\n</ol>","slug":"工具/unit-tests","published":1,"updated":"2020-12-21T13:24:25.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa5000yuhxxj7mh934n","content":"<p>I don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS</p>\n<a id=\"more\"></a>\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"noopener\">https://sinonjs.org/</a></li>\n  <li><a href=\"https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html\" target=\"_blank\" rel=\"noopener\">https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>I don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS</p>","more":"<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://sinonjs.org/\" target=\"_blank\" rel=\"noopener\">https://sinonjs.org/</a></li>\n  <li><a href=\"https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html\" target=\"_blank\" rel=\"noopener\">https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html</a></li>\n</ol>"},{"title":"工程化概述","date":"2020-12-21T12:06:13.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6844903588553048077</li>\n</ol>\n","source":"_posts/工程化/工程化概述.md","raw":"---\ntitle: 工程化概述\ndate: 2020-12-21 20:06:13\ntags:\ncategories: 工程化\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://juejin.cn/post/6844903588553048077</li>\n</ol>\n","slug":"工程化/工程化概述","published":1,"updated":"2021-01-01T05:31:01.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa60011uhxxzspbs7vf","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6844903588553048077\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903588553048077</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://juejin.cn/post/6844903588553048077\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903588553048077</a></li>\n</ol>\n"},{"title":"VSCode常用快捷键","date":"2019-10-17T03:48:38.000Z","_content":"\n<p></p>\n\n<!-- more -->\n\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","source":"_posts/工具/VSCode常用快捷键.md","raw":"---\ntitle: VSCode常用快捷键\ndate: 2019-10-17 11:48:38\ntags: 工具\ncategories: 工具\n---\n\n<p></p>\n\n<!-- more -->\n\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","slug":"工具/VSCode常用快捷键","published":1,"updated":"2021-01-01T11:27:41.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa70014uhxxvxicq9se","content":"<p></p>\n\n<a id=\"more\"></a>\n<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p></p>","more":"<table>\n  <thead>\n    <tr>\n      <th>快捷键</th>\n      <th>操作</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>shift + alt +up/down</td>\n      <td>复制当前行</td>\n    </tr>\n    <tr>\n      <td>alt + up/down</td>\n      <td>移动行</td>\n    </tr>\n    <tr>\n      <td>command + b</td>\n      <td>显示/隐藏左侧目录栏</td>\n    </tr>\n    <tr>\n      <td>shift + command + k</td>\n      <td>删除当前行</td>\n    </tr>\n    <tr>\n      <td>command + ~</td>\n      <td>控制台终端显示与隐藏</td>\n    </tr>\n    <tr>\n      <td>alt + shift + A</td>\n      <td>多行注释</td>\n    </tr>\n    <tr>\n      <td>command + [</td>\n      <td>行增加缩进</td>\n    </tr>\n    <tr>\n      <td>command + ]</td>\n      <td>行减少缩进</td>\n    </tr>\n    <tr>\n      <td>command + ( + 或 - )</td>\n      <td>字体放大/缩小</td>\n    </tr>\n    <tr>\n      <td>command + shift + left/right</td>\n      <td>切换窗口</td>\n    </tr>\n    <tr>\n      <td>command + w</td>\n      <td>关闭编辑器窗口</td>\n    </tr>\n    <tr>\n      <td>command + k + w</td>\n      <td>关闭所有窗口</td>\n    </tr>\n  </tbody>\n</table>"},{"title":"使用Hexo+Github搭建属于自己的blog","date":"2019-02-18T14:24:22.000Z","toc":true,"_content":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<!-- more -->\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p>主要参考文章有：</p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\"  target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p>优化</p>\n<ul>\n    <li>热更新：https://github.com/hexojs/hexo-browsersync</li>\n</ul>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<h4>常用命令</h4>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new \"postName\" #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<h4>配置文件</h4>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<h4>Questions</h4>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题<p>\n        <p>只需要在_config.yml里增加如下配置即可</p>\n        ```\n        marked:\n            breaks: false\n        ```\n        <p>参考：http://1900.live/rep-hexo-marked/<p>\n    </li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：https://www.jianshu.com/p/366ff564a8f2</p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：https://segmentfault.com/a/1190000016267344</p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","source":"_posts/总结/使用Hexo-Github搭建属于自己的blog.md","raw":"---\ntitle: 使用Hexo+Github搭建属于自己的blog\ndate: 2019-02-18 22:24:22\ntoc: true\ncategories: 总结\ntags:\n---\n<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<!-- more -->\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p>主要参考文章有：</p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\"  target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p>优化</p>\n<ul>\n    <li>热更新：https://github.com/hexojs/hexo-browsersync</li>\n</ul>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<h4>常用命令</h4>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new \"postName\" #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<h4>配置文件</h4>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<h4>Questions</h4>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题<p>\n        <p>只需要在_config.yml里增加如下配置即可</p>\n        ```\n        marked:\n            breaks: false\n        ```\n        <p>参考：http://1900.live/rep-hexo-marked/<p>\n    </li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：https://www.jianshu.com/p/366ff564a8f2</p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：https://segmentfault.com/a/1190000016267344</p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","slug":"总结/使用Hexo-Github搭建属于自己的blog","published":1,"updated":"2020-12-21T13:23:45.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa70016uhxxj5bm4yxk","content":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>\n<a id=\"more\"></a>\n<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p></p><p>主要参考文章有：</p><p></p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\" target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p></p><p>优化</p><p></p>\n<ul>\n    <li>热更新：<a href=\"https://github.com/hexojs/hexo-browsersync\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo-browsersync</a></li>\n</ul>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><h4>常用命令</h4><p></p>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new “postName” #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<p></p><h4>配置文件</h4><p></p>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<p></p><h4>Questions</h4><p></p>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题</p><p>\n        </p><p>只需要在_config.yml里增加如下配置即可</p>\n        <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">    breaks: false</span><br></pre></td></tr></table></figure>\n\n        <p>参考：<a href=\"http://1900.live/rep-hexo-marked/\" target=\"_blank\" rel=\"noopener\">http://1900.live/rep-hexo-marked/</a></p><p>\n    </p></li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：<a href=\"https://www.jianshu.com/p/366ff564a8f2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/366ff564a8f2</a></p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：<a href=\"https://segmentfault.com/a/1190000016267344\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016267344</a></p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>\n","site":{"data":{}},"excerpt":"<p>一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现)</p>","more":"<p>网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。</p>\n\n<p></p><p>主要参考文章有：</p><p></p>\n<ul>\n    <li><a href=\"https://hexo.io/\" target=\"_blank\">hexo官网</a></li>\n    <li><a href=\"https://www.cnblogs.com/fengxiongZz/p/7707219.html\" target=\"_blank\">使用Hexo+Github一步步搭建属于自己的博客（基础）</a></li>\n</ul>\n\n<p></p><p>优化</p><p></p>\n<ul>\n    <li>热更新：<a href=\"https://github.com/hexojs/hexo-browsersync\" target=\"_blank\" rel=\"noopener\">https://github.com/hexojs/hexo-browsersync</a></li>\n</ul>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><h4>常用命令</h4><p></p>\n<ol>\n    <li>hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。</li>\n    <li>hexo clean #清除缓存 网页正常情况下可以忽略此条命令</li>\n    <li>hexo new “postName” #新建文章</li>\n    <li>hexo d -g #生成部署git</li>\n</ol>\n\n<p></p><h4>配置文件</h4><p></p>\n<ol>\n    <li>config.xml里的per_page，这个设置成0就全都没有分页了。</li>\n</ol>\n\n<p></p><h4>Questions</h4><p></p>\n<ol>\n    <li>\n        <p>解决hexo渲染的html页面中有br的问题</p><p>\n        </p><p>只需要在_config.yml里增加如下配置即可</p>\n        <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">marked:</span><br><span class=\"line\">    breaks: false</span><br></pre></td></tr></table></figure>\n\n        <p>参考：<a href=\"http://1900.live/rep-hexo-marked/\" target=\"_blank\" rel=\"noopener\">http://1900.live/rep-hexo-marked/</a></p><p>\n    </p></li>\n    <li>\n        <p>md文件插入代码片段</p>\n        <p>参考：<a href=\"https://www.jianshu.com/p/366ff564a8f2\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/366ff564a8f2</a></p>\n    </li>\n    <li>\n        <p>后期完善(评论、站点统计)参考：<a href=\"https://segmentfault.com/a/1190000016267344\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016267344</a></p>\n    </li>\n    <li>\n      <p>node版本：12.14.1</p>\n    </li>\n</ol>\n\n<div style=\"margin-bottom:50px\"></div>"},{"title":"前端性能优化","date":"2019-05-10T04:09:04.000Z","thumbnail":"img/plant.jpg","_content":"\n本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》\n\n<!-- more -->\n\n<h4>JavaScript篇</h4>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<h4>css篇</h4>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<h4>网络篇</h4>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    ```\n    Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；\n    Cache-Control: private immutable \n    //不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；\n    Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；\n    Cache-Control: public max-age=3600 s-maxage=7200 \n    //本地缓存 1 小时，CDN 上缓存 2 小时；\n    Cache-Control: public max-age=3600 proxy-revalidate  \n    //本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源\n    ```\n    </li>\n</ol>\n\n<h4>其他</h4>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：https://www.cnblogs.com/yingsong/p/6170780.html</p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：https://www.cnblogs.com/softidea/p/5308489.html</p>\n    </li>\n</ol>\n","source":"_posts/异常&性能/前端性能优化.md","raw":"---\ntitle: 前端性能优化\ndate: 2019-05-10 12:09:04\ntags: 异常&性能\ncategories: 异常&性能\nthumbnail: img/plant.jpg\n---\n\n本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》\n\n<!-- more -->\n\n<h4>JavaScript篇</h4>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<h4>css篇</h4>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<h4>网络篇</h4>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    ```\n    Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；\n    Cache-Control: private immutable \n    //不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；\n    Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；\n    Cache-Control: public max-age=3600 s-maxage=7200 \n    //本地缓存 1 小时，CDN 上缓存 2 小时；\n    Cache-Control: public max-age=3600 proxy-revalidate  \n    //本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源\n    ```\n    </li>\n</ol>\n\n<h4>其他</h4>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：https://www.cnblogs.com/yingsong/p/6170780.html</p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：https://www.cnblogs.com/softidea/p/5308489.html</p>\n    </li>\n</ol>\n","slug":"异常&性能/前端性能优化","published":1,"updated":"2021-01-14T02:46:47.768Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa80019uhxxljhboeoq","content":"<p>本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》</p>\n<a id=\"more\"></a>\n<p></p><h4>JavaScript篇</h4><p></p>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<p></p><h4>css篇</h4><p></p>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<p></p><h4>网络篇</h4><p></p>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；</span><br><span class=\"line\">Cache-Control: private immutable </span><br><span class=\"line\">//不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；</span><br><span class=\"line\">Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；</span><br><span class=\"line\">Cache-Control: public max-age=3600 s-maxage=7200 </span><br><span class=\"line\">//本地缓存 1 小时，CDN 上缓存 2 小时；</span><br><span class=\"line\">Cache-Control: public max-age=3600 proxy-revalidate  </span><br><span class=\"line\">//本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源</span><br></pre></td></tr></table></figure>\n\n    </li>\n</ol>\n\n<p></p><h4>其他</h4><p></p>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：<a href=\"https://www.cnblogs.com/yingsong/p/6170780.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yingsong/p/6170780.html</a></p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：<a href=\"https://www.cnblogs.com/softidea/p/5308489.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/softidea/p/5308489.html</a></p>\n    </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》</p>","more":"<p></p><h4>JavaScript篇</h4><p></p>\n<ol>\n    <li>body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。</li>\n    <li>合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。</li>\n    <li>有多种无阻塞下载JavaScript的方法：\n        <ul>\n            <li>使用script标签的defer属性；</li>\n            <li>使用动态创建的script元素来下载并执行代码；</li>\n            <li>使用XHR对象下载JavaScript代码并注入页面中。</li>\n        </ul>\n    </li>\n</ol>\n\n<p></p><h4>css篇</h4><p></p>\n<ol>\n    <li>用精灵图处理图标。</li>\n    <li>减少重排与重绘</li>\n</ol>\n\n<p></p><h4>网络篇</h4><p></p>\n<ol>\n    <li>CDN缓存</li>\n    <li>HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control \n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；</span><br><span class=\"line\">Cache-Control: private immutable </span><br><span class=\"line\">//不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；</span><br><span class=\"line\">Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；</span><br><span class=\"line\">Cache-Control: public max-age=3600 s-maxage=7200 </span><br><span class=\"line\">//本地缓存 1 小时，CDN 上缓存 2 小时；</span><br><span class=\"line\">Cache-Control: public max-age=3600 proxy-revalidate  </span><br><span class=\"line\">//本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源</span><br></pre></td></tr></table></figure>\n\n    </li>\n</ol>\n\n<p></p><h4>其他</h4><p></p>\n<ol>\n    <li>关于html，css，js三者的加载顺序问题：\n        <p>参考：<a href=\"https://www.cnblogs.com/yingsong/p/6170780.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yingsong/p/6170780.html</a></p>\n    </li>\n    <li>浏览器缓存机制：\n        <p>参考：<a href=\"https://www.cnblogs.com/softidea/p/5308489.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/softidea/p/5308489.html</a></p>\n    </li>\n</ol>"},{"title":"UNIX编程艺术","date":"2021-01-06T06:54:57.000Z","_content":"\n<p>孔子云：\"取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣\"。</p>\n","source":"_posts/架构/UNIX编程艺术.md","raw":"---\ntitle: UNIX编程艺术\ndate: 2021-01-06 14:54:57\ncategories: 架构\ntags: 架构\n---\n\n<p>孔子云：\"取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣\"。</p>\n","slug":"架构/UNIX编程艺术","published":1,"updated":"2021-01-09T14:28:41.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaa9001buhxxyy44wgtt","content":"<p>孔子云：”取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>孔子云：”取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。</p>\n"},{"title":"Vue问题总结","date":"2019-10-28T15:09:34.000Z","_content":"\n<p>常见问题总结</p>\n\n<!-- more -->\n\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    ```\n    props: {\n      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n      propA: Number,\n      // 多个可能的类型\n      propB: [String, Number],\n      // 必填的字符串\n      propC: {\n        type: String,\n        required: true\n      },\n      // 带有默认值的数字\n      propD: {\n        type: Number,\n        default: 100\n      },\n      // 带有默认值的对象\n      propE: {\n        type: Object,\n        // 对象或数组默认值必须从一个工厂函数获取\n        default: function () {\n          return { message: 'hello' }\n        }\n      },\n      // 自定义验证函数\n      propF: {\n        validator: function (value) {\n          // 这个值必须匹配下列字符串中的一个\n          return ['success', 'warning', 'danger'].indexOf(value) !== -1\n        }\n      }\n    }\n    ```\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    ![vue生命周期执行过程](/img/execute.png)\n  </li>\n</ol>\n","source":"_posts/框架/Vue问题总结.md","raw":"---\ntitle: Vue问题总结\ndate: 2019-10-28 23:09:34\ntags: 框架\ncategories: 框架\n---\n\n<p>常见问题总结</p>\n\n<!-- more -->\n\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    ```\n    props: {\n      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n      propA: Number,\n      // 多个可能的类型\n      propB: [String, Number],\n      // 必填的字符串\n      propC: {\n        type: String,\n        required: true\n      },\n      // 带有默认值的数字\n      propD: {\n        type: Number,\n        default: 100\n      },\n      // 带有默认值的对象\n      propE: {\n        type: Object,\n        // 对象或数组默认值必须从一个工厂函数获取\n        default: function () {\n          return { message: 'hello' }\n        }\n      },\n      // 自定义验证函数\n      propF: {\n        validator: function (value) {\n          // 这个值必须匹配下列字符串中的一个\n          return ['success', 'warning', 'danger'].indexOf(value) !== -1\n        }\n      }\n    }\n    ```\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    ![vue生命周期执行过程](/img/execute.png)\n  </li>\n</ol>\n","slug":"框架/Vue问题总结","published":1,"updated":"2021-01-15T20:14:26.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaaa001euhxx70aog95l","content":"<p>常见问题总结</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class=\"line\">  propA: Number,</span><br><span class=\"line\">  // 多个可能的类型</span><br><span class=\"line\">  propB: [String, Number],</span><br><span class=\"line\">  // 必填的字符串</span><br><span class=\"line\">  propC: &#123;</span><br><span class=\"line\">    type: String,</span><br><span class=\"line\">    required: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的数字</span><br><span class=\"line\">  propD: &#123;</span><br><span class=\"line\">    type: Number,</span><br><span class=\"line\">    default: 100</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的对象</span><br><span class=\"line\">  propE: &#123;</span><br><span class=\"line\">    type: Object,</span><br><span class=\"line\">    // 对象或数组默认值必须从一个工厂函数获取</span><br><span class=\"line\">    default: function () &#123;</span><br><span class=\"line\">      return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 自定义验证函数</span><br><span class=\"line\">  propF: &#123;</span><br><span class=\"line\">    validator: function (value) &#123;</span><br><span class=\"line\">      // 这个值必须匹配下列字符串中的一个</span><br><span class=\"line\">      return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    <img src=\"/img/execute.png\" alt=\"vue生命周期执行过程\">\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>常见问题总结</p>","more":"<ol>\n  <li>父组件给子组件传props，当props值不需设置时，可传null或者undefined\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">props: &#123;</span><br><span class=\"line\">  // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br><span class=\"line\">  propA: Number,</span><br><span class=\"line\">  // 多个可能的类型</span><br><span class=\"line\">  propB: [String, Number],</span><br><span class=\"line\">  // 必填的字符串</span><br><span class=\"line\">  propC: &#123;</span><br><span class=\"line\">    type: String,</span><br><span class=\"line\">    required: true</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的数字</span><br><span class=\"line\">  propD: &#123;</span><br><span class=\"line\">    type: Number,</span><br><span class=\"line\">    default: 100</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 带有默认值的对象</span><br><span class=\"line\">  propE: &#123;</span><br><span class=\"line\">    type: Object,</span><br><span class=\"line\">    // 对象或数组默认值必须从一个工厂函数获取</span><br><span class=\"line\">    default: function () &#123;</span><br><span class=\"line\">      return &#123; message: &apos;hello&apos; &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  // 自定义验证函数</span><br><span class=\"line\">  propF: &#123;</span><br><span class=\"line\">    validator: function (value) &#123;</span><br><span class=\"line\">      // 这个值必须匹配下列字符串中的一个</span><br><span class=\"line\">      return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。</li>\n  <li>\n    主函数/mixin/组件 生命周期执行过程\n    <img src=\"/img/execute.png\" alt=\"vue生命周期执行过程\">\n  </li>\n</ol>"},{"title":"Chrome架构","date":"2020-04-02T06:01:04.000Z","_content":"\n<ul>\n  <li>进程线程：https://cloud.tencent.com/developer/news/414508</li>\n</ul>\n","source":"_posts/架构/Chrome架构.md","raw":"---\ntitle: Chrome架构\ndate: 2020-04-02 14:01:04\ncategories: 架构\ntags: 架构\n---\n\n<ul>\n  <li>进程线程：https://cloud.tencent.com/developer/news/414508</li>\n</ul>\n","slug":"架构/Chrome架构","published":1,"updated":"2021-01-01T05:31:31.493Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaab001huhxx5xh53zy2","content":"<ul>\n  <li>进程线程：<a href=\"https://cloud.tencent.com/developer/news/414508\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/414508</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n  <li>进程线程：<a href=\"https://cloud.tencent.com/developer/news/414508\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/414508</a></li>\n</ul>\n"},{"title":"从零搭建vue/react项目","date":"2021-01-13T09:24:01.000Z","_content":"\n不借助vue-cil脚手架，基于webpack+vue搭建开发环境\n\ngithub:\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<!--more-->\n\n<h4 style=\"margin-top:50px;\">具体步骤:</h4>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n","source":"_posts/框架/从零搭建vue项目.md","raw":"---\ntitle: 从零搭建vue/react项目\ndate: 2021-01-13 17:24:01\ntags: 框架\ncategories: 框架\n---\n\n不借助vue-cil脚手架，基于webpack+vue搭建开发环境\n\ngithub:\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<!--more-->\n\n<h4 style=\"margin-top:50px;\">具体步骤:</h4>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n","slug":"框架/从零搭建vue项目","published":1,"updated":"2021-01-16T09:28:42.536Z","_id":"ckjytoaab001kuhxxg35y610k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>不借助vue-cil脚手架，基于webpack+vue搭建开发环境</p>\n<p>github:</p>\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>\n\n<a id=\"more\"></a>\n<p></p><h4 style=\"margin-top:50px;\">具体步骤:</h4><p></p>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\" target=\"_blank\" rel=\"noopener\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：<p></p>\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>不借助vue-cil脚手架，基于webpack+vue搭建开发环境</p>\n<p>github:</p>\n<ul>\n  <li>vue-demo地址：\n    <a href=\"https://github.com/sunhui-blog/vue-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/vue-demo\n    </a>\n  </li>\n  <li>react-demo地址：\n    <a href=\"https://github.com/sunhui-blog/react-demo\" target=\"_blank\">\n      https://github.com/sunhui-blog/react-demo\n    </a>\n  </li>\n</ul>","more":"<p></p><h4 style=\"margin-top:50px;\">具体步骤:</h4><p></p>\n<ol>\n  <li>project初始化：npm init生成package.json</li>\n  <li>安装依赖包：npm i webpack vue vue-loader</li>\n  <li>实例化vue：index.js文件中实例化vue</li>\n  <li>配置webpack.config.js：plugins和loader及开发环境</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<p></p><p>\n  参考：\n  <a href=\"https://blog.csdn.net/u013368397/article/details/86467581\" target=\"_blank\" rel=\"noopener\">\n    不使用cli脚手架搭建vue项目工程(webpack简单配置)\n  </a>\n</p>\n遇到的问题：<p></p>\n<ol>\n  <li>\n    <p>vue+webpack 执行npm run dev后访问首页显示目录结构的原因</p>\n    <p>参考解决：<a href=\"https://blog.csdn.net/rpf1234/article/details/103205173\" target=\"_blank\">https://blog.csdn.net/rpf1234/article/details/103205173</a></p>\n  </li>\n  <li>\n    <p>webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘</p>\n    <p>参考解决：\n      <a href=\"https://juejin.cn/post/6883375553395720199\" target=\"_blank\">\n        https://juejin.cn/post/6883375553395720199\n      </a>\n    </p>\n  </li>\n</ol>"},{"title":"骨架屏","date":"2019-04-26T11:56:38.000Z","thumbnail":"img/flower.jpg","_content":"骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<!-- more -->\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> -->\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：https://github.com/egoist/vue-content-loader</p>\n","source":"_posts/框架/骨架屏.md","raw":"---\ntitle: 骨架屏\ndate: 2019-04-26 19:56:38\ntags: 框架\ncategories: 框架\nthumbnail: img/flower.jpg\n---\n骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<!-- more -->\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> -->\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：https://github.com/egoist/vue-content-loader</p>\n","slug":"框架/骨架屏","published":1,"updated":"2021-01-01T05:31:40.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaac001nuhxxflatr23y","content":"<p>骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。\n<a id=\"more\"></a>\n<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> --></p>\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：<a href=\"https://github.com/egoist/vue-content-loader\" target=\"_blank\" rel=\"noopener\">https://github.com/egoist/vue-content-loader</a></p>\n","site":{"data":{}},"excerpt":"<p>骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。</p>","more":"<!-- <h2>介绍</h2> -->\n<!-- <p>作为与用户联系最为密切的前端开发者，用户体验是最值得关注的问题。关于页面loading状态的展示，主流的主要有loading图和进度条两种。除此之外，越来越多的APP采用了“骨架屏”的方式去展示未加载内容，给予了用户焕然一新的体验。随着SPA在前端界的逐渐流行，首屏加载的问题也在困扰着开发者们。那么有没有一个办法，也能让SPA用上骨架屏呢？这就是这篇文章将要探讨的问题。</p> --></p>\n<p>vue中引入骨架屏：</p>\n<p>可引入的组件：<a href=\"https://github.com/egoist/vue-content-loader\" target=\"_blank\" rel=\"noopener\">https://github.com/egoist/vue-content-loader</a></p>"},{"title":"Javascript数组去重和排序","date":"2020-12-13T02:27:19.000Z","_content":"\n<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n数组去重和排序\n\n<!--more-->\n\n<h4>数组去重: 包含null/undefined</h4>\n<ol>\n  <li>es6的Set\n    ```\n    function unique (arr) {\n      return [...new Set(arr)]\n    }\n\n    function unique (arr) {\n      return Array.from(new Set(arr));\n    }\n\n    unique(['a', 'a', 'b', 'c']) // ['a', 'b', 'c']\n    ```\n  </li>\n  <li>indexOf()结合for...of/forEach/for...in\n    ```\n    const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];\n\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (newArr.indexOf(item) === -1) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>includes()结合for...of/forEach/for...in\n    ```\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (!newArr.includes(item)) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    ```\n    function unique (arr) {\n      const newArr = []\n      let isRepeat = false\n      for (let item of arr) {\n        isRepeat = false\n        for (let newItem of newArr) {\n          if (item === newItem) {\n            isRepeat = true\n          }\n        }\n\n        if (!isRepeat) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n\n    优化版\n    ```\n    function unique (arr) {\n      const newArr = []\n      const len = arr.length\n      for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n          if (arr[i] === arr[j]) {\n            j = ++i\n          }\n        }\n        newArr.push(arr[i])\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n</ol>\n\n<h4>数组排序</h4>\n<ol>\n  <li>sort()\n    ```\n    const arr=[1, 11, 2, 3, 6]\n    arr.sort((a, b) => {\n      return a - b\n    })\n    arr // output: [1, 2, 3, 6, 11]\n    ```\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","source":"_posts/数据结构&算法/Javascript数组去重和排序.md","raw":"---\ntitle: Javascript数组去重和排序\ndate: 2020-12-13 10:27:19\ntags: 算法\ncategories: 数据结构&算法\n---\n\n<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n数组去重和排序\n\n<!--more-->\n\n<h4>数组去重: 包含null/undefined</h4>\n<ol>\n  <li>es6的Set\n    ```\n    function unique (arr) {\n      return [...new Set(arr)]\n    }\n\n    function unique (arr) {\n      return Array.from(new Set(arr));\n    }\n\n    unique(['a', 'a', 'b', 'c']) // ['a', 'b', 'c']\n    ```\n  </li>\n  <li>indexOf()结合for...of/forEach/for...in\n    ```\n    const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];\n\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (newArr.indexOf(item) === -1) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>includes()结合for...of/forEach/for...in\n    ```\n    function unique (arr) {\n      const newArr = [];\n      for(let item of arr){\n        if (!newArr.includes(item)) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    ```\n    function unique (arr) {\n      const newArr = []\n      let isRepeat = false\n      for (let item of arr) {\n        isRepeat = false\n        for (let newItem of newArr) {\n          if (item === newItem) {\n            isRepeat = true\n          }\n        }\n\n        if (!isRepeat) {\n          newArr.push(item)\n        }\n      }\n\n      return newArr\n    }\n    ```\n\n    优化版\n    ```\n    function unique (arr) {\n      const newArr = []\n      const len = arr.length\n      for (let i = 0; i < len; i++) {\n        for (let j = i + 1; j < len; j++) {\n          if (arr[i] === arr[j]) {\n            j = ++i\n          }\n        }\n        newArr.push(arr[i])\n      }\n\n      return newArr\n    }\n    ```\n  </li>\n</ol>\n\n<h4>数组排序</h4>\n<ol>\n  <li>sort()\n    ```\n    const arr=[1, 11, 2, 3, 6]\n    arr.sort((a, b) => {\n      return a - b\n    })\n    arr // output: [1, 2, 3, 6, 11]\n    ```\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","slug":"数据结构&算法/Javascript数组去重和排序","published":1,"updated":"2021-01-15T19:13:28.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaad001quhxxpr1ly6k2","content":"<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n<p>数组去重和排序</p>\n<a id=\"more\"></a>\n<p></p><h4>数组去重: 包含null/undefined</h4><p></p>\n<ol>\n  <li>es6的Set\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>indexOf()结合for…of/forEach/for…in\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (newArr.indexOf(item) === -1) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>includes()结合for…of/forEach/for…in\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (!newArr.includes(item)) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  let isRepeat = false</span><br><span class=\"line\">  for (let item of arr) &#123;</span><br><span class=\"line\">    isRepeat = false</span><br><span class=\"line\">    for (let newItem of newArr) &#123;</span><br><span class=\"line\">      if (item === newItem) &#123;</span><br><span class=\"line\">        isRepeat = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!isRepeat) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    优化版\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  const len = arr.length</span><br><span class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">      if (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        j = ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    newArr.push(arr[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4>数组排序</h4><p></p>\n<ol>\n  <li>sort()\n    <figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr=[1, 11, 2, 3, 6]</span><br><span class=\"line\">arr.sort((a, b) =&gt; &#123;</span><br><span class=\"line\">  return a - b</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">arr // output: [1, 2, 3, 6, 11]</span><br></pre></td></tr></table></figure>\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.red {\n  color: red;\n}\n</style>\n\n<p>数组去重和排序</p>","more":"<p></p><h4>数组去重: 包含null/undefined</h4><p></p>\n<ol>\n  <li>es6的Set\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return [...new Set(arr)]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">unique([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>indexOf()结合for…of/forEach/for…in\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];</span><br><span class=\"line\"></span><br><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (newArr.indexOf(item) === -1) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>includes()结合for…of/forEach/for…in\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = [];</span><br><span class=\"line\">  for(let item of arr)&#123;</span><br><span class=\"line\">    if (!newArr.includes(item)) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n  <li>双重for循环，<span class=\"red\">时间复杂度为O(n^2)</span>\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  let isRepeat = false</span><br><span class=\"line\">  for (let item of arr) &#123;</span><br><span class=\"line\">    isRepeat = false</span><br><span class=\"line\">    for (let newItem of newArr) &#123;</span><br><span class=\"line\">      if (item === newItem) &#123;</span><br><span class=\"line\">        isRepeat = true</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (!isRepeat) &#123;</span><br><span class=\"line\">      newArr.push(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n    优化版\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique (arr) &#123;</span><br><span class=\"line\">  const newArr = []</span><br><span class=\"line\">  const len = arr.length</span><br><span class=\"line\">  for (let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">    for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">      if (arr[i] === arr[j]) &#123;</span><br><span class=\"line\">        j = ++i</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    newArr.push(arr[i])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return newArr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </li>\n</ol>\n\n<p></p><h4>数组排序</h4><p></p>\n<ol>\n  <li>sort()\n    <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const arr=[1, 11, 2, 3, 6]</span><br><span class=\"line\">arr.sort((a, b) =&gt; &#123;</span><br><span class=\"line\">  return a - b</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">arr // output: [1, 2, 3, 6, 11]</span><br></pre></td></tr></table></figure>\n\n    注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。\n  </li>\n</ol>"},{"title":"浏览器中的EventLoop","date":"2019-09-30T03:37:05.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://www.ruanyifeng.com/blog/2014/10/event-loop.html</li>\n  <li>https://wangdoc.com/javascript/events/model.html</li>\n</ol>\n","source":"_posts/浏览器/浏览器中的EventLoop.md","raw":"---\ntitle: 浏览器中的EventLoop\ndate: 2019-09-30 11:37:05\ntags: 浏览器\ncategories: 浏览器\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://www.ruanyifeng.com/blog/2014/10/event-loop.html</li>\n  <li>https://wangdoc.com/javascript/events/model.html</li>\n</ol>\n","slug":"浏览器/浏览器中的EventLoop","published":1,"updated":"2021-01-01T05:32:06.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaae001tuhxxiw64yb3e","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>\n  <li><a href=\"https://wangdoc.com/javascript/events/model.html\" target=\"_blank\" rel=\"noopener\">https://wangdoc.com/javascript/events/model.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>\n  <li><a href=\"https://wangdoc.com/javascript/events/model.html\" target=\"_blank\" rel=\"noopener\">https://wangdoc.com/javascript/events/model.html</a></li>\n</ol>\n"},{"title":"浏览器缓存机制","date":"2019-09-30T08:55:50.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://bbs.qcloud.com/thread-3775-1-1.html</li>\n  <li>https://www.jb51.net/article/51951.htm</li>\n  <li>https://segmentfault.com/a/1190000016265991</li>\n  <li>https://juejin.im/entry/5ad86c16f265da505a77dca4</li>\n</ol>\n","source":"_posts/浏览器/浏览器缓存机制.md","raw":"---\ntitle: 浏览器缓存机制\ndate: 2019-09-30 16:55:50\ntags: 浏览器\ncategories: 浏览器\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>http://bbs.qcloud.com/thread-3775-1-1.html</li>\n  <li>https://www.jb51.net/article/51951.htm</li>\n  <li>https://segmentfault.com/a/1190000016265991</li>\n  <li>https://juejin.im/entry/5ad86c16f265da505a77dca4</li>\n</ol>\n","slug":"浏览器/浏览器缓存机制","published":1,"updated":"2021-01-01T05:31:57.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaaf001zuhxxbcnks8co","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://bbs.qcloud.com/thread-3775-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.qcloud.com/thread-3775-1-1.html</a></li>\n  <li><a href=\"https://www.jb51.net/article/51951.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/51951.htm</a></li>\n  <li><a href=\"https://segmentfault.com/a/1190000016265991\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016265991</a></li>\n  <li><a href=\"https://juejin.im/entry/5ad86c16f265da505a77dca4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad86c16f265da505a77dca4</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"http://bbs.qcloud.com/thread-3775-1-1.html\" target=\"_blank\" rel=\"noopener\">http://bbs.qcloud.com/thread-3775-1-1.html</a></li>\n  <li><a href=\"https://www.jb51.net/article/51951.htm\" target=\"_blank\" rel=\"noopener\">https://www.jb51.net/article/51951.htm</a></li>\n  <li><a href=\"https://segmentfault.com/a/1190000016265991\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000016265991</a></li>\n  <li><a href=\"https://juejin.im/entry/5ad86c16f265da505a77dca4\" target=\"_blank\" rel=\"noopener\">https://juejin.im/entry/5ad86c16f265da505a77dca4</a></li>\n</ol>\n"},{"title":"UML类图与交互图","date":"2019-08-09T07:10:40.000Z","_content":"<p>总结UML类图与交互图相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\nhttps://www.jianshu.com/p/08015c0ca2f1","source":"_posts/程序设计/UML类图与交互图.md","raw":"---\ntitle: UML类图与交互图\ndate: 2019-08-09 15:10:40\ntags: 程序设计\ncategories: 程序设计\n---\n<p>总结UML类图与交互图相关知识，加深学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n\nhttps://www.jianshu.com/p/08015c0ca2f1","slug":"程序设计/UML类图与交互图","published":1,"updated":"2021-01-01T11:25:14.878Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaag0022uhxxja60ra60","content":"<p></p><p>总结UML类图与交互图相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p><a href=\"https://www.jianshu.com/p/08015c0ca2f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08015c0ca2f1</a></p>\n","site":{"data":{}},"excerpt":"<p></p><p>总结UML类图与交互图相关知识，加深学习和理解。</p><p></p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p><a href=\"https://www.jianshu.com/p/08015c0ca2f1\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/08015c0ca2f1</a></p>"},{"title":"web安全","date":"2019-10-10T10:54:05.000Z","toc":true,"_content":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: https://baike.baidu.com/item/WAF</p>\n\n","source":"_posts/网络安全/web安全.md","raw":"---\ntitle: web安全\ndate: 2019-10-10 18:54:05\ntoc: true\ncategories: 网络安全\n---\n<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: https://baike.baidu.com/item/WAF</p>\n\n","slug":"网络安全/web安全","published":1,"updated":"2021-01-01T05:32:28.754Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaah0025uhxxrkyws12r","content":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: <a href=\"https://baike.baidu.com/item/WAF\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/WAF</a></p>\n\n","site":{"data":{}},"excerpt":"","more":"<p>出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。</p>\n<p>参考: <a href=\"https://baike.baidu.com/item/WAF\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/WAF</a></p>\n\n"},{"title":"进程与线程","date":"2020-03-20T19:23:55.000Z","_content":"\n巩固补充一波基础知识\n<!-- more -->\n\n进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。\n\n\n","source":"_posts/计算机基础/进程与线程.md","raw":"---\ntitle: 进程与线程\ndate: 2020-03-21 03:23:55\ncategories: 计算机基础\n---\n\n巩固补充一波基础知识\n<!-- more -->\n\n进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。\n\n\n","slug":"计算机基础/进程与线程","published":1,"updated":"2021-01-01T05:31:15.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaai0028uhxxhnfx06d9","content":"<p>巩固补充一波基础知识\n<a id=\"more\"></a></p>\n<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>\n","site":{"data":{}},"excerpt":"<p>巩固补充一波基础知识</p>","more":"</p>\n<p>进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。</p>"},{"title":"JavaScript设计模式-观察者模式","date":"2019-05-24T15:31:27.000Z","thumbnail":"img/desert.jpg","_content":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。<p>\n\n\n``` \n// 发布者\nfunction Publisher() {\n    var self = this;\n    self.dispatcher = $({});\n}\n\n// 触发send操作时，发布信息\nPublisher.prototype.send = function (){\n    var self = this\n    self.dispatcher.trigger(\"sendMessage\", [\"Yes\"]);\n}\n\n// 订阅者\nvar subscribe = new Publisher()\n\n// 订阅者获取信息\nsubscribe.dispatcher.on('sendMessage',function(data){\n    console.log(data);  // 输出“Yes”\n});\n\n// 发送信息触发\nsubscribe.send();\n\n\n```\n<h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","source":"_posts/设计模式/JavaScript设计模式-观察者模式.md","raw":"---\ntitle: JavaScript设计模式-观察者模式\ndate: 2019-05-24 23:31:27\ntags: 设计模式\ncategories: 设计模式\nthumbnail: img/desert.jpg\n---\n<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<!-- more -->\n\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。<p>\n\n\n``` \n// 发布者\nfunction Publisher() {\n    var self = this;\n    self.dispatcher = $({});\n}\n\n// 触发send操作时，发布信息\nPublisher.prototype.send = function (){\n    var self = this\n    self.dispatcher.trigger(\"sendMessage\", [\"Yes\"]);\n}\n\n// 订阅者\nvar subscribe = new Publisher()\n\n// 订阅者获取信息\nsubscribe.dispatcher.on('sendMessage',function(data){\n    console.log(data);  // 输出“Yes”\n});\n\n// 发送信息触发\nsubscribe.send();\n\n\n```\n<h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","slug":"设计模式/JavaScript设计模式-观察者模式","published":1,"updated":"2021-01-01T05:32:17.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaai002auhxxzj088dpv","content":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>\n\n<a id=\"more\"></a>\n<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。</p><p>\n\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 发布者</span><br><span class=\"line\">function Publisher() &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self.dispatcher = $(&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 触发send操作时，发布信息</span><br><span class=\"line\">Publisher.prototype.send = function ()&#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    self.dispatcher.trigger(&quot;sendMessage&quot;, [&quot;Yes&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者</span><br><span class=\"line\">var subscribe = new Publisher()</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者获取信息</span><br><span class=\"line\">subscribe.dispatcher.on(&apos;sendMessage&apos;,function(data)&#123;</span><br><span class=\"line\">    console.log(data);  // 输出“Yes”</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送信息触发</span><br><span class=\"line\">subscribe.send();</span><br></pre></td></tr></table></figure>\n\n</p><h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>","site":{"data":{}},"excerpt":"<p style=\"text-indent:30px\">概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。</p>","more":"<p style=\"text-indent:30px\">观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。</p>\n\n<p style=\"text-indent:30px\">为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。</p>\n\n<p style=\"text-indent:30px\">此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。</p>\n\n<p style=\"text-indent:30px\">目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。</p>\n\n<p style=\"text-indent:30px\">此处举个简单常用的例子，组件间的传值。</p>\n\n<p style=\"text-indent:30px\">实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。</p><p>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 发布者</span><br><span class=\"line\">function Publisher() &#123;</span><br><span class=\"line\">    var self = this;</span><br><span class=\"line\">    self.dispatcher = $(&#123;&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 触发send操作时，发布信息</span><br><span class=\"line\">Publisher.prototype.send = function ()&#123;</span><br><span class=\"line\">    var self = this</span><br><span class=\"line\">    self.dispatcher.trigger(&quot;sendMessage&quot;, [&quot;Yes&quot;]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者</span><br><span class=\"line\">var subscribe = new Publisher()</span><br><span class=\"line\"></span><br><span class=\"line\">// 订阅者获取信息</span><br><span class=\"line\">subscribe.dispatcher.on(&apos;sendMessage&apos;,function(data)&#123;</span><br><span class=\"line\">    console.log(data);  // 输出“Yes”</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 发送信息触发</span><br><span class=\"line\">subscribe.send();</span><br></pre></td></tr></table></figure>\n\n</p><h4>注：</h4>\n<ol>\n    <li>部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证</li>\n    <li>复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充</li>\n</ol>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"设计模式概览","date":"2019-07-29T08:37:49.000Z","_content":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<h4>创建型模式</h4>\n<ol>\n  <li>Abstract Factory(抽象工厂)--对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      <p>\n    </div>\n  </li>\n</ol>\n\n<h4>行为型模式</h4>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：https://github.com/sunhui-blog/designPatterns</p>  \n\n代码后续会逐渐优化~\n\n<h4 style=\"margin-top:50px;\">格式</h4>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","source":"_posts/设计模式/设计模式概览.md","raw":"---\ntitle: 设计模式概览\ndate: 2019-07-29 16:37:49\ntags: 设计模式\ncategories: 设计模式\n---\n<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<!-- more -->\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<h4>创建型模式</h4>\n<ol>\n  <li>Abstract Factory(抽象工厂)--对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      <p>\n    </div>\n  </li>\n</ol>\n\n<h4>行为型模式</h4>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：https://github.com/sunhui-blog/designPatterns</p>  \n\n代码后续会逐渐优化~\n\n<h4 style=\"margin-top:50px;\">格式</h4>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","slug":"设计模式/设计模式概览","published":1,"updated":"2021-01-01T05:32:13.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaaj002cuhxx84ftv52j","content":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>\n\n<a id=\"more\"></a>\n<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<p></p><h4>创建型模式</h4><p></p>\n<ol>\n  <li>Abstract Factory(抽象工厂)–对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      </p><p>\n    </p></div>\n  </li>\n</ol>\n\n<p></p><h4>行为型模式</h4><p></p>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：<a href=\"https://github.com/sunhui-blog/designPatterns\" target=\"_blank\" rel=\"noopener\">https://github.com/sunhui-blog/designPatterns</a></p>  \n\n<p>代码后续会逐渐优化~</p>\n<p></p><h4 style=\"margin-top:50px;\">格式</h4><p></p>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>\n","site":{"data":{}},"excerpt":"<p>总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。</p>\n<style type=\"text/css\">\n.red{color:red;}\n</style>","more":"<p>原则：找出程序中变化的地方，并将变化封装起来。</p>\n\n<p class=\"red\">理解和应用上恐有偏差，会持续更新完善</p>\n\n<p></p><h4>创建型模式</h4><p></p>\n<ol>\n  <li>Abstract Factory(抽象工厂)–对象创建型模型\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。\n      </p>\n    </div>\n  </li>\n  <li>Builder(生成器)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。\n      </p>\n    </div>\n  </li>\n  <li>Singleton(单例模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：保证一个类仅有<span class=\"red\">一个实例</span>，并提供一个访问它的<span class=\"red\">全局访问点</span>。\n      </p>\n      <p>\n        理解点在于：\n          让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。\n          并提供可以访问该实例的方法。\n      </p>\n      <p>\n        应用实践：登陆弹框\n      </p><p>\n    </p></div>\n  </li>\n</ol>\n\n<p></p><h4>行为型模式</h4><p></p>\n<ol>\n  <li>Mediator(中介者)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。\n      </p>\n    </div>\n  </li>\n  <li>Observer(观察者)\n    <div>\n      <p>\n        概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n      </p>\n      <p>\n        副作用：需要维护相关对象的一致性。\n      </p>\n    </div>\n  </li>\n  <li>Strategy(策略模式)\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。\n      </p>\n    </div>\n  </li>\n</ol>\n\n<p>实例：<a href=\"https://github.com/sunhui-blog/designPatterns\" target=\"_blank\" rel=\"noopener\">https://github.com/sunhui-blog/designPatterns</a></p>  \n\n<p>代码后续会逐渐优化~</p>\n<p></p><h4 style=\"margin-top:50px;\">格式</h4><p></p>\n<ul>\n  <li>模式名称\n    <div style=\"margin-top:10px;\">\n      <p>\n        概念：待补充\n      </p>\n      <p>\n        理解点在于：待补充\n      </p>\n      <p>\n        副作用：待补充\n      </p>\n      <p>\n        类图：待补充\n      </p>\n      <p>\n        交互图：待补充\n      </p>\n      <p>\n        应用实践：待补充\n      </p>\n    </div>\n  </li>\n</ul>\n\n<p style=\"margin-top: 60px;color: #666;font-size: 1.2rem;\">#未完待续#</p>"},{"title":"网络传输模型","date":"2020-12-21T16:06:09.000Z","_content":"<p>简述网络传输过程。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    ![OSI七层参考模型](/img/network/osi.png)\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    ![TCP/IP五层模型](/img/network/tcp.png)\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</li>\n</ol>\n","source":"_posts/计算机网络/网络传输模型.md","raw":"---\ntitle: 网络传输模型\ndate: 2020-12-22 00:06:09\ntags: 网络知识\ncategories: 计算机网络\n---\n<p>简述网络传输过程。</p>\n\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    ![OSI七层参考模型](/img/network/osi.png)\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    ![TCP/IP五层模型](/img/network/tcp.png)\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</li>\n</ol>\n","slug":"计算机网络/网络传输模型","published":1,"updated":"2021-01-01T05:31:23.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaak002fuhxxyn1q45rl","content":"<p>简述网络传输过程。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    <img src=\"/img/network/osi.png\" alt=\"OSI七层参考模型\">\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    <img src=\"/img/network/tcp.png\" alt=\"TCP/IP五层模型\">\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2\" target=\"_blank\" rel=\"noopener\">https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>简述网络传输过程。</p>","more":"<ol>\n  <li class=\"pt\">\n    OSI(Open System Interconnection)七层参考模型\n    <img src=\"/img/network/osi.png\" alt=\"OSI七层参考模型\">\n  </li>\n  <li class=\"pt\">\n    TCP/IP(Transmission Control Protocol/ Internet Protocol)\n    <img src=\"/img/network/tcp.png\" alt=\"TCP/IP五层模型\">\n  </li>\n  <li class=\"pt\">\n    <p>KEY DIFFERENCE</p>\n    <ul>\n      <li>OSI has 7 layers whereas TCP/IP has 4 layers.</li>\n      <li>The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them.</li>\n      <li>OSI header is 5 bytes whereas TCP/IP header size is 20 bytes.</li>\n      <li>OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol.</li>\n      <li>OSI follows a vertical approach whereas TCP/IP follows a horizontal approach.</li>\n      <li>OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless.</li>\n      <li>OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network).</li>\n      <li>OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers.</li>\n    </ul>\n  </li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2\" target=\"_blank\" rel=\"noopener\">https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2</a></li>\n</ol>"},{"title":"手写一个reduce","date":"2021-01-13T11:05:14.000Z","_content":"\nreduce累加器的js实现\n<!-- more -->\n\n```\nArray.prototype.myReduce = function (callback, initVal) {\n  const arr = this\n\n  arr.forEach((item) => {\n    initVal = callback(item, initVal)\n  })\n\n  return initVal\n}\n```\n\n测试一下：\n```\nconst datas = [4, 8, 15, 16, 23, 42]\n\nconst sum = datas.myReduce(function (prev, next) {\n  return prev + next\n}, 0)\n\nconsole.log(sum) // 108\n```\n","source":"_posts/JavaScript/手写一个reduce.md","raw":"---\ntitle: 手写一个reduce\ndate: 2021-01-13 19:05:14\ntags: 编程语言\ncategories: JavaScript\n---\n\nreduce累加器的js实现\n<!-- more -->\n\n```\nArray.prototype.myReduce = function (callback, initVal) {\n  const arr = this\n\n  arr.forEach((item) => {\n    initVal = callback(item, initVal)\n  })\n\n  return initVal\n}\n```\n\n测试一下：\n```\nconst datas = [4, 8, 15, 16, 23, 42]\n\nconst sum = datas.myReduce(function (prev, next) {\n  return prev + next\n}, 0)\n\nconsole.log(sum) // 108\n```\n","slug":"JavaScript/手写一个reduce","published":1,"updated":"2021-01-15T21:55:31.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaal002iuhxx99rh9x6p","content":"<p>reduce累加器的js实现\n<a id=\"more\"></a></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (callback, initVal) &#123;</span><br><span class=\"line\">  const arr = this</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.forEach((item) =&gt; &#123;</span><br><span class=\"line\">    initVal = callback(item, initVal)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return initVal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const datas = [4, 8, 15, 16, 23, 42]</span><br><span class=\"line\"></span><br><span class=\"line\">const sum = datas.myReduce(function (prev, next) &#123;</span><br><span class=\"line\">  return prev + next</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum) // 108</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>reduce累加器的js实现</p>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.prototype.myReduce = function (callback, initVal) &#123;</span><br><span class=\"line\">  const arr = this</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.forEach((item) =&gt; &#123;</span><br><span class=\"line\">    initVal = callback(item, initVal)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  return initVal</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>测试一下：\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const datas = [4, 8, 15, 16, 23, 42]</span><br><span class=\"line\"></span><br><span class=\"line\">const sum = datas.myReduce(function (prev, next) &#123;</span><br><span class=\"line\">  return prev + next</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(sum) // 108</span><br></pre></td></tr></table></figure></p>"},{"title":"手写一个简易版promise","date":"2021-01-13T15:58:42.000Z","_content":"\npromise的简易实现\n<!-- more -->\n\n<h5>解决的问题有：</h5>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<h5>运用到的设计模式：</h5>\n<p>发布订阅模式：收集依赖 -> 触发通知 -> 取出依赖执行</p>\n\n\n```\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nclass Promise {\n  constructor (executor) {\n    this.status = PENDING\n    this.value = null\n    this.reason = null\n    // 存放依赖\n    this.onRejectedCallbacks = []\n    this.onResolvedCallbacks = []\n\n    // 触发通知\n    const resolve = (value) => {\n      if (this.status === PENDING) {\n        this.status = FULFILLED\n        this.value = value\n\n        // 执行依赖\n        this.onResolvedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    // 触发通知\n    const reject = (value) => {\n      if (this.status === PENDING) {\n        this.status = REJECTED\n        this.reason = value\n\n        // 执行依赖\n        this.onRejectedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  then (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.reason)\n    }\n\n    // 收集依赖\n    if (this.status === PENDING) {\n      this.onResolvedCallbacks.push(() => {\n        onFulfilled(this.value)\n      })\n\n      this.onRejectedCallbacks.push(() => {\n        onRejected(this.reason)\n      })\n    }\n  }\n}\n```\n\n<h5>测试一下：</h5>\n```\nnew Promise((resolve, reject) => {\n  resolve('success')\n}).then((data) => {\n  console.log(data) // 'success'\n}, (err) => {\n  console.log(err)\n})\n```\n\n\n```\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  }, 100)\n}).then((data) => {\n  console.log(data) // 'success'\n}, (error) => {\n  console.log(error)\n})\n```\n","source":"_posts/JavaScript/手写一个简易版promise.md","raw":"---\ntitle: 手写一个简易版promise\ndate: 2021-01-13 23:58:42\ntags: 编程语言\ncategories: JavaScript\n---\n\npromise的简易实现\n<!-- more -->\n\n<h5>解决的问题有：</h5>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<h5>运用到的设计模式：</h5>\n<p>发布订阅模式：收集依赖 -> 触发通知 -> 取出依赖执行</p>\n\n\n```\nconst PENDING = 'PENDING'\nconst FULFILLED = 'FULFILLED'\nconst REJECTED = 'REJECTED'\n\nclass Promise {\n  constructor (executor) {\n    this.status = PENDING\n    this.value = null\n    this.reason = null\n    // 存放依赖\n    this.onRejectedCallbacks = []\n    this.onResolvedCallbacks = []\n\n    // 触发通知\n    const resolve = (value) => {\n      if (this.status === PENDING) {\n        this.status = FULFILLED\n        this.value = value\n\n        // 执行依赖\n        this.onResolvedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    // 触发通知\n    const reject = (value) => {\n      if (this.status === PENDING) {\n        this.status = REJECTED\n        this.reason = value\n\n        // 执行依赖\n        this.onRejectedCallbacks.forEach((fn) => fn())\n      }\n    }\n\n    try {\n      executor(resolve, reject)\n    } catch (error) {\n      reject(error)\n    }\n  }\n\n  then (onFulfilled, onRejected) {\n    if (this.status === FULFILLED) {\n      onFulfilled(this.value)\n    }\n\n    if (this.status === REJECTED) {\n      onRejected(this.reason)\n    }\n\n    // 收集依赖\n    if (this.status === PENDING) {\n      this.onResolvedCallbacks.push(() => {\n        onFulfilled(this.value)\n      })\n\n      this.onRejectedCallbacks.push(() => {\n        onRejected(this.reason)\n      })\n    }\n  }\n}\n```\n\n<h5>测试一下：</h5>\n```\nnew Promise((resolve, reject) => {\n  resolve('success')\n}).then((data) => {\n  console.log(data) // 'success'\n}, (err) => {\n  console.log(err)\n})\n```\n\n\n```\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  }, 100)\n}).then((data) => {\n  console.log(data) // 'success'\n}, (error) => {\n  console.log(error)\n})\n```\n","slug":"JavaScript/手写一个简易版promise","published":1,"updated":"2021-01-15T21:55:28.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaan002luhxx6xs17a1o","content":"<p>promise的简易实现\n<a id=\"more\"></a></p>\n<p></p><h5>解决的问题有：</h5><p></p>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<p></p><h5>运用到的设计模式：</h5><p></p>\n<p>发布订阅模式：收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</p>\n\n\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PENDING = &apos;PENDING&apos;</span><br><span class=\"line\">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class=\"line\">const REJECTED = &apos;REJECTED&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">  constructor (executor) &#123;</span><br><span class=\"line\">    this.status = PENDING</span><br><span class=\"line\">    this.value = null</span><br><span class=\"line\">    this.reason = null</span><br><span class=\"line\">    // 存放依赖</span><br><span class=\"line\">    this.onRejectedCallbacks = []</span><br><span class=\"line\">    this.onResolvedCallbacks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const resolve = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = FULFILLED</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onResolvedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const reject = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = REJECTED</span><br><span class=\"line\">        this.reason = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onRejectedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      executor(resolve, reject)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">      onFulfilled(this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (this.status === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(this.reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集依赖</span><br><span class=\"line\">    if (this.status === PENDING) &#123;</span><br><span class=\"line\">      this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onFulfilled(this.value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onRejected(this.reason)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p></p><h5>测试一下：</h5>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;success&apos;)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;success&apos;)</span><br><span class=\"line\">  &#125;, 100)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>promise的简易实现</p>","more":"</p>\n<p></p><h5>解决的问题有：</h5><p></p>\n<ol>\n  <li>嵌套调用，第一个函数的输出往往是第二个函数的输入；</li>\n  <li>处理多个异步请求并发，开发时往往需要同步请求最终的结果。</li>\n</ol>\n\n<p></p><h5>运用到的设计模式：</h5><p></p>\n<p>发布订阅模式：收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行</p>\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const PENDING = &apos;PENDING&apos;</span><br><span class=\"line\">const FULFILLED = &apos;FULFILLED&apos;</span><br><span class=\"line\">const REJECTED = &apos;REJECTED&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">class Promise &#123;</span><br><span class=\"line\">  constructor (executor) &#123;</span><br><span class=\"line\">    this.status = PENDING</span><br><span class=\"line\">    this.value = null</span><br><span class=\"line\">    this.reason = null</span><br><span class=\"line\">    // 存放依赖</span><br><span class=\"line\">    this.onRejectedCallbacks = []</span><br><span class=\"line\">    this.onResolvedCallbacks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const resolve = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = FULFILLED</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onResolvedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 触发通知</span><br><span class=\"line\">    const reject = (value) =&gt; &#123;</span><br><span class=\"line\">      if (this.status === PENDING) &#123;</span><br><span class=\"line\">        this.status = REJECTED</span><br><span class=\"line\">        this.reason = value</span><br><span class=\"line\"></span><br><span class=\"line\">        // 执行依赖</span><br><span class=\"line\">        this.onRejectedCallbacks.forEach((fn) =&gt; fn())</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      executor(resolve, reject)</span><br><span class=\"line\">    &#125; catch (error) &#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  then (onFulfilled, onRejected) &#123;</span><br><span class=\"line\">    if (this.status === FULFILLED) &#123;</span><br><span class=\"line\">      onFulfilled(this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (this.status === REJECTED) &#123;</span><br><span class=\"line\">      onRejected(this.reason)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 收集依赖</span><br><span class=\"line\">    if (this.status === PENDING) &#123;</span><br><span class=\"line\">      this.onResolvedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onFulfilled(this.value)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      this.onRejectedCallbacks.push(() =&gt; &#123;</span><br><span class=\"line\">        onRejected(this.reason)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p></p><h5>测试一下：</h5>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&apos;success&apos;)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (err) =&gt; &#123;</span><br><span class=\"line\">  console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><p></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    resolve(&apos;success&apos;)</span><br><span class=\"line\">  &#125;, 100)</span><br><span class=\"line\">&#125;).then((data) =&gt; &#123;</span><br><span class=\"line\">  console.log(data) // &apos;success&apos;</span><br><span class=\"line\">&#125;, (error) =&gt; &#123;</span><br><span class=\"line\">  console.log(error)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"},{"title":"跨平台多端适配","date":"2021-01-07T11:16:22.000Z","_content":"\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    Weex:https://weex.apache.org/zh/\n  </li>\n</ol>","source":"_posts/兼容性问题处理/多端适配.md","raw":"---\ntitle: 跨平台多端适配\ndate: 2021-01-07 19:16:22\ntags: 架构\ncategories: 架构\n---\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>\n  <li>\n    Weex:https://weex.apache.org/zh/\n  </li>\n</ol>","slug":"兼容性问题处理/多端适配","published":1,"updated":"2021-01-15T21:23:15.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaao002ouhxxlhvk3cjd","content":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    Weex:<a href=\"https://weex.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">https://weex.apache.org/zh/</a>\n  </li>\n</ol>","site":{"data":{}},"excerpt":"","more":"<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li>\n    Weex:<a href=\"https://weex.apache.org/zh/\" target=\"_blank\" rel=\"noopener\">https://weex.apache.org/zh/</a>\n  </li>\n</ol>"},{"title":"Performance Monitor性能指标","date":"2021-01-10T14:28:17.000Z","_content":"\n查看性能指标，页面性能调优。\n\n<!--more-->\n\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://juejin.cn/post/6844904045774110733</li>\n</ol>","source":"_posts/异常&性能/Performance-Monitor性能指标.md","raw":"---\ntitle: Performance Monitor性能指标\ndate: 2021-01-10 22:28:17\ntags: 异常&性能\ncategories: 异常&性能\n---\n\n查看性能指标，页面性能调优。\n\n<!--more-->\n\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<h4 style=\"margin-top: 40px;\"><附></h4>\n<ol>\n  <li>https://juejin.cn/post/6844904045774110733</li>\n</ol>","slug":"异常&性能/Performance-Monitor性能指标","published":1,"updated":"2021-01-15T21:22:18.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaap002ruhxxlogxo9a1","content":"<p>查看性能指标，页面性能调优。</p>\n<a id=\"more\"></a>\n<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904045774110733\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904045774110733</a></li>\n</ol>","site":{"data":{}},"excerpt":"<p>查看性能指标，页面性能调优。</p>","more":"<ol>\n  <li>CPU usage, CPU占用率</li>\n  <li>JS head size, JS内存使用大小</li>\n  <li>DOM Nodes, 内存中挂载的DOM节点个数</li>\n  <li>JS event listeners, 事件监听数</li>\n</ol>\n\n<p></p><h4 style=\"margin-top: 40px;\">&lt;附&gt;</h4><p></p>\n<ol>\n  <li><a href=\"https://juejin.cn/post/6844904045774110733\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844904045774110733</a></li>\n</ol>"},{"title":"前端异常处理","date":"2021-01-10T02:44:51.000Z","_content":"\nhttp://jartto.wang/2018/11/20/js-exception-handling/","source":"_posts/异常&性能/前端异常处理.md","raw":"---\ntitle: 前端异常处理\ndate: 2021-01-10 10:44:51\ntags: 异常&性能\ncategories: 异常&性能\n---\n\nhttp://jartto.wang/2018/11/20/js-exception-handling/","slug":"异常&性能/前端异常处理","published":1,"updated":"2021-01-15T21:09:47.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaaq002uuhxx98lxis7j","content":"<p><a href=\"http://jartto.wang/2018/11/20/js-exception-handling/\" target=\"_blank\" rel=\"noopener\">http://jartto.wang/2018/11/20/js-exception-handling/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://jartto.wang/2018/11/20/js-exception-handling/\" target=\"_blank\" rel=\"noopener\">http://jartto.wang/2018/11/20/js-exception-handling/</a></p>\n"},{"title":"无服务器架构","date":"2020-02-18T04:42:11.000Z","_content":"\n无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。\n\n千万级流量业务的Serverless实践，看FaaS给前端带来的变化：https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\n\n深入理解无服务器架构(Faas/Serverless)：https://blog.csdn.net/xialingming/article/details/81369624\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</li>\n</ol>\n\n\n","source":"_posts/架构/无服务器架构.md","raw":"---\ntitle: 无服务器架构\ndate: 2020-02-18 12:42:11\ncategories: 架构\ntags: 架构\n---\n\n无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。\n\n千万级流量业务的Serverless实践，看FaaS给前端带来的变化：https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\n\n深入理解无服务器架构(Faas/Serverless)：https://blog.csdn.net/xialingming/article/details/81369624\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</li>\n</ol>\n\n\n","slug":"架构/无服务器架构","published":1,"updated":"2021-01-15T21:25:09.115Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaar002xuhxxunu4tovy","content":"<p>无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。</p>\n<p>千万级流量业务的Serverless实践，看FaaS给前端带来的变化：<a href=\"https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q</a></p>\n<p>深入理解无服务器架构(Faas/Serverless)：<a href=\"https://blog.csdn.net/xialingming/article/details/81369624\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xialingming/article/details/81369624</a></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</a></li>\n</ol>\n\n\n","site":{"data":{}},"excerpt":"","more":"<p>无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。</p>\n<p>千万级流量业务的Serverless实践，看FaaS给前端带来的变化：<a href=\"https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q</a></p>\n<p>深入理解无服务器架构(Faas/Serverless)：<a href=\"https://blog.csdn.net/xialingming/article/details/81369624\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xialingming/article/details/81369624</a></p>\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/\" target=\"_blank\" rel=\"noopener\">https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/</a></li>\n</ol>\n\n\n"},{"title":"「vue-router源码」页面问题：菜单路由连续点击无响应","date":"2021-01-15T03:10:56.000Z","_content":"\n<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<!-- more -->\n\n![控制台报错信息](/img/vuerouter/error.png)\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 -- promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p>触发该报错信息条件：</p>\n```\n// in the case the route map has been dynamically appended to\n```\n![触发条件-vuerouter源码](/img/vuerouter/samerouter.png)\n\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\nmatched机制说明：\n<ol>\n  <li>matched的map源码实现：\n  ![matched-vuerouter源码](/img/vuerouter/matched.png)</li>\n</ol>\n","source":"_posts/框架/菜单路由连续点击无响应.md","raw":"---\ntitle: 「vue-router源码」页面问题：菜单路由连续点击无响应\ndate: 2021-01-15 11:10:56\ntags: 框架\ncategories: 框架\n---\n\n<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<!-- more -->\n\n![控制台报错信息](/img/vuerouter/error.png)\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 -- promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p>触发该报错信息条件：</p>\n```\n// in the case the route map has been dynamically appended to\n```\n![触发条件-vuerouter源码](/img/vuerouter/samerouter.png)\n\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<h4 style=\"margin-top:50px;\"><附></h4>\nmatched机制说明：\n<ol>\n  <li>matched的map源码实现：\n  ![matched-vuerouter源码](/img/vuerouter/matched.png)</li>\n</ol>\n","slug":"框架/菜单路由连续点击无响应","published":1,"updated":"2021-01-15T21:56:49.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaas0030uhxxaglz7sw0","content":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>\n<a id=\"more\"></a>\n\n<img src=\"/img/vuerouter/error.png\" alt=\"控制台报错信息\">\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 – promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p></p><p>触发该报错信息条件：</p>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// in the case the route map has been dynamically appended to</span><br></pre></td></tr></table></figure><p></p>\n<p><img src=\"/img/vuerouter/samerouter.png\" alt=\"触发条件-vuerouter源码\"></p>\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\nmatched机制说明：<p></p>\n<ol>\n  <li>matched的map源码实现：\n  <img src=\"/img/vuerouter/matched.png\" alt=\"matched-vuerouter源码\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.pt{padding-top: 10px;}\n.mt5{margin-top: 5px;}\n.mt10{margin-top: 10px;}\n.red{color: red;}\n.blue{color: blue;}\n.fb{font-weight: bolder}\n</style>\n\n<p>页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。</p>","more":"<img src=\"/img/vuerouter/error.png\" alt=\"控制台报错信息\">\n\n<p class=\"mt10\" style=\"margin-top: 30px;\">\n  <span class=\"fb\">问题出现在：</span>\n  <span class=\"red\">vue-router v3.0.7版本后</span>\n</p>\n\n<div class=\"mt5\">\n  <span class=\"fb\">问题解决方式：</span>\n  <span class=\"blue\">package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 – promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。</span>\n</div>\n\n<p class=\"fb mt10\" style=\"margin-top: 30px;\">\n  解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。\n</p>\n\n<p></p><p>触发该报错信息条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// in the case the route map has been dynamically appended to</span><br></pre></td></tr></table></figure><p></p>\n<p><img src=\"/img/vuerouter/samerouter.png\" alt=\"触发条件-vuerouter源码\"></p>\n<ol>\n  <li>isSameRoute()：match匹配</li>\n  <li>上次路由索引 与 当前路由索引 全匹配</li>\n  <li>在2条件满足后，触发vue-router的matched机制</li>\n</ol>\n\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4>\nmatched机制说明：<p></p>\n<ol>\n  <li>matched的map源码实现：\n  <img src=\"/img/vuerouter/matched.png\" alt=\"matched-vuerouter源码\"></li>\n</ol>"},{"title":"JavaScript柯里化","date":"2021-01-12T12:04:18.000Z","_content":"\n<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<!-- more -->\n\n```\nfunction add (x, y) {\n  return (x + y)\n}\n\nconsole.log(add(1, 2))\n\nfunction curriedAdd (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nconsole.log(curriedAdd(1)(3))\nconsole.log(curriedAdd(1)(3) === 4)\n\nfunction add (x, y) {\n  return (x + y)\n}\n\nfunction currying (fn, ...args1) {\n  return function (...args2) {\n    return fn(...args1, ...args2)\n  }\n}\n\ncurrying(add, 1)\ncurrying(add, 1)(2)\n```\n\n","source":"_posts/编译原理/JavaScript柯里化.md","raw":"---\ntitle: JavaScript柯里化\ndate: 2021-01-12 20:04:18\ntags: 编译原理\ncategories: 编译原理\n---\n\n<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<!-- more -->\n\n```\nfunction add (x, y) {\n  return (x + y)\n}\n\nconsole.log(add(1, 2))\n\nfunction curriedAdd (x) {\n  return function (y) {\n    return x + y\n  }\n}\n\nconsole.log(curriedAdd(1)(3))\nconsole.log(curriedAdd(1)(3) === 4)\n\nfunction add (x, y) {\n  return (x + y)\n}\n\nfunction currying (fn, ...args1) {\n  return function (...args2) {\n    return fn(...args1, ...args2)\n  }\n}\n\ncurrying(add, 1)\ncurrying(add, 1)(2)\n```\n\n","slug":"编译原理/JavaScript柯里化","published":1,"updated":"2021-01-15T21:20:23.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaat0033uhxxkih8upq9","content":"<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>\n\n<a id=\"more\"></a>\n<figure class=\"highlight plain hljs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\"></span><br><span class=\"line\">function curriedAdd (x) &#123;</span><br><span class=\"line\">  return function (y) &#123;</span><br><span class=\"line\">    return x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(curriedAdd(1)(3))</span><br><span class=\"line\">console.log(curriedAdd(1)(3) === 4)</span><br><span class=\"line\"></span><br><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function currying (fn, ...args1) &#123;</span><br><span class=\"line\">  return function (...args2) &#123;</span><br><span class=\"line\">    return fn(...args1, ...args2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">currying(add, 1)</span><br><span class=\"line\">currying(add, 1)(2)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(add(1, 2))</span><br><span class=\"line\"></span><br><span class=\"line\">function curriedAdd (x) &#123;</span><br><span class=\"line\">  return function (y) &#123;</span><br><span class=\"line\">    return x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(curriedAdd(1)(3))</span><br><span class=\"line\">console.log(curriedAdd(1)(3) === 4)</span><br><span class=\"line\"></span><br><span class=\"line\">function add (x, y) &#123;</span><br><span class=\"line\">  return (x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function currying (fn, ...args1) &#123;</span><br><span class=\"line\">  return function (...args2) &#123;</span><br><span class=\"line\">    return fn(...args1, ...args2)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">currying(add, 1)</span><br><span class=\"line\">currying(add, 1)(2)</span><br></pre></td></tr></table></figure>"},{"title":"前端脚手架","date":"2021-01-01T07:50:17.000Z","_content":"\n<p>工具封装，组件封装，网络请求库封装。</p>\n<!-- more -->\n\n","source":"_posts/脚手架/前端脚手架.md","raw":"---\ntitle: 前端脚手架\ndate: 2021-01-01 15:50:17\ntags: 脚手架\ncategories: 脚手架\n---\n\n<p>工具封装，组件封装，网络请求库封装。</p>\n<!-- more -->\n\n","slug":"脚手架/前端脚手架","published":1,"updated":"2021-01-15T21:25:02.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaau0036uhxxlxma09s0","content":"<p></p><p>工具封装，组件封装，网络请求库封装。</p>\n<a id=\"more\"></a><p></p>\n","site":{"data":{}},"excerpt":"<p></p><p>工具封装，组件封装，网络请求库封装。</p>","more":"<p></p>"},{"title":"传输协议","date":"2020-01-12T16:01:13.000Z","_content":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p>简述网络协议相关。</p>\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</ol>\n","source":"_posts/计算机网络/计算机网络.md","raw":"---\ntitle: 传输协议\ndate: 2020-1-13 00:01:13\ntags: 网络知识\ncategories: 计算机网络\n---\n<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p>简述网络协议相关。</p>\n<!-- more -->\n\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</ol>\n","slug":"计算机网络/计算机网络","published":1,"updated":"2021-01-15T21:26:30.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaav0039uhxxwwibxadb","content":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p></p><p>简述网络协议相关。</p>\n<a id=\"more\"></a><p></p>\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</li></ol>\n","site":{"data":{}},"excerpt":"<style type=\"text/css\">\n.pt{padding-top:10px;}\n</style>\n\n<p></p><p>简述网络协议相关。</p>","more":"<p></p>\n<ol>\n  <li class=\"pt\">\n    <p>HTTPS传输比HTTP传输的优势？</p>\n    <ul>\n      <li>HTTP协议以明文方式发送内容，不提供任何方式的数据加密。</li>\n      <li>HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li>\n      <li>使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>FTP的应用场景？</p>\n    <ul>\n      <li>迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代）</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>SMTP/POP3/IMAP的应用场景？</p>\n    <ul>\n      <li>电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>Telnet和SSH的应用场景？</p>\n    <ul>\n      <li>Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。</li>\n    </ul>\n  </li>\n  <li class=\"pt\">\n    <p>ws或wss(wss表示在TLS之上的Websocket)数据双向传输？</p>\n    <ul>\n      <li>允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送)</li>\n      <li>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。</li>\n    </ul>\n</li></ol>"},{"title":"HTTP响应代码","date":"2021-01-09T13:30:27.000Z","_content":"\n<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<!-- more -->\n\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理</il>\n  <li>200-299：成功状态码，用于表示请求正常处理完毕</il>\n  <li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转</il>\n  <li>400-499：客户端错误状态码，表示服务器无法处理请求</il>\n  <li>500-599：服务器错误状态码，表示服务器处理请求出错</il>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">常见code码：</h5>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">Protocol</h5>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>\n</ol>\n","source":"_posts/计算机网络/HTTP响应代码.md","raw":"---\ntitle: HTTP响应代码\ndate: 2021-01-09 21:30:27\ntags: 网络知识\ncategories: 计算机网络\n---\n\n<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<!-- more -->\n\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理</il>\n  <li>200-299：成功状态码，用于表示请求正常处理完毕</il>\n  <li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转</il>\n  <li>400-499：客户端错误状态码，表示服务器无法处理请求</il>\n  <li>500-599：服务器错误状态码，表示服务器处理请求出错</il>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">常见code码：</h5>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<h5 style=\"margin-top: 40px;\">Protocol</h5>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<h4 style=\"margin-top:50px;\"><附></h4>\n<ol>参考：\n  <li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>\n</ol>\n","slug":"计算机网络/HTTP响应代码","published":1,"updated":"2021-01-15T21:10:39.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckjytoaaw003cuhxxsd90jdxd","content":"<p>简述前端常见HTTP响应代码对应网络状态。</p>\n\n<a id=\"more\"></a>\n<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理\n  </li><li>200-299：成功状态码，用于表示请求正常处理完毕\n  </li><li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转\n  </li><li>400-499：客户端错误状态码，表示服务器无法处理请求\n  </li><li>500-599：服务器错误状态码，表示服务器处理请求出错\n</li></ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">常见code码：</h5><p></p>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">Protocol</h5><p></p>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>简述前端常见HTTP响应代码对应网络状态。</p>","more":"<ol>\n  <li>100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理\n  </li><li>200-299：成功状态码，用于表示请求正常处理完毕\n  </li><li>300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转\n  </li><li>400-499：客户端错误状态码，表示服务器无法处理请求\n  </li><li>500-599：服务器错误状态码，表示服务器处理请求出错\n</li></ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">常见code码：</h5><p></p>\n<ol>\n  <li>101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li>\n  <li>200 OK: 请求成功。</li>\n  <li>301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li>\n  <li>302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。</li>\n  <li>304 Not Modified: 协商缓存。</li>\n  <li>400 Bad Request: 请求参数有误。</li>\n  <li>403 Forbidden: 服务器已经理解请求，但是拒绝执行它。</li>\n  <li>404 Not Found: 请求失败。</li>\n  <li>500 Internal Server Error: 服务器遇到了不知道如何处理的情况。</li>\n</ol>\n\n<p></p><h5 style=\"margin-top: 40px;\">Protocol</h5><p></p>\n<ol>\n  <li>https</li>\n  <li>wss</li>\n  <li>blob</li>\n</ol>\n\n<p></p><h4 style=\"margin-top:50px;\">&lt;附&gt;</h4><p></p>\n<ol>参考：\n  <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a></li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"ckjytoa9k0000uhxx1h4sgyh9","category_id":"ckjrazwrj0002faxx2rza5uqb","_id":"ckjytoa9p0004uhxxqz1dzvii"},{"post_id":"ckjytoa9m0001uhxxylmkmddp","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9q0007uhxxhp88gvob"},{"post_id":"ckjytoa9o0002uhxx4r9xdmv2","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9u0009uhxxxj7j1plw"},{"post_id":"ckjytoa9o0003uhxx9xcxf6te","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9v000buhxx9unrnp87"},{"post_id":"ckjytoa9q0006uhxxxhtqsh30","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9w000duhxxogp62oxt"},{"post_id":"ckjytoa9r0008uhxx9ld58p37","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9x000guhxxfzdf2tlc"},{"post_id":"ckjytoa9v000auhxxw59ea19x","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoa9z000juhxxur0hnmwf"},{"post_id":"ckjytoa9w000cuhxxgr6baymb","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa0000luhxxv584g2uk"},{"post_id":"ckjytoa9x000fuhxxivh7bvc2","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa1000nuhxxlh10kbsl"},{"post_id":"ckjytoa9y000iuhxxp4btkrto","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa2000quhxx3mrg17gl"},{"post_id":"ckjytoaa0000kuhxxtc9mueua","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa3000tuhxxtw48it1u"},{"post_id":"ckjytoaa1000muhxxlylrdg1p","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa4000vuhxxx9qvszbg"},{"post_id":"ckjytoaa2000puhxxdr0ry871","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaa5000xuhxx1zy0bct4"},{"post_id":"ckjytoaa2000suhxxoo67lwys","category_id":"ckjrazwrm0006faxxdjh089hp","_id":"ckjytoaa5000zuhxxn09vjzxf"},{"post_id":"ckjytoaa3000uuhxxlhtetb2e","category_id":"ckjrazws80022faxx6gomuqv1","_id":"ckjytoaa60012uhxxpj5z7au0"},{"post_id":"ckjytoaa4000wuhxxmih530ph","category_id":"ckjrazws80022faxx6gomuqv1","_id":"ckjytoaa70015uhxx164ia18m"},{"post_id":"ckjytoaa5000yuhxxj7mh934n","category_id":"ckjrazws80022faxx6gomuqv1","_id":"ckjytoaa80017uhxx8h6wb3o1"},{"post_id":"ckjytoaa60011uhxxzspbs7vf","category_id":"ckjrazwsh002wfaxxxjwjiej4","_id":"ckjytoaa9001auhxx4ab3n6d7"},{"post_id":"ckjytoaa70014uhxxvxicq9se","category_id":"ckjrazws80022faxx6gomuqv1","_id":"ckjytoaaa001cuhxxxruum44b"},{"post_id":"ckjytoaa70016uhxxj5bm4yxk","category_id":"ckjrazwsp003ffaxxopkb5mt6","_id":"ckjytoaaa001fuhxxmfwgo2wr"},{"post_id":"ckjytoaa80019uhxxljhboeoq","category_id":"ckjw93t1a002i9oxxhhzi3hgk","_id":"ckjytoaab001iuhxxi7y0it4c"},{"post_id":"ckjytoaa9001buhxxyy44wgtt","category_id":"ckjrazwsr003ofaxxvsk65zxw","_id":"ckjytoaac001luhxxy0elv168"},{"post_id":"ckjytoaaa001euhxx70aog95l","category_id":"ckjrazwth005yfaxxzdmwwegy","_id":"ckjytoaac001ouhxx37oafv08"},{"post_id":"ckjytoaab001huhxx5xh53zy2","category_id":"ckjrazwsr003ofaxxvsk65zxw","_id":"ckjytoaad001ruhxxjj1iqguy"},{"post_id":"ckjytoaab001kuhxxg35y610k","category_id":"ckjrazwth005yfaxxzdmwwegy","_id":"ckjytoaae001uuhxxarad31yn"},{"post_id":"ckjytoaac001nuhxxflatr23y","category_id":"ckjrazwth005yfaxxzdmwwegy","_id":"ckjytoaaf001xuhxxm8wc5nlb"},{"post_id":"ckjytoaad001quhxxpr1ly6k2","category_id":"ckjv2uqqx00169oxxin4sdo1n","_id":"ckjytoaag0020uhxxf5fnv80i"},{"post_id":"ckjytoaae001tuhxxiw64yb3e","category_id":"ckjrazwtl006lfaxxu1xgfsvj","_id":"ckjytoaah0023uhxxlgm0w1gc"},{"post_id":"ckjytoaaf001zuhxxbcnks8co","category_id":"ckjrazwtl006lfaxxu1xgfsvj","_id":"ckjytoaai0029uhxxxgxjuhho"},{"post_id":"ckjytoaag0022uhxxja60ra60","category_id":"ckjrazwtn006tfaxxxkpzudtg","_id":"ckjytoaaj002buhxxuoe0r7p3"},{"post_id":"ckjytoaah0025uhxxrkyws12r","category_id":"ckjrazwtp007cfaxxbjely5gp","_id":"ckjytoaak002duhxxgdti2hp9"},{"post_id":"ckjytoaai0028uhxxhnfx06d9","category_id":"ckjrazwtq007jfaxxgvr11aaf","_id":"ckjytoaak002guhxxxa6xpz9l"},{"post_id":"ckjytoaai002auhxxzj088dpv","category_id":"ckjrazwtr007qfaxxy9r2x8a5","_id":"ckjytoaam002juhxxiqdhs5qh"},{"post_id":"ckjytoaaj002cuhxx84ftv52j","category_id":"ckjrazwtr007qfaxxy9r2x8a5","_id":"ckjytoaao002muhxxf0sl7led"},{"post_id":"ckjytoaak002fuhxxyn1q45rl","category_id":"ckjrazwtr007nfaxxeduyr9r9","_id":"ckjytoaap002puhxxe2wh09kh"},{"post_id":"ckjytoaal002iuhxx99rh9x6p","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaaq002suhxx4ghll6jd"},{"post_id":"ckjytoaan002luhxx6xs17a1o","category_id":"ckjrazwro000bfaxxtaj0xzih","_id":"ckjytoaar002vuhxxodzzh4e7"},{"post_id":"ckjytoaao002ouhxxlhvk3cjd","category_id":"ckjrazwsr003ofaxxvsk65zxw","_id":"ckjytoaas002yuhxxu3kc7j3s"},{"post_id":"ckjytoaap002ruhxxlogxo9a1","category_id":"ckjw93t1a002i9oxxhhzi3hgk","_id":"ckjytoaas0031uhxxt0azy41f"},{"post_id":"ckjytoaaq002uuhxx98lxis7j","category_id":"ckjw93t1a002i9oxxhhzi3hgk","_id":"ckjytoaau0034uhxxx6jp8zp6"},{"post_id":"ckjytoaar002xuhxxunu4tovy","category_id":"ckjrazwsr003ofaxxvsk65zxw","_id":"ckjytoaav0037uhxxlikbj0t2"},{"post_id":"ckjytoaas0030uhxxaglz7sw0","category_id":"ckjrazwth005yfaxxzdmwwegy","_id":"ckjytoaaw003auhxx6jp99by7"},{"post_id":"ckjytoaat0033uhxxkih8upq9","category_id":"ckjrazwto0075faxxkav8xrje","_id":"ckjytoaax003duhxxy4mecm2z"},{"post_id":"ckjytoaau0036uhxxlxma09s0","category_id":"ckjrazwtq007lfaxxdl8768vk","_id":"ckjytoaax003fuhxxakitzx8a"},{"post_id":"ckjytoaav0039uhxxwwibxadb","category_id":"ckjrazwtr007nfaxxeduyr9r9","_id":"ckjytoaax003huhxxldyebkf2"},{"post_id":"ckjytoaaw003cuhxxsd90jdxd","category_id":"ckjrazwtr007nfaxxeduyr9r9","_id":"ckjytoaax003iuhxx7wj0v88b"}],"PostTag":[{"post_id":"ckjytoa9o0002uhxx4r9xdmv2","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoa9q0005uhxxoqmu95lc"},{"post_id":"ckjytoa9v000auhxxw59ea19x","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoa9x000euhxx44dipj8r"},{"post_id":"ckjytoa9w000cuhxxgr6baymb","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoa9y000huhxxeqtpozy3"},{"post_id":"ckjytoaa0000kuhxxtc9mueua","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoaa2000ouhxx7tdmrw8v"},{"post_id":"ckjytoaa1000muhxxlylrdg1p","tag_id":"ckjrazwry0012faxxevkjmax1","_id":"ckjytoaa2000ruhxxj6wd959o"},{"post_id":"ckjytoaa4000wuhxxmih530ph","tag_id":"ckjrazws2001ifaxxfuq349vk","_id":"ckjytoaa60010uhxxyjfefcu9"},{"post_id":"ckjytoaa5000yuhxxj7mh934n","tag_id":"ckjrazws2001ifaxxfuq349vk","_id":"ckjytoaa70013uhxx75mt6b1b"},{"post_id":"ckjytoaa70014uhxxvxicq9se","tag_id":"ckjrazws2001ifaxxfuq349vk","_id":"ckjytoaa80018uhxxzq8dqx6o"},{"post_id":"ckjytoaa80019uhxxljhboeoq","tag_id":"ckjw93t1b002j9oxx5qgw1lh3","_id":"ckjytoaaa001duhxxqx6ehw1w"},{"post_id":"ckjytoaa9001buhxxyy44wgtt","tag_id":"ckjrazwsd002ifaxxz6wrtxx5","_id":"ckjytoaaa001guhxx4qu4smt4"},{"post_id":"ckjytoaaa001euhxx70aog95l","tag_id":"ckjrazwsq003jfaxxtnpodzwf","_id":"ckjytoaab001juhxx188zh4ng"},{"post_id":"ckjytoaab001huhxx5xh53zy2","tag_id":"ckjrazwsd002ifaxxz6wrtxx5","_id":"ckjytoaac001muhxxj7cj5ago"},{"post_id":"ckjytoaab001kuhxxg35y610k","tag_id":"ckjrazwsq003jfaxxtnpodzwf","_id":"ckjytoaad001puhxxqaige5lv"},{"post_id":"ckjytoaac001nuhxxflatr23y","tag_id":"ckjrazwsq003jfaxxtnpodzwf","_id":"ckjytoaae001suhxx9x1vuey9"},{"post_id":"ckjytoaad001quhxxpr1ly6k2","tag_id":"ckjrazwt2004rfaxxo0h2oqod","_id":"ckjytoaae001vuhxx8bui2mov"},{"post_id":"ckjytoaae001tuhxxiw64yb3e","tag_id":"ckjrazwsw0046faxxu501cosy","_id":"ckjytoaaf001yuhxxk2flguoa"},{"post_id":"ckjytoaaf001zuhxxbcnks8co","tag_id":"ckjrazwsw0046faxxu501cosy","_id":"ckjytoaah0024uhxxzupnzf9z"},{"post_id":"ckjytoaag0022uhxxja60ra60","tag_id":"ckjrazwt0004kfaxxeljhmw55","_id":"ckjytoaai0027uhxxbvu3eg9c"},{"post_id":"ckjytoaai002auhxxzj088dpv","tag_id":"ckjrazwtk006bfaxxbegd2kks","_id":"ckjytoaak002euhxx9v74di18"},{"post_id":"ckjytoaaj002cuhxx84ftv52j","tag_id":"ckjrazwtk006bfaxxbegd2kks","_id":"ckjytoaal002huhxx0b3y7sf4"},{"post_id":"ckjytoaak002fuhxxyn1q45rl","tag_id":"ckjrazwti0062faxxpt0mlm2p","_id":"ckjytoaan002kuhxxt0avbvbi"},{"post_id":"ckjytoaal002iuhxx99rh9x6p","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoaao002nuhxxtsql3376"},{"post_id":"ckjytoaan002luhxx6xs17a1o","tag_id":"ckjrazwrn0008faxxk59es0yg","_id":"ckjytoaap002quhxx1zvq0sur"},{"post_id":"ckjytoaao002ouhxxlhvk3cjd","tag_id":"ckjrazwsd002ifaxxz6wrtxx5","_id":"ckjytoaaq002tuhxx5k2s82pn"},{"post_id":"ckjytoaap002ruhxxlogxo9a1","tag_id":"ckjw93t1b002j9oxx5qgw1lh3","_id":"ckjytoaar002wuhxxmh05ylau"},{"post_id":"ckjytoaaq002uuhxx98lxis7j","tag_id":"ckjw93t1b002j9oxx5qgw1lh3","_id":"ckjytoaas002zuhxxswkjqet6"},{"post_id":"ckjytoaar002xuhxxunu4tovy","tag_id":"ckjrazwsd002ifaxxz6wrtxx5","_id":"ckjytoaat0032uhxxydq2fpug"},{"post_id":"ckjytoaas0030uhxxaglz7sw0","tag_id":"ckjrazwsq003jfaxxtnpodzwf","_id":"ckjytoaau0035uhxx29va33vk"},{"post_id":"ckjytoaat0033uhxxkih8upq9","tag_id":"ckjrazwt4004xfaxx85pbso59","_id":"ckjytoaav0038uhxxt8fro1vr"},{"post_id":"ckjytoaau0036uhxxlxma09s0","tag_id":"ckjrazwth005xfaxxqz1imptz","_id":"ckjytoaaw003buhxx6tgapzeg"},{"post_id":"ckjytoaav0039uhxxwwibxadb","tag_id":"ckjrazwti0062faxxpt0mlm2p","_id":"ckjytoaax003euhxxv3yh1qq9"},{"post_id":"ckjytoaaw003cuhxxsd90jdxd","tag_id":"ckjrazwti0062faxxpt0mlm2p","_id":"ckjytoaax003guhxxjhntsqd4"}],"Tag":[{"name":"编程语言","_id":"ckjrazwrn0008faxxk59es0yg"},{"name":"书籍","_id":"ckjrazwrw000vfaxxefp5x2xf"},{"name":"前后端分离","_id":"ckjrazwry0012faxxevkjmax1"},{"name":"工具","_id":"ckjrazws2001ifaxxfuq349vk"},{"name":"性能","_id":"ckjrazwsb002bfaxx4oy0z1wm"},{"name":"架构","_id":"ckjrazwsd002ifaxxz6wrtxx5"},{"name":"服务端渲染","_id":"ckjrazwsh002vfaxxngm6gnl2"},{"name":"框架","_id":"ckjrazwsq003jfaxxtnpodzwf"},{"name":"浏览器","_id":"ckjrazwsw0046faxxu501cosy"},{"name":"程序设计","_id":"ckjrazwt0004kfaxxeljhmw55"},{"name":"算法","_id":"ckjrazwt2004rfaxxo0h2oqod"},{"name":"编译原理","_id":"ckjrazwt4004xfaxx85pbso59"},{"name":"编程范式","_id":"ckjrazwtf005sfaxxfl0mq0rv"},{"name":"脚手架","_id":"ckjrazwth005xfaxxqz1imptz"},{"name":"网络知识","_id":"ckjrazwti0062faxxpt0mlm2p"},{"name":"设计模式","_id":"ckjrazwtk006bfaxxbegd2kks"},{"name":"源码","_id":"ckjrazwtl006jfaxxf64h8xnn"},{"name":"操作系统","_id":"ckjuxsbl2000t9oxxctktimfp"},{"name":"数据库","_id":"ckjvfetro001q9oxxp9nzjy38"},{"name":"异常&性能","_id":"ckjw93t1b002j9oxx5qgw1lh3"}]}}